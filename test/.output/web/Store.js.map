{"version":3,"sources":["D:/tools/es-vue/dist/types/web/Store.es"],"names":["key","storeProxy","storeInstance","creator","getInstances","dataset","System","getConfig","setConfig","Map","_plugins","setPlugins","plugins","push","_getActivePinia","getActivePinia","main","registerOnceHook","app","pinia","createPinia","setActivePinia","forEach","plugin","use","vue","getAttribute","storeClass","Store","instance","get","create","set","getOptions","getStorage","descriptor","Reflect","getDescriptor","states","getters","actions","members","bindMethods","selfMethods","selfProperties","publicMethods","_proxy","Proxy","target","receiver","includes","hasOwnProperty","bind","desc","store","$state","call","ReferenceError","String","toString","whenPropertyNotExists","value","name","id","namespace","className","setupOptions","state","options","newStore","defineStore","setState","getState","patch","data","$patch","onAction","callback","always","$onAction","subscribe","$subscribe","watch","_watch","dispose","$dispose","reset","$reset"],"mappings":"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","sourcesContent":["package web{\r\n\r\n    import {defineStore, createPinia,getActivePinia,setActivePinia} from 'pinia'; \r\n    import {watch as _watch} from 'vue';\r\n    import {computed, ref, toRefs, markRaw} from '@vue/reactivity';\r\n    class Store{\r\n\r\n        static private getInstances():Map<class<Store>,Store>{\r\n            let dataset = System.getConfig('globals.webStoreInstances');\r\n            if(!dataset){\r\n                System.setConfig('globals.webStoreInstances', dataset=new Map());\r\n            }\r\n            return dataset;\r\n        }\r\n\r\n        static private _plugins = []\r\n        static setPlugins(plugins:any[]){\r\n            _plugins.push(...plugins)\r\n        }\r\n\r\n        static private _getActivePinia():PiniaInstance{\r\n            return System.getConfig('globals.store.pinia.active.instance') || getActivePinia();\r\n        }\r\n\r\n        @Main(false)\r\n        static main(){\r\n            when(Syntax('es-nuxt')){\r\n                System.registerOnceHook('application:created', (app)=>{\r\n                    const nuxt = app.getAttribute('nuxtApp') as Record;\r\n                    const pinia = nuxt.$pinia as PiniaInstance\r\n                    System.setConfig('globals.store.pinia.active.instance', pinia)\r\n                    _plugins.forEach(plugin=>{\r\n                        pinia.use(plugin)\r\n                    })\r\n                })\r\n            }then{\r\n                System.registerOnceHook('application:created', (app)=>{\r\n                    const pinia =createPinia() as PiniaInstance\r\n                    setActivePinia(pinia);\r\n                    System.setConfig('globals.store.pinia.active.instance', pinia)\r\n                    _plugins.forEach(plugin=>{\r\n                        pinia.use(plugin)\r\n                    })\r\n                    const vue = app.getAttribute('vueApp');\r\n                    vue.use(pinia);\r\n                });\r\n            }\r\n        }\r\n\r\n        static use<T extends class<Store>>(storeClass:T){\r\n            let dataset = Store.getInstances();\r\n            let instance = dataset.get(storeClass) as Store;\r\n            if(!instance){\r\n                instance = new storeClass() as Store;\r\n                instance.create();\r\n                dataset.set(storeClass, instance);\r\n            }\r\n            return instance.storeProxy as T;\r\n        }\r\n\r\n        protected key = 'store';\r\n\r\n        protected getOptions(){\r\n            return {}\r\n        }\r\n\r\n        protected getStorage(){\r\n            return {}\r\n        }\r\n\r\n        protected create(){\r\n            const descriptor = Reflect.getDescriptor(this) || {};\r\n            const states = this.getStorage();\r\n            const getters = {};\r\n            const actions = {};\r\n\r\n            type DT = {[key:string]:any, value?:Function, get?:Function, set?:Function};\r\n            const members:{[key:string]:DT}[] = (descriptor.members || []) as any[];\r\n            const bindMethods = {};\r\n            const selfMethods = ['setState','getState','whenPropertyNotExists','getOptions','getStorage'];\r\n            const selfProperties = ['storeInstance','key','storeProxy'];\r\n            const publicMethods = ['patch','onAction','reset','subscribe','watch','dispose']\r\n            const _proxy = new Proxy(this, {\r\n                get:(target,key,receiver)=>{\r\n                    if(descriptor.privateKey === key){\r\n                        return this[descriptor.privateKey];\r\n                    }\r\n                    if(selfMethods.includes(key)){\r\n                        if( bindMethods.hasOwnProperty(key) ){\r\n                            return bindMethods[key];\r\n                        }\r\n                        return bindMethods[key] = (this[key] as Function).bind(this);\r\n                    }else if(selfProperties.includes(key)){\r\n                        return this[key];\r\n                    }\r\n\r\n                    const desc = members[key];\r\n                    if(desc){\r\n                        if(desc.label==='property'){\r\n                            if(desc.permission==='public'){\r\n                                return store.$state[key];\r\n                            }\r\n                            return this[key];\r\n                        }else if(desc.label==='accessor'){\r\n                            if(desc.get){\r\n                                return desc.get.call(this);\r\n                            }else{\r\n                                throw new ReferenceError(`Store property the \"${key}\" is not readable.`) \r\n                            }\r\n                        }else if(desc.label==='method'){\r\n                            if( bindMethods.hasOwnProperty(key) ){\r\n                                return bindMethods[key];\r\n                            }\r\n                            return bindMethods[key] = desc.value.bind(this);\r\n                        }\r\n                    }else{\r\n                        key = String(key);\r\n                        if(key==='Symbol(Symbol.toStringTag)'){\r\n                            return this.toString()\r\n                        }else{\r\n                            return this.whenPropertyNotExists(key);\r\n                        }\r\n                    }\r\n                },\r\n                set:(target,key,value)=>{\r\n                    const desc = members[key];\r\n                    if(desc){\r\n                        if(desc.label==='property'){\r\n                            if(desc.permission==='public'){\r\n                                store.$state[key]=value\r\n                            }else{\r\n                                this[key] = value;\r\n                            }\r\n                            return true\r\n                        }else if(desc.label==='accessor'){\r\n                            if(desc.set){\r\n                                desc.set.call(this, value);\r\n                                return true;\r\n                            }\r\n                        }\r\n                        throw new ReferenceError(`Store property the \"${key}\" is not writable.`)\r\n                    }else{\r\n                        throw new ReferenceError(`Store properties the \"${key}\" is not exist.`)\r\n                    }\r\n                }\r\n            });\r\n\r\n            for(let name in members){\r\n                const desc = members[name];\r\n                if(desc.permission!=='public')continue;\r\n                if(desc.label==='property'){\r\n                    if(!states.hasOwnProperty(name)){\r\n                        states[name] = desc.value;\r\n                    }\r\n                }else if(desc.label==='accessor'){\r\n                    if(desc.get){\r\n                        getters[name] = desc.get.bind(_proxy);\r\n                    }\r\n                }else if(desc.label==='method'){\r\n                    actions[name] = desc.value.bind(_proxy);\r\n                }\r\n            }\r\n\r\n            const pinia = _getActivePinia();\r\n            const id = this.key+':'+(descriptor.namespace ? descriptor.namespace +'.'+ descriptor.className : descriptor.className);\r\n            \r\n            let setupOptions = {\r\n                state:()=>states,\r\n                getters,\r\n                actions\r\n            }\r\n\r\n            let store:StoreInstance = null;\r\n            let options = this.getOptions();\r\n\r\n            when( Env(mode, 'production', expect=false) ){\r\n                const oldStore = pinia._s.get(id);\r\n                const newStore = defineStore(id, setupOptions, options) as Function;\r\n                if(oldStore){\r\n                    store = newStore(pinia, oldStore);\r\n                }else{\r\n                    store = newStore();\r\n                }\r\n            }then{\r\n                const newStore = defineStore(id, setupOptions, options) as Function;\r\n                store = newStore();\r\n            }\r\n\r\n            this.storeInstance = store;\r\n            this.storeProxy = new Proxy(store, {\r\n                set:(target,key,value)=>{\r\n                    const desc = members[key];\r\n                    if(!desc){\r\n                        throw new ReferenceError(`Store property the \"${key}\" is not exist`)\r\n                    }\r\n                    if(desc.permission!=='public'){\r\n                        throw new ReferenceError(`Store ${desc.label} the \"${key}\" is not accessible`)\r\n                    }\r\n                    if(desc.label==='accessor'){\r\n                        if(desc.set){\r\n                            desc.set.call(this, value);\r\n                            return true;\r\n                        }else{\r\n                            throw new ReferenceError(`Store property the \"${key}\" is not writable.`)\r\n                        }\r\n                    }else if(desc.label==='property'){\r\n                        if(desc.writable){\r\n                            store.$state[key] = value;\r\n                            return true;\r\n                        }else{\r\n                            throw new ReferenceError(`Store state the \"${key}\" is not writable.`)\r\n                        }\r\n                    }else{\r\n                        throw new ReferenceError(`Store property the \"${key}\" is not writable`)\r\n                    }\r\n                },\r\n                get:(target,key,receiver)=>{\r\n                    if(key===\"$id\"){\r\n                        return store[key];\r\n                    }\r\n                    if(publicMethods.includes(key)){\r\n                        if( bindMethods.hasOwnProperty(key) ){\r\n                            return bindMethods[key];\r\n                        }\r\n                        return bindMethods[key] = (this[key] as Function).bind(this);\r\n                    }\r\n                    const desc = members[key];\r\n                    if(!desc){\r\n                        return this.whenPropertyNotExists(String(key))\r\n                    }\r\n                    if(desc.permission!=='public'){\r\n                        throw new ReferenceError(`Store ${desc.label} the \"${key}\" is not accessible`)\r\n                    }\r\n                    //getters computed 在服务端使用了缓存导致与客户端状态不同步\r\n                    when(Env(platform, server)){\r\n                        when(Env(mode, development)){\r\n                            if(desc.get){\r\n                                return desc.get.call(this)\r\n                            }\r\n                        }\r\n                    }\r\n                    return store[key];\r\n                }\r\n            });\r\n        }\r\n\r\n        protected storeProxy=null;\r\n        protected storeInstance:StoreInstance= null\r\n\r\n        protected setState(name:string, value:any){\r\n            this.storeInstance.$state[':'+name] = value;\r\n        }\r\n\r\n        protected getState<T=any>(name:string){\r\n            return this.storeInstance.$state[':'+name] as T;\r\n        }\r\n\r\n        protected whenPropertyNotExists(key){\r\n            throw new ReferenceError(`Store property the \"${key}\" is not exist.`)\r\n        }\r\n\r\n        patch(data:Record|(states:Record)=>void){\r\n            this.storeInstance.$patch(data);\r\n        }\r\n\r\n        onAction(callback:(options:{\r\n            name?:string,\r\n            store?:{},\r\n            args?:any[],\r\n            after?:(callback:(...args)=>void)=>void,\r\n            onError?:(callback:(...args)=>void)=>void,\r\n        })=>void, always=false){\r\n           return this.storeInstance.$onAction(callback, always);\r\n        }\r\n\r\n        subscribe(callback:(mutation:Record, state:Record)=>void, options?:{detached: boolean}&Record){\r\n            this.storeInstance.$subscribe(callback);\r\n        }\r\n\r\n        watch(callback:vue.WatchCallback<Record>, options?:vue.WatchOptions):()=>void{\r\n            return _watch(this.storeInstance.$state, callback, options)\r\n        }\r\n\r\n        dispose(){\r\n            this.storeInstance.$dispose();\r\n        }\r\n\r\n        reset(){\r\n            this.storeInstance.$reset();\r\n        }\r\n    }\r\n\r\n    declare interface StoreInstance{\r\n        $state:Record\r\n        $onAction:(...args)=>(()=>void)\r\n        $reset:(...args)=>void\r\n        $patch:(...args)=>void\r\n        $subscribe:(...args)=>void\r\n        $dispose:()=>void\r\n        [key:string]:any\r\n    }\r\n\r\n    declare interface PiniaInstance{\r\n        install(app):void\r\n        use(plugin):this\r\n        _p:any[]\r\n        _a:any\r\n        _e:any\r\n        _s:Map<string,any>\r\n        state:{value:Record<Record<any>>}\r\n    }\r\n}\r\n\r\n\r\n"]}