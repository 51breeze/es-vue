{"version":3,"sources":["D:/tools/es-vue/dist/types/web/Store.es"],"names":["getKeySymbols","key","storeProxy","storeInstance","creator","getInstances","dataset","System","getConfig","setConfig","Map","_plugins","setPlugins","plugins","push","_getActivePinia","getActivePinia","main","registerOnceHook","app","pinia","createPinia","setActivePinia","forEach","plugin","use","vue","getAttribute","storeClass","Store","instance","get","create","set","getOptions","getStorage","descriptor","Reflect","getDescriptor","states","getters","actions","members","console","log","bindMethods","selfMethods","selfProperties","publicMethods","_proxy","Proxy","target","receiver","isPrivatePropertyKey","includes","hasOwnProperty","bind","desc","getMemberDescriptor","isProperty","isPublic","store","$state","isAccessor","getter","invokeGetter","ReferenceError","isMethod","call","value","String","toString","whenPropertyNotExists","setter","invokeSetter","id","namespace","className","setupOptions","state","options","newStore","defineStore","label","writable","setState","name","getState","patch","data","$patch","onAction","callback","always","$onAction","subscribe","$subscribe","watch","_watch","dispose","$dispose","reset","$reset"],"mappings":"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","sourcesContent":["package web{\r\n\r\n    import {defineStore, createPinia,getActivePinia,setActivePinia} from 'pinia'; \r\n    import {watch as _watch} from 'vue';\r\n    import {computed, ref, toRefs, markRaw} from '@vue/reactivity';\r\n    class Store{\r\n\r\n        static private getInstances():Map<class<Store>,Store>{\r\n            let dataset = System.getConfig('globals.webStoreInstances');\r\n            if(!dataset){\r\n                System.setConfig('globals.webStoreInstances', dataset=new Map());\r\n            }\r\n            return dataset;\r\n        }\r\n\r\n        static private _plugins = []\r\n        static setPlugins(plugins:any[]){\r\n            _plugins.push(...plugins)\r\n        }\r\n\r\n        static private _getActivePinia():PiniaInstance{\r\n            return System.getConfig('globals.store.pinia.active.instance') || getActivePinia();\r\n        }\r\n\r\n        @Main(false)\r\n        static main(){\r\n            when(Syntax('es-nuxt')){\r\n                System.registerOnceHook('application:created', (app)=>{\r\n                    const nuxt = app.getAttribute('nuxtApp') as Record;\r\n                    const pinia = nuxt.$pinia as PiniaInstance\r\n                    System.setConfig('globals.store.pinia.active.instance', pinia)\r\n                    _plugins.forEach(plugin=>{\r\n                        pinia.use(plugin)\r\n                    })\r\n                })\r\n            }then{\r\n                System.registerOnceHook('application:created', (app)=>{\r\n                    const pinia =createPinia() as PiniaInstance\r\n                    setActivePinia(pinia);\r\n                    System.setConfig('globals.store.pinia.active.instance', pinia)\r\n                    _plugins.forEach(plugin=>{\r\n                        pinia.use(plugin)\r\n                    })\r\n                    const vue = app.getAttribute('vueApp');\r\n                    vue.use(pinia);\r\n                });\r\n            }\r\n        }\r\n\r\n        static use<T extends class<Store>>(storeClass:T){\r\n            let dataset = Store.getInstances();\r\n            let instance = dataset.get(storeClass) as Store;\r\n            if(!instance){\r\n                instance = new storeClass() as Store;\r\n                instance.create();\r\n                dataset.set(storeClass, instance);\r\n            }\r\n            return instance.storeProxy as T;\r\n        }\r\n\r\n        protected key = 'store';\r\n\r\n        protected getOptions(){\r\n            return {}\r\n        }\r\n\r\n        protected getStorage(){\r\n            return {}\r\n        }\r\n\r\n        protected create(){\r\n            const descriptor = Reflect.getDescriptor(this);\r\n            const states = this.getStorage();\r\n            const getters = {};\r\n            const actions = {};\r\n            const members:MemberDescriptor[] = descriptor.members;\r\n\r\n\r\n            console.log( members ,\"=========members===============\" )\r\n\r\n\r\n\r\n\r\n            const bindMethods = {};\r\n            const selfMethods = ['setState','getState','whenPropertyNotExists','getOptions','getStorage'];\r\n            const selfProperties = ['storeInstance','key','storeProxy'];\r\n            const publicMethods = ['patch','onAction','reset','subscribe','watch','dispose']\r\n            const _proxy = new Proxy(this, {\r\n                get:(target,key,receiver)=>{\r\n                    if(descriptor.isPrivatePropertyKey(key)){\r\n                        return this[key];\r\n                    }\r\n                    if(selfMethods.includes(key)){\r\n                        if( bindMethods.hasOwnProperty(key) ){\r\n                            return bindMethods[key];\r\n                        }\r\n                        return bindMethods[key] = (this[key] as Function).bind(this);\r\n                    }else if(selfProperties.includes(key)){\r\n                        return this[key];\r\n                    }\r\n\r\n                    const desc = descriptor.getMemberDescriptor(key);\r\n                    if(desc){\r\n                        if(desc.isProperty()){\r\n                            if(desc.isPublic()){\r\n                                return store.$state[key];\r\n                            }\r\n                            return this[key];\r\n                        }else if(desc.isAccessor()){\r\n                            if(desc.getter){\r\n                                return desc.invokeGetter(this);\r\n                            }else{\r\n                                throw new ReferenceError(`Store property the \"${key}\" is not readable.`) \r\n                            }\r\n                        }else if(desc.isMethod()){\r\n                            if( bindMethods.hasOwnProperty(key) ){\r\n                                return bindMethods[key];\r\n                            }\r\n                            return bindMethods[key] = desc.value.bind(this);\r\n                        }\r\n                    }else{\r\n                        key = String(key);\r\n                        if(key==='Symbol(Symbol.toStringTag)'){\r\n                            return this.toString()\r\n                        }else{\r\n                            return this.whenPropertyNotExists(key);\r\n                        }\r\n                    }\r\n                },\r\n                set:(target,key,value)=>{\r\n                    const desc = descriptor.getMemberDescriptor(key);\r\n                    if(desc){\r\n                        if(desc.isProperty()){\r\n                            if(desc.isPublic()){\r\n                                store.$state[key]=value\r\n                            }else{\r\n                                this[key] = value;\r\n                            }\r\n                            return true\r\n                        }else if(desc.isAccessor()){\r\n                            if(desc.setter){\r\n                                desc.invokeSetter(this, value);\r\n                                return true;\r\n                            }\r\n                        }\r\n                        throw new ReferenceError(`Store property the \"${key}\" is not writable.`)\r\n                    }else{\r\n                        throw new ReferenceError(`Store properties the \"${key}\" is not exist.`)\r\n                    }\r\n                }\r\n            });\r\n\r\n            members.forEach( desc=>{\r\n                if(!desc.isPublic())return;\r\n                if(desc.isProperty()){\r\n                    if(!states.hasOwnProperty(desc.key)){\r\n                        states[desc.key] = desc.value;\r\n                    }\r\n                }else if(desc.isAccessor()){\r\n                    if(desc.getter){\r\n                        getters[desc.key] = desc.getter.bind(_proxy);\r\n                    }\r\n                }else if(desc.isMethod()){\r\n                    actions[desc.key] = desc.value.bind(_proxy);\r\n                }\r\n            })\r\n\r\n            const pinia = _getActivePinia();\r\n            const id = this.key+':'+(descriptor.namespace ? descriptor.namespace +'.'+ descriptor.className : descriptor.className);\r\n            \r\n            let setupOptions = {\r\n                state:()=>states,\r\n                getters,\r\n                actions\r\n            }\r\n\r\n            let store:StoreInstance = null;\r\n            let options = this.getOptions();\r\n\r\n            when( Env(mode, 'production', expect=false) ){\r\n                const oldStore = pinia._s.get(id);\r\n                const newStore = defineStore(id, setupOptions, options) as Function;\r\n                if(oldStore){\r\n                    store = newStore(pinia, oldStore);\r\n                }else{\r\n                    store = newStore();\r\n                }\r\n            }then{\r\n                const newStore = defineStore(id, setupOptions, options) as Function;\r\n                store = newStore();\r\n            }\r\n\r\n            this.storeInstance = store;\r\n            this.storeProxy = new Proxy(store, {\r\n                set:(target,key,value)=>{\r\n                    const desc = descriptor.getMemberDescriptor(key);\r\n                    if(!desc){\r\n                        throw new ReferenceError(`Store property the \"${key}\" 222 is not exist`)\r\n                    }\r\n                    if(!desc.isPublic()){\r\n                        throw new ReferenceError(`Store ${desc.label} the \"${key}\" is not accessible`)\r\n                    }\r\n                    if(desc.isAccessor()){\r\n                        if(desc.setter){\r\n                            desc.invokeSetter(this, value);\r\n                            return true;\r\n                        }else{\r\n                            throw new ReferenceError(`Store property the \"${key}\" is not writable.`)\r\n                        }\r\n                    }else if(desc.isProperty()){\r\n                        if(desc.writable){\r\n                            store.$state[key] = value;\r\n                            return true;\r\n                        }else{\r\n                            throw new ReferenceError(`Store state the \"${key}\" is not writable.`)\r\n                        }\r\n                    }else{\r\n                        throw new ReferenceError(`Store property the \"${key}\" is not writable`)\r\n                    }\r\n                },\r\n                get:(target,key,receiver)=>{\r\n                    if(key===\"$id\"){\r\n                        return store[key];\r\n                    }\r\n                    if(publicMethods.includes(key)){\r\n                        if( bindMethods.hasOwnProperty(key) ){\r\n                            return bindMethods[key];\r\n                        }\r\n                        return bindMethods[key] = (this[key] as Function).bind(this);\r\n                    }\r\n                    const desc = descriptor.getMemberDescriptor(key);\r\n                    if(!desc){\r\n                        return this.whenPropertyNotExists(String(key))\r\n                    }\r\n                    if(!desc.isPublic()){\r\n                        throw new ReferenceError(`Store ${desc.label} the \"${key}\" is not accessible`)\r\n                    }\r\n                    //getters computed 在服务端使用了缓存导致与客户端状态不同步\r\n                    when(Env(platform, server)){\r\n                        when(Env(mode, development)){\r\n                            if(desc.getter){\r\n                                return desc.invokeGetter(this)\r\n                            }\r\n                        }\r\n                    }\r\n                    return store[key];\r\n                }\r\n            });\r\n        }\r\n\r\n        protected storeProxy=null;\r\n        protected storeInstance:StoreInstance= null\r\n\r\n        protected setState(name:string, value:any){\r\n            this.storeInstance.$state[':'+name] = value;\r\n        }\r\n\r\n        protected getState<T=any>(name:string){\r\n            return this.storeInstance.$state[':'+name] as T;\r\n        }\r\n\r\n        protected whenPropertyNotExists(key){\r\n            throw new ReferenceError(`Store property the \"${key}\" is not exist.`)\r\n        }\r\n\r\n        patch(data:Record|(states:Record)=>void){\r\n            this.storeInstance.$patch(data);\r\n        }\r\n\r\n        onAction(callback:(options:{\r\n            name?:string,\r\n            store?:{},\r\n            args?:any[],\r\n            after?:(callback:(...args)=>void)=>void,\r\n            onError?:(callback:(...args)=>void)=>void,\r\n        })=>void, always=false){\r\n           return this.storeInstance.$onAction(callback, always);\r\n        }\r\n\r\n        subscribe(callback:(mutation:Record, state:Record)=>void, options?:{detached: boolean}&Record){\r\n            this.storeInstance.$subscribe(callback);\r\n        }\r\n\r\n        watch(callback:vue.WatchCallback<Record>, options?:vue.WatchOptions):()=>void{\r\n            return _watch(this.storeInstance.$state, callback, options)\r\n        }\r\n\r\n        dispose(){\r\n            this.storeInstance.$dispose();\r\n        }\r\n\r\n        reset(){\r\n            this.storeInstance.$reset();\r\n        }\r\n    }\r\n\r\n    declare interface StoreInstance{\r\n        $state:Record\r\n        $onAction:(...args)=>(()=>void)\r\n        $reset:(...args)=>void\r\n        $patch:(...args)=>void\r\n        $subscribe:(...args)=>void\r\n        $dispose:()=>void\r\n        [key:string]:any\r\n    }\r\n\r\n    declare interface PiniaInstance{\r\n        install(app):void\r\n        use(plugin):this\r\n        _p:any[]\r\n        _a:any\r\n        _e:any\r\n        _s:Map<string,any>\r\n        state:{value:Record<Record<any>>}\r\n    }\r\n}\r\n\r\n\r\n"]}