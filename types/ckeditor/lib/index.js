var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
};

// node_modules/lodash-es/isBuffer.js
var require_isBuffer = __commonJS((exports, module) => {
  __markAsModule(exports);
  __export(exports, {
    default: () => isBuffer_default
  });
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root_default.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer5 = nativeIsBuffer || stubFalse_default;
  var isBuffer_default = isBuffer5;
});

// node_modules/lodash-es/_nodeUtil.js
var require_nodeUtil = __commonJS((exports, module) => {
  __markAsModule(exports);
  __export(exports, {
    default: () => nodeUtil_default
  });
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal_default.process;
  var nodeUtil4 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeUtil_default = nodeUtil4;
});

// node_modules/lodash-es/_cloneBuffer.js
var require_cloneBuffer = __commonJS((exports, module) => {
  __markAsModule(exports);
  __export(exports, {
    default: () => cloneBuffer_default
  });
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root_default.Buffer : void 0;
  var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer3(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  var cloneBuffer_default = cloneBuffer3;
});

// node_modules/color-name/index.js
var require_color_name = __commonJS((exports, module) => {
  "use strict";
  module.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/color-parse/index.js
var require_color_parse = __commonJS((exports, module) => {
  "use strict";
  var names = require_color_name();
  module.exports = parse2;
  var baseHues = {
    red: 0,
    orange: 60,
    yellow: 120,
    green: 180,
    blue: 240,
    purple: 300
  };
  function parse2(cstr) {
    var m, parts = [], alpha = 1, space;
    if (typeof cstr === "string") {
      if (names[cstr]) {
        parts = names[cstr].slice();
        space = "rgb";
      } else if (cstr === "transparent") {
        alpha = 0;
        space = "rgb";
        parts = [0, 0, 0];
      } else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
        var base = cstr.slice(1);
        var size = base.length;
        var isShort = size <= 4;
        alpha = 1;
        if (isShort) {
          parts = [
            parseInt(base[0] + base[0], 16),
            parseInt(base[1] + base[1], 16),
            parseInt(base[2] + base[2], 16)
          ];
          if (size === 4) {
            alpha = parseInt(base[3] + base[3], 16) / 255;
          }
        } else {
          parts = [
            parseInt(base[0] + base[1], 16),
            parseInt(base[2] + base[3], 16),
            parseInt(base[4] + base[5], 16)
          ];
          if (size === 8) {
            alpha = parseInt(base[6] + base[7], 16) / 255;
          }
        }
        if (!parts[0])
          parts[0] = 0;
        if (!parts[1])
          parts[1] = 0;
        if (!parts[2])
          parts[2] = 0;
        space = "rgb";
      } else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
        var name = m[1];
        var isRGB = name === "rgb";
        var base = name.replace(/a$/, "");
        space = base;
        var size = base === "cmyk" ? 4 : base === "gray" ? 1 : 3;
        parts = m[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(x, i) {
          if (/%$/.test(x)) {
            if (i === size)
              return parseFloat(x) / 100;
            if (base === "rgb")
              return parseFloat(x) * 255 / 100;
            return parseFloat(x);
          } else if (base[i] === "h") {
            if (/deg$/.test(x)) {
              return parseFloat(x);
            } else if (baseHues[x] !== void 0) {
              return baseHues[x];
            }
          }
          return parseFloat(x);
        });
        if (name === base)
          parts.push(1);
        alpha = isRGB ? 1 : parts[size] === void 0 ? 1 : parts[size];
        parts = parts.slice(0, size);
      } else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
        parts = cstr.match(/([0-9]+)/g).map(function(value) {
          return parseFloat(value);
        });
        space = cstr.match(/([a-z])/ig).join("").toLowerCase();
      }
    } else if (!isNaN(cstr)) {
      space = "rgb";
      parts = [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255];
    } else if (Array.isArray(cstr) || cstr.length) {
      parts = [cstr[0], cstr[1], cstr[2]];
      space = "rgb";
      alpha = cstr.length === 4 ? cstr[3] : 1;
    } else if (cstr instanceof Object) {
      if (cstr.r != null || cstr.red != null || cstr.R != null) {
        space = "rgb";
        parts = [
          cstr.r || cstr.red || cstr.R || 0,
          cstr.g || cstr.green || cstr.G || 0,
          cstr.b || cstr.blue || cstr.B || 0
        ];
      } else {
        space = "hsl";
        parts = [
          cstr.h || cstr.hue || cstr.H || 0,
          cstr.s || cstr.saturation || cstr.S || 0,
          cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
        ];
      }
      alpha = cstr.a || cstr.alpha || cstr.opacity || 1;
      if (cstr.opacity != null)
        alpha /= 100;
    }
    return {
      space,
      values: parts,
      alpha
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports, module) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (const key of Object.keys(cssKeywords)) {
    reverseKeywords[cssKeywords[key]] = key;
  }
  var convert2 = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  module.exports = convert2;
  for (const model of Object.keys(convert2)) {
    if (!("channels" in convert2[model])) {
      throw new Error("missing channels property: " + model);
    }
    if (!("labels" in convert2[model])) {
      throw new Error("missing channel labels property: " + model);
    }
    if (convert2[model].labels.length !== convert2[model].channels) {
      throw new Error("channel and label counts mismatch: " + model);
    }
    const {channels, labels} = convert2[model];
    delete convert2[model].channels;
    delete convert2[model].labels;
    Object.defineProperty(convert2[model], "channels", {value: channels});
    Object.defineProperty(convert2[model], "labels", {value: labels});
  }
  convert2.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    const l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert2.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff2 = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff2 + 1 / 2;
    };
    if (diff2 === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff2 / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert2.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = convert2.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert2.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  convert2.rgb.keyword = function(rgb) {
    const reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys(cssKeywords)) {
      const value = cssKeywords[keyword];
      const distance = comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  convert2.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert2.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert2.rgb.lab = function(rgb) {
    const xyz = convert2.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert2.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    const t1 = 2 * l - t2;
    const rgb = [0, 0, 0];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert2.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert2.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert2.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert2.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert2.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert2.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert2.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [l, a, b];
  };
  convert2.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert2.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    const c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert2.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert2.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert2.hsv.ansi16 = function(args) {
    return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
  };
  convert2.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert2.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50) {
        color += 3.5;
      }
      color = color / 10.5 * 255;
      return [color, color, color];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert2.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert2.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert2.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    let colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    }
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [r, g, b];
  };
  convert2.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1) {
      grayscale = min / (1 - chroma);
    } else {
      grayscale = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale * 100];
  };
  convert2.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert2.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert2.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    const pure = [0, 0, 0];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert2.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert2.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert2.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert2.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert2.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert2.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert2.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert2.gray.hsl = function(args) {
    return [0, 0, args[0]];
  };
  convert2.gray.hsv = convert2.gray.hsl;
  convert2.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert2.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert2.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert2.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert2.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports, module) => {
  var conversions = require_conversions();
  function buildGraph() {
    const graph = {};
    const models = Object.keys(conversions);
    for (let len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    const graph = buildGraph();
    const queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys(conversions[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    const path = [graph[toModel].parent, toModel];
    let fn = conversions[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function(fromModel) {
    const graph = deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports, module) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert2 = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null) {
        return arg0;
      }
      if (arg0.length > 1) {
        args = arg0;
      }
      const result = fn(args);
      if (typeof result === "object") {
        for (let len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach((fromModel) => {
    convert2[fromModel] = {};
    Object.defineProperty(convert2[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert2[fromModel], "labels", {value: conversions[fromModel].labels});
    const routes = route(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      convert2[fromModel][toModel] = wrapRounded(fn);
      convert2[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module.exports = convert2;
});

// node_modules/@ckeditor/ckeditor5-utils/src/env.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getUserAgent() {
  try {
    return navigator.userAgent.toLowerCase();
  } catch (e) {
    return "";
  }
}
var userAgent = getUserAgent();
var env = {
  isMac: isMac(userAgent),
  isWindows: isWindows(userAgent),
  isGecko: isGecko(userAgent),
  isSafari: isSafari(userAgent),
  isiOS: isiOS(userAgent),
  isAndroid: isAndroid(userAgent),
  isBlink: isBlink(userAgent),
  features: {
    isRegExpUnicodePropertySupported: isRegExpUnicodePropertySupported()
  }
};
var env_default = env;
function isMac(userAgent2) {
  return userAgent2.indexOf("macintosh") > -1;
}
function isWindows(userAgent2) {
  return userAgent2.indexOf("windows") > -1;
}
function isGecko(userAgent2) {
  return !!userAgent2.match(/gecko\/\d+/);
}
function isSafari(userAgent2) {
  return userAgent2.indexOf(" applewebkit/") > -1 && userAgent2.indexOf("chrome") === -1;
}
function isiOS(userAgent2) {
  return !!userAgent2.match(/iphone|ipad/i) || isMac(userAgent2) && navigator.maxTouchPoints > 0;
}
function isAndroid(userAgent2) {
  return userAgent2.indexOf("android") > -1;
}
function isBlink(userAgent2) {
  return userAgent2.indexOf("chrome/") > -1 && userAgent2.indexOf("edge/") < 0;
}
function isRegExpUnicodePropertySupported() {
  let isSupported = false;
  try {
    isSupported = "\u0107".search(new RegExp("[\\p{L}]", "u")) === 0;
  } catch (error) {
  }
  return isSupported;
}

// node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function fastDiff(a, b, cmp, atomicChanges) {
  cmp = cmp || function(a2, b2) {
    return a2 === b2;
  };
  const arrayA = Array.isArray(a) ? a : Array.prototype.slice.call(a);
  const arrayB = Array.isArray(b) ? b : Array.prototype.slice.call(b);
  const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);
  const result = atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);
  return result;
}
function findChangeBoundaryIndexes(arr1, arr2, cmp) {
  const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);
  if (firstIndex === -1) {
    return {firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1};
  }
  const oldArrayReversed = cutAndReverse(arr1, firstIndex);
  const newArrayReversed = cutAndReverse(arr2, firstIndex);
  const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);
  const lastIndexOld = arr1.length - lastIndex;
  const lastIndexNew = arr2.length - lastIndex;
  return {firstIndex, lastIndexOld, lastIndexNew};
}
function findFirstDifferenceIndex(arr1, arr2, cmp) {
  for (let i = 0; i < Math.max(arr1.length, arr2.length); i++) {
    if (arr1[i] === void 0 || arr2[i] === void 0 || !cmp(arr1[i], arr2[i])) {
      return i;
    }
  }
  return -1;
}
function cutAndReverse(arr, howMany) {
  return arr.slice(howMany).reverse();
}
function changeIndexesToChanges(newArray, changeIndexes) {
  const result = [];
  const {firstIndex, lastIndexOld, lastIndexNew} = changeIndexes;
  if (lastIndexNew - firstIndex > 0) {
    result.push({
      index: firstIndex,
      type: "insert",
      values: newArray.slice(firstIndex, lastIndexNew)
    });
  }
  if (lastIndexOld - firstIndex > 0) {
    result.push({
      index: firstIndex + (lastIndexNew - firstIndex),
      type: "delete",
      howMany: lastIndexOld - firstIndex
    });
  }
  return result;
}
function changeIndexesToAtomicChanges(changeIndexes, newLength) {
  const {firstIndex, lastIndexOld, lastIndexNew} = changeIndexes;
  if (firstIndex === -1) {
    return Array(newLength).fill("equal");
  }
  let result = [];
  if (firstIndex > 0) {
    result = result.concat(Array(firstIndex).fill("equal"));
  }
  if (lastIndexNew - firstIndex > 0) {
    result = result.concat(Array(lastIndexNew - firstIndex).fill("insert"));
  }
  if (lastIndexOld - firstIndex > 0) {
    result = result.concat(Array(lastIndexOld - firstIndex).fill("delete"));
  }
  if (lastIndexNew < newLength) {
    result = result.concat(Array(newLength - lastIndexNew).fill("equal"));
  }
  return result;
}

// node_modules/@ckeditor/ckeditor5-utils/src/diff.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function diff(a, b, cmp) {
  cmp = cmp || function(a2, b2) {
    return a2 === b2;
  };
  const aLength = a.length;
  const bLength = b.length;
  if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {
    return diff.fastDiff(a, b, cmp, true);
  }
  let _insert2, _delete;
  if (bLength < aLength) {
    const tmp = a;
    a = b;
    b = tmp;
    _insert2 = "delete";
    _delete = "insert";
  } else {
    _insert2 = "insert";
    _delete = "delete";
  }
  const m = a.length;
  const n = b.length;
  const delta = n - m;
  const es = {};
  const fp = {};
  function snake(k2) {
    const y1 = (fp[k2 - 1] !== void 0 ? fp[k2 - 1] : -1) + 1;
    const y2 = fp[k2 + 1] !== void 0 ? fp[k2 + 1] : -1;
    const dir = y1 > y2 ? -1 : 1;
    if (es[k2 + dir]) {
      es[k2] = es[k2 + dir].slice(0);
    }
    if (!es[k2]) {
      es[k2] = [];
    }
    es[k2].push(y1 > y2 ? _insert2 : _delete);
    let y = Math.max(y1, y2);
    let x = y - k2;
    while (x < m && y < n && cmp(a[x], b[y])) {
      x++;
      y++;
      es[k2].push("equal");
    }
    return y;
  }
  let p = 0;
  let k;
  do {
    for (k = -p; k < delta; k++) {
      fp[k] = snake(k);
    }
    for (k = delta + p; k > delta; k--) {
      fp[k] = snake(k);
    }
    fp[delta] = snake(delta);
    p++;
  } while (fp[delta] !== n);
  return es[delta].slice(1);
}
diff.fastDiff = fastDiff;

// node_modules/@ckeditor/ckeditor5-utils/src/difftochanges.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function diffToChanges(diff2, output) {
  const changes = [];
  let index = 0;
  let lastOperation = null;
  diff2.forEach((change) => {
    if (change == "equal") {
      pushLast();
      index++;
    } else if (change == "insert") {
      if (lastOperation && lastOperation.type == "insert") {
        lastOperation.values.push(output[index]);
      } else {
        pushLast();
        lastOperation = {
          type: "insert",
          index,
          values: [output[index]]
        };
      }
      index++;
    } else {
      if (lastOperation && lastOperation.type == "delete") {
        lastOperation.howMany++;
      } else {
        pushLast();
        lastOperation = {
          type: "delete",
          index,
          howMany: 1
        };
      }
    }
  });
  pushLast();
  return changes;
  function pushLast() {
    if (lastOperation) {
      changes.push(lastOperation);
      lastOperation = null;
    }
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/mix.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function mix(baseClass, ...mixins) {
  mixins.forEach((mixin) => {
    const propertyNames = Object.getOwnPropertyNames(mixin);
    const propertySymbols = Object.getOwnPropertySymbols(mixin);
    propertyNames.concat(propertySymbols).forEach((key) => {
      if (key in baseClass.prototype) {
        return;
      }
      if (typeof mixin == "function" && (key == "length" || key == "name" || key == "prototype")) {
        return;
      }
      const sourceDescriptor = Object.getOwnPropertyDescriptor(mixin, key);
      sourceDescriptor.enumerable = false;
      Object.defineProperty(baseClass.prototype, key, sourceDescriptor);
    });
  });
}

// node_modules/@ckeditor/ckeditor5-utils/src/spy.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function spy() {
  return function spy2() {
    spy2.called = true;
  };
}
var spy_default = spy;

// node_modules/@ckeditor/ckeditor5-utils/src/eventinfo.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EventInfo = class {
  constructor(source, name) {
    this.source = source;
    this.name = name;
    this.path = [];
    this.stop = spy_default();
    this.off = spy_default();
  }
};
var eventinfo_default = EventInfo;

// node_modules/@ckeditor/ckeditor5-utils/src/uid.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var HEX_NUMBERS = new Array(256).fill("").map((_, index) => ("0" + index.toString(16)).slice(-2));
function uid() {
  const r1 = Math.random() * 4294967296 >>> 0;
  const r2 = Math.random() * 4294967296 >>> 0;
  const r3 = Math.random() * 4294967296 >>> 0;
  const r4 = Math.random() * 4294967296 >>> 0;
  return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
}

// node_modules/@ckeditor/ckeditor5-utils/src/priorities.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var priorities = {
  get(priority = "normal") {
    if (typeof priority != "number") {
      return this[priority] || this.normal;
    } else {
      return priority;
    }
  },
  highest: 1e5,
  high: 1e3,
  normal: 0,
  low: -1e3,
  lowest: -1e5
};
var priorities_default = priorities;

// node_modules/@ckeditor/ckeditor5-utils/src/inserttopriorityarray.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function insertToPriorityArray(objects, objectToInsert) {
  const priority = priorities_default.get(objectToInsert.priority);
  for (let i = 0; i < objects.length; i++) {
    if (priorities_default.get(objects[i].priority) < priority) {
      objects.splice(i, 0, objectToInsert);
      return;
    }
  }
  objects.push(objectToInsert);
}

// node_modules/@ckeditor/ckeditor5-utils/src/ckeditorerror.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DOCUMENTATION_URL = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
var CKEditorError = class extends Error {
  constructor(errorName, context, data) {
    super(getErrorMessage(errorName, data));
    this.name = "CKEditorError";
    this.context = context;
    this.data = data;
  }
  is(type) {
    return type === "CKEditorError";
  }
  static rethrowUnexpectedError(err, context) {
    if (err.is && err.is("CKEditorError")) {
      throw err;
    }
    const error = new CKEditorError(err.message, context);
    error.stack = err.stack;
    throw error;
  }
};
var ckeditorerror_default = CKEditorError;
function logWarning(errorName, data) {
  console.warn(...formatConsoleArguments(errorName, data));
}
function logError(errorName, data) {
  console.error(...formatConsoleArguments(errorName, data));
}
function getLinkToDocumentationMessage(errorName) {
  return `
Read more: ${DOCUMENTATION_URL}#error-${errorName}`;
}
function getErrorMessage(errorName, data) {
  const processedObjects = new WeakSet();
  const circularReferencesReplacer = (key, value) => {
    if (typeof value === "object" && value !== null) {
      if (processedObjects.has(value)) {
        return `[object ${value.constructor.name}]`;
      }
      processedObjects.add(value);
    }
    return value;
  };
  const stringifiedData = data ? ` ${JSON.stringify(data, circularReferencesReplacer)}` : "";
  const documentationLink = getLinkToDocumentationMessage(errorName);
  return errorName + stringifiedData + documentationLink;
}
function formatConsoleArguments(errorName, data) {
  const documentationMessage = getLinkToDocumentationMessage(errorName);
  return data ? [errorName, data, documentationMessage] : [errorName, documentationMessage];
}

// node_modules/@ckeditor/ckeditor5-utils/src/version.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var version = "40.0.0";
var version_default = version;
var releaseDate = new Date(2023, 9, 4);
/* istanbul ignore next -- @preserve */
if (globalThis.CKEDITOR_VERSION) {
  throw new ckeditorerror_default("ckeditor-duplicated-modules", null);
} else {
  globalThis.CKEDITOR_VERSION = version;
}

// node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var _listeningTo = Symbol("listeningTo");
var _emitterId = Symbol("emitterId");
var _delegations = Symbol("delegations");
var defaultEmitterClass = EmitterMixin(Object);
function EmitterMixin(base) {
  if (!base) {
    return defaultEmitterClass;
  }
  class Mixin extends base {
    on(event, callback, options) {
      this.listenTo(this, event, callback, options);
    }
    once(event, callback, options) {
      let wasFired = false;
      const onceCallback = (event2, ...args) => {
        if (!wasFired) {
          wasFired = true;
          event2.off();
          callback.call(this, event2, ...args);
        }
      };
      this.listenTo(this, event, onceCallback, options);
    }
    off(event, callback) {
      this.stopListening(this, event, callback);
    }
    listenTo(emitter, event, callback, options = {}) {
      let emitterInfo, eventCallbacks;
      if (!this[_listeningTo]) {
        this[_listeningTo] = {};
      }
      const emitters = this[_listeningTo];
      if (!_getEmitterId(emitter)) {
        _setEmitterId(emitter);
      }
      const emitterId = _getEmitterId(emitter);
      if (!(emitterInfo = emitters[emitterId])) {
        emitterInfo = emitters[emitterId] = {
          emitter,
          callbacks: {}
        };
      }
      if (!(eventCallbacks = emitterInfo.callbacks[event])) {
        eventCallbacks = emitterInfo.callbacks[event] = [];
      }
      eventCallbacks.push(callback);
      addEventListener(this, emitter, event, callback, options);
    }
    stopListening(emitter, event, callback) {
      const emitters = this[_listeningTo];
      let emitterId = emitter && _getEmitterId(emitter);
      const emitterInfo = emitters && emitterId ? emitters[emitterId] : void 0;
      const eventCallbacks = emitterInfo && event ? emitterInfo.callbacks[event] : void 0;
      if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
        return;
      }
      if (callback) {
        removeEventListener(this, emitter, event, callback);
        const index = eventCallbacks.indexOf(callback);
        if (index !== -1) {
          if (eventCallbacks.length === 1) {
            delete emitterInfo.callbacks[event];
          } else {
            removeEventListener(this, emitter, event, callback);
          }
        }
      } else if (eventCallbacks) {
        while (callback = eventCallbacks.pop()) {
          removeEventListener(this, emitter, event, callback);
        }
        delete emitterInfo.callbacks[event];
      } else if (emitterInfo) {
        for (event in emitterInfo.callbacks) {
          this.stopListening(emitter, event);
        }
        delete emitters[emitterId];
      } else {
        for (emitterId in emitters) {
          this.stopListening(emitters[emitterId].emitter);
        }
        delete this[_listeningTo];
      }
    }
    fire(eventOrInfo, ...args) {
      try {
        const eventInfo = eventOrInfo instanceof eventinfo_default ? eventOrInfo : new eventinfo_default(this, eventOrInfo);
        const event = eventInfo.name;
        let callbacks = getCallbacksForEvent(this, event);
        eventInfo.path.push(this);
        if (callbacks) {
          const callbackArgs = [eventInfo, ...args];
          callbacks = Array.from(callbacks);
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i].callback.apply(this, callbackArgs);
            if (eventInfo.off.called) {
              delete eventInfo.off.called;
              this._removeEventListener(event, callbacks[i].callback);
            }
            if (eventInfo.stop.called) {
              break;
            }
          }
        }
        const delegations = this[_delegations];
        if (delegations) {
          const destinations = delegations.get(event);
          const passAllDestinations = delegations.get("*");
          if (destinations) {
            fireDelegatedEvents(destinations, eventInfo, args);
          }
          if (passAllDestinations) {
            fireDelegatedEvents(passAllDestinations, eventInfo, args);
          }
        }
        return eventInfo.return;
      } catch (err) {
        /* istanbul ignore next -- @preserve */
        ckeditorerror_default.rethrowUnexpectedError(err, this);
      }
    }
    delegate(...events) {
      return {
        to: (emitter, nameOrFunction) => {
          if (!this[_delegations]) {
            this[_delegations] = new Map();
          }
          events.forEach((eventName) => {
            const destinations = this[_delegations].get(eventName);
            if (!destinations) {
              this[_delegations].set(eventName, new Map([[emitter, nameOrFunction]]));
            } else {
              destinations.set(emitter, nameOrFunction);
            }
          });
        }
      };
    }
    stopDelegating(event, emitter) {
      if (!this[_delegations]) {
        return;
      }
      if (!event) {
        this[_delegations].clear();
      } else if (!emitter) {
        this[_delegations].delete(event);
      } else {
        const destinations = this[_delegations].get(event);
        if (destinations) {
          destinations.delete(emitter);
        }
      }
    }
    _addEventListener(event, callback, options) {
      createEventNamespace(this, event);
      const lists = getCallbacksListsForNamespace(this, event);
      const priority = priorities_default.get(options.priority);
      const callbackDefinition = {
        callback,
        priority
      };
      for (const callbacks of lists) {
        insertToPriorityArray(callbacks, callbackDefinition);
      }
    }
    _removeEventListener(event, callback) {
      const lists = getCallbacksListsForNamespace(this, event);
      for (const callbacks of lists) {
        for (let i = 0; i < callbacks.length; i++) {
          if (callbacks[i].callback == callback) {
            callbacks.splice(i, 1);
            i--;
          }
        }
      }
    }
  }
  return Mixin;
}
[
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  EmitterMixin[key] = defaultEmitterClass.prototype[key];
});
function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {
  const listeningTo = listeningEmitter[_listeningTo];
  if (listeningTo && listeningTo[listenedToEmitterId]) {
    return listeningTo[listenedToEmitterId].emitter;
  }
  return null;
}
function _setEmitterId(emitter, id) {
  if (!emitter[_emitterId]) {
    emitter[_emitterId] = id || uid();
  }
}
function _getEmitterId(emitter) {
  return emitter[_emitterId];
}
function getEvents(source) {
  if (!source._events) {
    Object.defineProperty(source, "_events", {
      value: {}
    });
  }
  return source._events;
}
function makeEventNode() {
  return {
    callbacks: [],
    childEvents: []
  };
}
function createEventNamespace(source, eventName) {
  const events = getEvents(source);
  if (events[eventName]) {
    return;
  }
  let name = eventName;
  let childEventName = null;
  const newEventNodes = [];
  while (name !== "") {
    if (events[name]) {
      break;
    }
    events[name] = makeEventNode();
    newEventNodes.push(events[name]);
    if (childEventName) {
      events[name].childEvents.push(childEventName);
    }
    childEventName = name;
    name = name.substr(0, name.lastIndexOf(":"));
  }
  if (name !== "") {
    for (const node of newEventNodes) {
      node.callbacks = events[name].callbacks.slice();
    }
    events[name].childEvents.push(childEventName);
  }
}
function getCallbacksListsForNamespace(source, eventName) {
  const eventNode = getEvents(source)[eventName];
  if (!eventNode) {
    return [];
  }
  let callbacksLists = [eventNode.callbacks];
  for (let i = 0; i < eventNode.childEvents.length; i++) {
    const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);
    callbacksLists = callbacksLists.concat(childCallbacksLists);
  }
  return callbacksLists;
}
function getCallbacksForEvent(source, eventName) {
  let event;
  if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
    if (eventName.indexOf(":") > -1) {
      return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(":")));
    } else {
      return null;
    }
  }
  return event.callbacks;
}
function fireDelegatedEvents(destinations, eventInfo, fireArgs) {
  for (let [emitter, name] of destinations) {
    if (!name) {
      name = eventInfo.name;
    } else if (typeof name == "function") {
      name = name(eventInfo.name);
    }
    const delegatedInfo = new eventinfo_default(eventInfo.source, name);
    delegatedInfo.path = [...eventInfo.path];
    emitter.fire(delegatedInfo, ...fireArgs);
  }
}
function addEventListener(listener, emitter, event, callback, options) {
  if (emitter._addEventListener) {
    emitter._addEventListener(event, callback, options);
  } else {
    listener._addEventListener.call(emitter, event, callback, options);
  }
}
function removeEventListener(listener, emitter, event, callback) {
  if (emitter._removeEventListener) {
    emitter._removeEventListener(event, callback);
  } else {
    listener._removeEventListener.call(emitter, event, callback);
  }
}

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    configurable: true,
    enumerable: false,
    value: constant_default(string),
    writable: true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      configurable: true,
      enumerable: true,
      value,
      writable: true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start, transform4) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform4(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/_arrayLikeKeys.js
var import_isBuffer = __toModule(require_isBuffer());

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/isTypedArray.js
var import_nodeUtil = __toModule(require_nodeUtil());
var nodeIsTypedArray = import_nodeUtil.default && import_nodeUtil.default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && (0, import_isBuffer.default)(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform4) {
  return function(arg) {
    return func(transform4(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    hash: new Hash_default(),
    map: new (Map_default || ListCache_default)(),
    string: new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_baseClone.js
var import_cloneBuffer = __toModule(require_cloneBuffer());

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result = [];
  while (object) {
    arrayPush_default(result, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty11.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseClone.js
var import_isBuffer2 = __toModule(require_isBuffer());

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var import_nodeUtil2 = __toModule(require_nodeUtil());
var nodeIsMap = import_nodeUtil2.default && import_nodeUtil2.default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var import_nodeUtil3 = __toModule(require_nodeUtil());
var nodeIsSet = import_nodeUtil3.default && import_nodeUtil3.default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if ((0, import_isBuffer2.default)(value)) {
      return (0, import_cloneBuffer.default)(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set2) {
  var index = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag3 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag3:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert2 = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert2 || (convert2 = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto15 = Object.prototype;
var hasOwnProperty12 = objectProto15.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty12.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var import_isBuffer3 = __toModule(require_isBuffer());
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto16 = Object.prototype;
var hasOwnProperty13 = objectProto16.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && (0, import_isBuffer3.default)(object)) {
    if (!(0, import_isBuffer3.default)(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty13.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty13.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax2 = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax2(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/_baseMergeDeep.js
var import_cloneBuffer2 = __toModule(require_cloneBuffer());

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_baseMergeDeep.js
var import_isBuffer4 = __toModule(require_isBuffer());

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && (0, import_isBuffer4.default)(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = (0, import_cloneBuffer2.default)(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/last.js
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default = last;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/isElement.js
function isElement(value) {
  return isObjectLike_default(value) && value.nodeType === 1 && !isPlainObject_default(value);
}
var isElement_default = isElement;

// node_modules/lodash-es/isEqual.js
function isEqual(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result = customizer ? customizer(value, other) : void 0;
  return result === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  return object == null || delete object[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/set.js
function set(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    leading,
    maxWait: wait,
    trailing
  });
}
var throttle_default = throttle;

// node_modules/lodash-es/unset.js
function unset(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset;

// node_modules/@ckeditor/ckeditor5-utils/src/observablemixin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var observablePropertiesSymbol = Symbol("observableProperties");
var boundObservablesSymbol = Symbol("boundObservables");
var boundPropertiesSymbol = Symbol("boundProperties");
var decoratedMethods = Symbol("decoratedMethods");
var decoratedOriginal = Symbol("decoratedOriginal");
var defaultObservableClass = ObservableMixin(EmitterMixin());
function ObservableMixin(base) {
  if (!base) {
    return defaultObservableClass;
  }
  class Mixin extends base {
    set(name, value) {
      if (isObject_default(name)) {
        Object.keys(name).forEach((property) => {
          this.set(property, name[property]);
        }, this);
        return;
      }
      initObservable(this);
      const properties = this[observablePropertiesSymbol];
      if (name in this && !properties.has(name)) {
        throw new ckeditorerror_default("observable-set-cannot-override", this);
      }
      Object.defineProperty(this, name, {
        enumerable: true,
        configurable: true,
        get() {
          return properties.get(name);
        },
        set(value2) {
          const oldValue = properties.get(name);
          let newValue = this.fire(`set:${name}`, name, value2, oldValue);
          if (newValue === void 0) {
            newValue = value2;
          }
          if (oldValue !== newValue || !properties.has(name)) {
            properties.set(name, newValue);
            this.fire(`change:${name}`, name, newValue, oldValue);
          }
        }
      });
      this[name] = value;
    }
    bind(...bindProperties) {
      if (!bindProperties.length || !isStringArray(bindProperties)) {
        throw new ckeditorerror_default("observable-bind-wrong-properties", this);
      }
      if (new Set(bindProperties).size !== bindProperties.length) {
        throw new ckeditorerror_default("observable-bind-duplicate-properties", this);
      }
      initObservable(this);
      const boundProperties = this[boundPropertiesSymbol];
      bindProperties.forEach((propertyName) => {
        if (boundProperties.has(propertyName)) {
          throw new ckeditorerror_default("observable-bind-rebind", this);
        }
      });
      const bindings = new Map();
      bindProperties.forEach((a) => {
        const binding = {property: a, to: []};
        boundProperties.set(a, binding);
        bindings.set(a, binding);
      });
      return {
        to: bindTo,
        toMany: bindToMany,
        _observable: this,
        _bindProperties: bindProperties,
        _to: [],
        _bindings: bindings
      };
    }
    unbind(...unbindProperties) {
      if (!this[observablePropertiesSymbol]) {
        return;
      }
      const boundProperties = this[boundPropertiesSymbol];
      const boundObservables = this[boundObservablesSymbol];
      if (unbindProperties.length) {
        if (!isStringArray(unbindProperties)) {
          throw new ckeditorerror_default("observable-unbind-wrong-properties", this);
        }
        unbindProperties.forEach((propertyName) => {
          const binding = boundProperties.get(propertyName);
          if (!binding) {
            return;
          }
          binding.to.forEach(([toObservable, toProperty]) => {
            const toProperties = boundObservables.get(toObservable);
            const toPropertyBindings = toProperties[toProperty];
            toPropertyBindings.delete(binding);
            if (!toPropertyBindings.size) {
              delete toProperties[toProperty];
            }
            if (!Object.keys(toProperties).length) {
              boundObservables.delete(toObservable);
              this.stopListening(toObservable, "change");
            }
          });
          boundProperties.delete(propertyName);
        });
      } else {
        boundObservables.forEach((bindings, boundObservable) => {
          this.stopListening(boundObservable, "change");
        });
        boundObservables.clear();
        boundProperties.clear();
      }
    }
    decorate(methodName) {
      initObservable(this);
      const originalMethod = this[methodName];
      if (!originalMethod) {
        throw new ckeditorerror_default("observablemixin-cannot-decorate-undefined", this, {object: this, methodName});
      }
      this.on(methodName, (evt, args) => {
        evt.return = originalMethod.apply(this, args);
      });
      this[methodName] = function(...args) {
        return this.fire(methodName, args);
      };
      this[methodName][decoratedOriginal] = originalMethod;
      if (!this[decoratedMethods]) {
        this[decoratedMethods] = [];
      }
      this[decoratedMethods].push(methodName);
    }
    stopListening(emitter, event, callback) {
      if (!emitter && this[decoratedMethods]) {
        for (const methodName of this[decoratedMethods]) {
          this[methodName] = this[methodName][decoratedOriginal];
        }
        delete this[decoratedMethods];
      }
      super.stopListening(emitter, event, callback);
    }
  }
  return Mixin;
}
[
  "set",
  "bind",
  "unbind",
  "decorate",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  ObservableMixin[key] = defaultObservableClass.prototype[key];
});
function initObservable(observable) {
  if (observable[observablePropertiesSymbol]) {
    return;
  }
  Object.defineProperty(observable, observablePropertiesSymbol, {
    value: new Map()
  });
  Object.defineProperty(observable, boundObservablesSymbol, {
    value: new Map()
  });
  Object.defineProperty(observable, boundPropertiesSymbol, {
    value: new Map()
  });
}
function bindTo(...args) {
  const parsedArgs = parseBindToArgs(...args);
  const bindingsKeys = Array.from(this._bindings.keys());
  const numberOfBindings = bindingsKeys.length;
  if (!parsedArgs.callback && parsedArgs.to.length > 1) {
    throw new ckeditorerror_default("observable-bind-to-no-callback", this);
  }
  if (numberOfBindings > 1 && parsedArgs.callback) {
    throw new ckeditorerror_default("observable-bind-to-extra-callback", this);
  }
  parsedArgs.to.forEach((to) => {
    if (to.properties.length && to.properties.length !== numberOfBindings) {
      throw new ckeditorerror_default("observable-bind-to-properties-length", this);
    }
    if (!to.properties.length) {
      to.properties = this._bindProperties;
    }
  });
  this._to = parsedArgs.to;
  if (parsedArgs.callback) {
    this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
  }
  attachBindToListeners(this._observable, this._to);
  updateBindToBound(this);
  this._bindProperties.forEach((propertyName) => {
    updateBoundObservableProperty(this._observable, propertyName);
  });
}
function bindToMany(observables, attribute, callback) {
  if (this._bindings.size > 1) {
    throw new ckeditorerror_default("observable-bind-to-many-not-one-binding", this);
  }
  this.to(...getBindingTargets(observables, attribute), callback);
}
function getBindingTargets(observables, attribute) {
  const observableAndAttributePairs = observables.map((observable) => [observable, attribute]);
  return Array.prototype.concat.apply([], observableAndAttributePairs);
}
function isStringArray(arr) {
  return arr.every((a) => typeof a == "string");
}
function parseBindToArgs(...args) {
  if (!args.length) {
    throw new ckeditorerror_default("observable-bind-to-parse-error", null);
  }
  const parsed = {to: []};
  let lastObservable;
  if (typeof args[args.length - 1] == "function") {
    parsed.callback = args.pop();
  }
  args.forEach((a) => {
    if (typeof a == "string") {
      lastObservable.properties.push(a);
    } else if (typeof a == "object") {
      lastObservable = {observable: a, properties: []};
      parsed.to.push(lastObservable);
    } else {
      throw new ckeditorerror_default("observable-bind-to-parse-error", null);
    }
  });
  return parsed;
}
function updateBoundObservables(observable, binding, toObservable, toPropertyName) {
  const boundObservables = observable[boundObservablesSymbol];
  const bindingsToObservable = boundObservables.get(toObservable);
  const bindings = bindingsToObservable || {};
  if (!bindings[toPropertyName]) {
    bindings[toPropertyName] = new Set();
  }
  bindings[toPropertyName].add(binding);
  if (!bindingsToObservable) {
    boundObservables.set(toObservable, bindings);
  }
}
function updateBindToBound(chain) {
  let toProperty;
  chain._bindings.forEach((binding, propertyName) => {
    chain._to.forEach((to) => {
      toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];
      binding.to.push([to.observable, toProperty]);
      updateBoundObservables(chain._observable, binding, to.observable, toProperty);
    });
  });
}
function updateBoundObservableProperty(observable, propertyName) {
  const boundProperties = observable[boundPropertiesSymbol];
  const binding = boundProperties.get(propertyName);
  let propertyValue;
  if (binding.callback) {
    propertyValue = binding.callback.apply(observable, binding.to.map((to) => to[0][to[1]]));
  } else {
    propertyValue = binding.to[0];
    propertyValue = propertyValue[0][propertyValue[1]];
  }
  if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {
    observable[propertyName] = propertyValue;
  } else {
    observable.set(propertyName, propertyValue);
  }
}
function attachBindToListeners(observable, toBindings) {
  toBindings.forEach((to) => {
    const boundObservables = observable[boundObservablesSymbol];
    let bindings;
    if (!boundObservables.get(to.observable)) {
      observable.listenTo(to.observable, "change", (evt, propertyName) => {
        bindings = boundObservables.get(to.observable)[propertyName];
        if (bindings) {
          bindings.forEach((binding) => {
            updateBoundObservableProperty(observable, binding.property);
          });
        }
      });
    }
  });
}

// node_modules/@ckeditor/ckeditor5-utils/src/elementreplacer.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ElementReplacer = class {
  constructor() {
    this._replacedElements = [];
  }
  replace(element, newElement) {
    this._replacedElements.push({element, newElement});
    element.style.display = "none";
    if (newElement) {
      element.parentNode.insertBefore(newElement, element.nextSibling);
    }
  }
  restore() {
    this._replacedElements.forEach(({element, newElement}) => {
      element.style.display = "";
      if (newElement) {
        newElement.remove();
      }
    });
    this._replacedElements = [];
  }
};
var elementreplacer_default = ElementReplacer;

// node_modules/@ckeditor/ckeditor5-utils/src/count.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function count(iterable) {
  let count2 = 0;
  for (const _ of iterable) {
    count2++;
  }
  return count2;
}

// node_modules/@ckeditor/ckeditor5-utils/src/comparearrays.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function compareArrays(a, b) {
  const minLen = Math.min(a.length, b.length);
  for (let i = 0; i < minLen; i++) {
    if (a[i] != b[i]) {
      return i;
    }
  }
  if (a.length == b.length) {
    return "same";
  } else if (a.length < b.length) {
    return "prefix";
  } else {
    return "extension";
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/isiterable.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isIterable(value) {
  return !!(value && value[Symbol.iterator]);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/createelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function createElement(doc, name, attributes = {}, children = []) {
  const namespace = attributes && attributes.xmlns;
  const element = namespace ? doc.createElementNS(namespace, name) : doc.createElement(name);
  for (const key in attributes) {
    element.setAttribute(key, attributes[key]);
  }
  if (isString_default(children) || !isIterable(children)) {
    children = [children];
  }
  for (let child of children) {
    if (isString_default(child)) {
      child = doc.createTextNode(child);
    }
    element.appendChild(child);
  }
  return element;
}

// node_modules/@ckeditor/ckeditor5-utils/src/config.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Config = class {
  constructor(configurations, defaultConfigurations) {
    this._config = {};
    if (defaultConfigurations) {
      this.define(cloneConfig(defaultConfigurations));
    }
    if (configurations) {
      this._setObjectToTarget(this._config, configurations);
    }
  }
  set(name, value) {
    this._setToTarget(this._config, name, value);
  }
  define(name, value) {
    const isDefine = true;
    this._setToTarget(this._config, name, value, isDefine);
  }
  get(name) {
    return this._getFromSource(this._config, name);
  }
  *names() {
    for (const name of Object.keys(this._config)) {
      yield name;
    }
  }
  _setToTarget(target, name, value, isDefine = false) {
    if (isPlainObject_default(name)) {
      this._setObjectToTarget(target, name, isDefine);
      return;
    }
    const parts = name.split(".");
    name = parts.pop();
    for (const part of parts) {
      if (!isPlainObject_default(target[part])) {
        target[part] = {};
      }
      target = target[part];
    }
    if (isPlainObject_default(value)) {
      if (!isPlainObject_default(target[name])) {
        target[name] = {};
      }
      target = target[name];
      this._setObjectToTarget(target, value, isDefine);
      return;
    }
    if (isDefine && typeof target[name] != "undefined") {
      return;
    }
    target[name] = value;
  }
  _getFromSource(source, name) {
    const parts = name.split(".");
    name = parts.pop();
    for (const part of parts) {
      if (!isPlainObject_default(source[part])) {
        source = null;
        break;
      }
      source = source[part];
    }
    return source ? cloneConfig(source[name]) : void 0;
  }
  _setObjectToTarget(target, configuration, isDefine) {
    Object.keys(configuration).forEach((key) => {
      this._setToTarget(target, key, configuration[key], isDefine);
    });
  }
};
var config_default = Config;
function cloneConfig(source) {
  return cloneDeepWith_default(source, leaveDOMReferences);
}
function leaveDOMReferences(value) {
  return isElement_default(value) ? value : void 0;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isnode.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isNode(obj) {
  if (obj) {
    if (obj.defaultView) {
      return obj instanceof obj.defaultView.Document;
    } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {
      return obj instanceof obj.ownerDocument.defaultView.Node;
    }
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/iswindow.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isWindow(obj) {
  const stringifiedObject = Object.prototype.toString.apply(obj);
  if (stringifiedObject == "[object Window]") {
    return true;
  }
  if (stringifiedObject == "[object global]") {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/emittermixin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var defaultEmitterClass2 = DomEmitterMixin(EmitterMixin());
function DomEmitterMixin(base) {
  if (!base) {
    return defaultEmitterClass2;
  }
  class Mixin extends base {
    listenTo(emitter, event, callback, options = {}) {
      if (isNode(emitter) || isWindow(emitter)) {
        const proxyOptions = {
          capture: !!options.useCapture,
          passive: !!options.usePassive
        };
        const proxyEmitter = this._getProxyEmitter(emitter, proxyOptions) || new ProxyEmitter(emitter, proxyOptions);
        this.listenTo(proxyEmitter, event, callback, options);
      } else {
        super.listenTo(emitter, event, callback, options);
      }
    }
    stopListening(emitter, event, callback) {
      if (isNode(emitter) || isWindow(emitter)) {
        const proxyEmitters = this._getAllProxyEmitters(emitter);
        for (const proxy of proxyEmitters) {
          this.stopListening(proxy, event, callback);
        }
      } else {
        super.stopListening(emitter, event, callback);
      }
    }
    _getProxyEmitter(node, options) {
      return _getEmitterListenedTo(this, getProxyEmitterId(node, options));
    }
    _getAllProxyEmitters(node) {
      return [
        {capture: false, passive: false},
        {capture: false, passive: true},
        {capture: true, passive: false},
        {capture: true, passive: true}
      ].map((options) => this._getProxyEmitter(node, options)).filter((proxy) => !!proxy);
    }
  }
  return Mixin;
}
[
  "_getProxyEmitter",
  "_getAllProxyEmitters",
  "on",
  "once",
  "off",
  "listenTo",
  "stopListening",
  "fire",
  "delegate",
  "stopDelegating",
  "_addEventListener",
  "_removeEventListener"
].forEach((key) => {
  DomEmitterMixin[key] = defaultEmitterClass2.prototype[key];
});
var ProxyEmitter = class extends EmitterMixin() {
  constructor(node, options) {
    super();
    _setEmitterId(this, getProxyEmitterId(node, options));
    this._domNode = node;
    this._options = options;
  }
  attach(event) {
    if (this._domListeners && this._domListeners[event]) {
      return;
    }
    const domListener = this._createDomListener(event);
    this._domNode.addEventListener(event, domListener, this._options);
    if (!this._domListeners) {
      this._domListeners = {};
    }
    this._domListeners[event] = domListener;
  }
  detach(event) {
    let events;
    if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
      this._domListeners[event].removeListener();
    }
  }
  _addEventListener(event, callback, options) {
    this.attach(event);
    EmitterMixin().prototype._addEventListener.call(this, event, callback, options);
  }
  _removeEventListener(event, callback) {
    EmitterMixin().prototype._removeEventListener.call(this, event, callback);
    this.detach(event);
  }
  _createDomListener(event) {
    const domListener = (domEvt) => {
      this.fire(event, domEvt);
    };
    domListener.removeListener = () => {
      this._domNode.removeEventListener(event, domListener, this._options);
      delete this._domListeners[event];
    };
    return domListener;
  }
};
function getNodeUID(node) {
  return node["data-ck-expando"] || (node["data-ck-expando"] = uid());
}
function getProxyEmitterId(node, options) {
  let id = getNodeUID(node);
  for (const option of Object.keys(options).sort()) {
    if (options[option]) {
      id += "-" + option;
    }
  }
  return id;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/global.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var globalVar;
try {
  globalVar = {window, document};
} catch (e) {
  /* istanbul ignore next -- @preserve */
  globalVar = {window: {}, document: {}};
}
var global_default = globalVar;

// node_modules/@ckeditor/ckeditor5-utils/src/dom/findclosestscrollableancestor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function findClosestScrollableAncestor(domElement) {
  let element = domElement.parentElement;
  if (!element) {
    return null;
  }
  while (element.tagName != "BODY") {
    const overflow = element.style.overflowY || global_default.window.getComputedStyle(element).overflowY;
    if (overflow === "auto" || overflow === "scroll") {
      break;
    }
    element = element.parentElement;
    if (!element) {
      return null;
    }
  }
  return element;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getancestors.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getAncestors(node) {
  const nodes = [];
  let currentNode = node;
  while (currentNode && currentNode.nodeType != Node.DOCUMENT_NODE) {
    nodes.unshift(currentNode);
    currentNode = currentNode.parentNode;
  }
  return nodes;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getdatafromelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getDataFromElement(el) {
  if (el instanceof HTMLTextAreaElement) {
    return el.value;
  }
  return el.innerHTML;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getborderwidths.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getBorderWidths(element) {
  const style = element.ownerDocument.defaultView.getComputedStyle(element);
  return {
    top: parseInt(style.borderTopWidth, 10),
    right: parseInt(style.borderRightWidth, 10),
    bottom: parseInt(style.borderBottomWidth, 10),
    left: parseInt(style.borderLeftWidth, 10)
  };
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/istext.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isText(obj) {
  return Object.prototype.toString.call(obj) == "[object Text]";
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isrange.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isRange(obj) {
  return Object.prototype.toString.apply(obj) == "[object Range]";
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/getpositionedancestor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getPositionedAncestor(element) {
  if (!element || !element.parentNode) {
    return null;
  }
  if (element.offsetParent === global_default.document.body) {
    return null;
  }
  return element.offsetParent;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/rect.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var rectProperties = ["top", "right", "bottom", "left", "width", "height"];
var Rect = class {
  constructor(source) {
    const isSourceRange = isRange(source);
    Object.defineProperty(this, "_source", {
      value: source._source || source,
      writable: true,
      enumerable: false
    });
    if (isDomElement(source) || isSourceRange) {
      if (isSourceRange) {
        const rangeRects = Rect.getDomRangeRects(source);
        copyRectProperties(this, Rect.getBoundingRect(rangeRects));
      } else {
        copyRectProperties(this, source.getBoundingClientRect());
      }
    } else if (isWindow(source)) {
      const {innerWidth, innerHeight} = source;
      copyRectProperties(this, {
        top: 0,
        right: innerWidth,
        bottom: innerHeight,
        left: 0,
        width: innerWidth,
        height: innerHeight
      });
    } else {
      copyRectProperties(this, source);
    }
  }
  clone() {
    return new Rect(this);
  }
  moveTo(x, y) {
    this.top = y;
    this.right = x + this.width;
    this.bottom = y + this.height;
    this.left = x;
    return this;
  }
  moveBy(x, y) {
    this.top += y;
    this.right += x;
    this.left += x;
    this.bottom += y;
    return this;
  }
  getIntersection(anotherRect) {
    const rect = {
      top: Math.max(this.top, anotherRect.top),
      right: Math.min(this.right, anotherRect.right),
      bottom: Math.min(this.bottom, anotherRect.bottom),
      left: Math.max(this.left, anotherRect.left),
      width: 0,
      height: 0
    };
    rect.width = rect.right - rect.left;
    rect.height = rect.bottom - rect.top;
    if (rect.width < 0 || rect.height < 0) {
      return null;
    } else {
      const newRect = new Rect(rect);
      newRect._source = this._source;
      return newRect;
    }
  }
  getIntersectionArea(anotherRect) {
    const rect = this.getIntersection(anotherRect);
    if (rect) {
      return rect.getArea();
    } else {
      return 0;
    }
  }
  getArea() {
    return this.width * this.height;
  }
  getVisible() {
    const source = this._source;
    let visibleRect = this.clone();
    if (isBody(source)) {
      return visibleRect;
    }
    let child = source;
    let parent2 = source.parentNode || source.commonAncestorContainer;
    let absolutelyPositionedChildElement;
    while (parent2 && !isBody(parent2)) {
      const isParentOverflowVisible = getElementOverflow(parent2) === "visible";
      if (child instanceof HTMLElement && getElementPosition(child) === "absolute") {
        absolutelyPositionedChildElement = child;
      }
      const parentElementPosition = getElementPosition(parent2);
      if (isParentOverflowVisible || absolutelyPositionedChildElement && (parentElementPosition === "relative" && isParentOverflowVisible || parentElementPosition !== "relative")) {
        child = parent2;
        parent2 = parent2.parentNode;
        continue;
      }
      const parentRect = new Rect(parent2);
      const intersectionRect = visibleRect.getIntersection(parentRect);
      if (intersectionRect) {
        if (intersectionRect.getArea() < visibleRect.getArea()) {
          visibleRect = intersectionRect;
        }
      } else {
        return null;
      }
      child = parent2;
      parent2 = parent2.parentNode;
    }
    return visibleRect;
  }
  isEqual(anotherRect) {
    for (const prop of rectProperties) {
      if (this[prop] !== anotherRect[prop]) {
        return false;
      }
    }
    return true;
  }
  contains(anotherRect) {
    const intersectRect = this.getIntersection(anotherRect);
    return !!(intersectRect && intersectRect.isEqual(anotherRect));
  }
  toAbsoluteRect() {
    const {scrollX, scrollY} = global_default.window;
    const absoluteRect = this.clone().moveBy(scrollX, scrollY);
    if (isDomElement(absoluteRect._source)) {
      const positionedAncestor = getPositionedAncestor(absoluteRect._source);
      if (positionedAncestor) {
        shiftRectToCompensatePositionedAncestor(absoluteRect, positionedAncestor);
      }
    }
    return absoluteRect;
  }
  excludeScrollbarsAndBorders() {
    const source = this._source;
    let scrollBarWidth, scrollBarHeight, direction;
    if (isWindow(source)) {
      scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;
      scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;
      direction = source.getComputedStyle(source.document.documentElement).direction;
    } else {
      const borderWidths = getBorderWidths(source);
      scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;
      scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;
      direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;
      this.left += borderWidths.left;
      this.top += borderWidths.top;
      this.right -= borderWidths.right;
      this.bottom -= borderWidths.bottom;
      this.width = this.right - this.left;
      this.height = this.bottom - this.top;
    }
    this.width -= scrollBarWidth;
    if (direction === "ltr") {
      this.right -= scrollBarWidth;
    } else {
      this.left += scrollBarWidth;
    }
    this.height -= scrollBarHeight;
    this.bottom -= scrollBarHeight;
    return this;
  }
  static getDomRangeRects(range) {
    const rects = [];
    const clientRects = Array.from(range.getClientRects());
    if (clientRects.length) {
      for (const rect of clientRects) {
        rects.push(new Rect(rect));
      }
    } else {
      let startContainer = range.startContainer;
      if (isText(startContainer)) {
        startContainer = startContainer.parentNode;
      }
      const rect = new Rect(startContainer.getBoundingClientRect());
      rect.right = rect.left;
      rect.width = 0;
      rects.push(rect);
    }
    return rects;
  }
  static getBoundingRect(rects) {
    const boundingRectData = {
      left: Number.POSITIVE_INFINITY,
      top: Number.POSITIVE_INFINITY,
      right: Number.NEGATIVE_INFINITY,
      bottom: Number.NEGATIVE_INFINITY,
      width: 0,
      height: 0
    };
    let rectangleCount = 0;
    for (const rect of rects) {
      rectangleCount++;
      boundingRectData.left = Math.min(boundingRectData.left, rect.left);
      boundingRectData.top = Math.min(boundingRectData.top, rect.top);
      boundingRectData.right = Math.max(boundingRectData.right, rect.right);
      boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);
    }
    if (rectangleCount == 0) {
      return null;
    }
    boundingRectData.width = boundingRectData.right - boundingRectData.left;
    boundingRectData.height = boundingRectData.bottom - boundingRectData.top;
    return new Rect(boundingRectData);
  }
};
var rect_default = Rect;
function copyRectProperties(rect, source) {
  for (const p of rectProperties) {
    rect[p] = source[p];
  }
}
function isBody(value) {
  if (!isDomElement(value)) {
    return false;
  }
  return value === value.ownerDocument.body;
}
function isDomElement(value) {
  return value !== null && typeof value === "object" && value.nodeType === 1 && typeof value.getBoundingClientRect === "function";
}
function getElementPosition(element) {
  return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).position : "static";
}
function getElementOverflow(element) {
  return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).overflow : "visible";
}
function shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {
  const ancestorPosition = new Rect(positionedElementAncestor);
  const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);
  let moveX = 0;
  let moveY = 0;
  moveX -= ancestorPosition.left;
  moveY -= ancestorPosition.top;
  moveX += positionedElementAncestor.scrollLeft;
  moveY += positionedElementAncestor.scrollTop;
  moveX -= ancestorBorderWidths.left;
  moveY -= ancestorBorderWidths.top;
  rect.moveBy(moveX, moveY);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/resizeobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ResizeObserver = class {
  constructor(element, callback) {
    if (!ResizeObserver._observerInstance) {
      ResizeObserver._createObserver();
    }
    this._element = element;
    this._callback = callback;
    ResizeObserver._addElementCallback(element, callback);
    ResizeObserver._observerInstance.observe(element);
  }
  get element() {
    return this._element;
  }
  destroy() {
    ResizeObserver._deleteElementCallback(this._element, this._callback);
  }
  static _addElementCallback(element, callback) {
    if (!ResizeObserver._elementCallbacks) {
      ResizeObserver._elementCallbacks = new Map();
    }
    let callbacks = ResizeObserver._elementCallbacks.get(element);
    if (!callbacks) {
      callbacks = new Set();
      ResizeObserver._elementCallbacks.set(element, callbacks);
    }
    callbacks.add(callback);
  }
  static _deleteElementCallback(element, callback) {
    const callbacks = ResizeObserver._getElementCallbacks(element);
    if (callbacks) {
      callbacks.delete(callback);
      if (!callbacks.size) {
        ResizeObserver._elementCallbacks.delete(element);
        ResizeObserver._observerInstance.unobserve(element);
      }
    }
    if (ResizeObserver._elementCallbacks && !ResizeObserver._elementCallbacks.size) {
      ResizeObserver._observerInstance = null;
      ResizeObserver._elementCallbacks = null;
    }
  }
  static _getElementCallbacks(element) {
    if (!ResizeObserver._elementCallbacks) {
      return null;
    }
    return ResizeObserver._elementCallbacks.get(element);
  }
  static _createObserver() {
    ResizeObserver._observerInstance = new global_default.window.ResizeObserver((entries) => {
      for (const entry of entries) {
        const callbacks = ResizeObserver._getElementCallbacks(entry.target);
        if (callbacks) {
          for (const callback of callbacks) {
            callback(entry);
          }
        }
      }
    });
  }
};
var resizeobserver_default = ResizeObserver;
ResizeObserver._observerInstance = null;
ResizeObserver._elementCallbacks = null;

// node_modules/@ckeditor/ckeditor5-utils/src/dom/setdatainelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function setDataInElement(el, data) {
  if (el instanceof HTMLTextAreaElement) {
    el.value = data;
  }
  el.innerHTML = data;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/tounit.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function toUnit(unit) {
  return (value) => value + unit;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/indexof.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function indexOf(node) {
  let index = 0;
  while (node.previousSibling) {
    node = node.previousSibling;
    index++;
  }
  return index;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/insertat.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function insertAt(parentElement, index, nodeToInsert) {
  parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index] || null);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/iscomment.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isComment(obj) {
  return obj && obj.nodeType === Node.COMMENT_NODE;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isvalidattributename.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isValidAttributeName(name) {
  try {
    global_default.document.createAttribute(name);
  } catch (error) {
    return false;
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/isvisible.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isVisible(element) {
  return !!(element && element.getClientRects && element.getClientRects().length);
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getOptimalPosition({element, target, positions, limiter, fitInViewport, viewportOffsetConfig}) {
  if (isFunction_default(target)) {
    target = target();
  }
  if (isFunction_default(limiter)) {
    limiter = limiter();
  }
  const positionedElementAncestor = getPositionedAncestor(element);
  const constrainedViewportRect = getConstrainedViewportRect(viewportOffsetConfig);
  const elementRect = new rect_default(element);
  const visibleTargetRect = getVisibleViewportIntersectionRect(target, constrainedViewportRect);
  let bestPosition;
  if (!visibleTargetRect || !constrainedViewportRect.getIntersection(visibleTargetRect)) {
    return null;
  }
  const positionOptions = {
    targetRect: visibleTargetRect,
    elementRect,
    positionedElementAncestor,
    viewportRect: constrainedViewportRect
  };
  if (!limiter && !fitInViewport) {
    bestPosition = new PositionObject(positions[0], positionOptions);
  } else {
    if (limiter) {
      const visibleLimiterRect = getVisibleViewportIntersectionRect(limiter, constrainedViewportRect);
      if (visibleLimiterRect) {
        positionOptions.limiterRect = visibleLimiterRect;
      }
    }
    bestPosition = getBestPosition(positions, positionOptions);
  }
  return bestPosition;
}
function getVisibleViewportIntersectionRect(source, viewportRect) {
  const visibleSourceRect = new rect_default(source).getVisible();
  if (!visibleSourceRect) {
    return null;
  }
  return visibleSourceRect.getIntersection(viewportRect);
}
function getConstrainedViewportRect(viewportOffsetConfig) {
  viewportOffsetConfig = Object.assign({top: 0, bottom: 0, left: 0, right: 0}, viewportOffsetConfig);
  const viewportRect = new rect_default(global_default.window);
  viewportRect.top += viewportOffsetConfig.top;
  viewportRect.height -= viewportOffsetConfig.top;
  viewportRect.bottom -= viewportOffsetConfig.bottom;
  viewportRect.height -= viewportOffsetConfig.bottom;
  return viewportRect;
}
function getBestPosition(positions, options) {
  const {elementRect} = options;
  const elementRectArea = elementRect.getArea();
  const positionInstances = positions.map((positioningFunction) => new PositionObject(positioningFunction, options)).filter((position) => !!position.name);
  let maxFitFactor = 0;
  let bestPosition = null;
  for (const position of positionInstances) {
    const {limiterIntersectionArea, viewportIntersectionArea} = position;
    if (limiterIntersectionArea === elementRectArea) {
      return position;
    }
    const fitFactor = viewportIntersectionArea ** 2 + limiterIntersectionArea ** 2;
    if (fitFactor > maxFitFactor) {
      maxFitFactor = fitFactor;
      bestPosition = position;
    }
  }
  return bestPosition;
}
var PositionObject = class {
  constructor(positioningFunction, options) {
    const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect, options.limiterRect);
    if (!positioningFunctionOutput) {
      return;
    }
    const {left, top, name, config} = positioningFunctionOutput;
    this.name = name;
    this.config = config;
    this._positioningFunctionCoordinates = {left, top};
    this._options = options;
  }
  get left() {
    return this._absoluteRect.left;
  }
  get top() {
    return this._absoluteRect.top;
  }
  get limiterIntersectionArea() {
    const limiterRect = this._options.limiterRect;
    if (limiterRect) {
      return limiterRect.getIntersectionArea(this._rect);
    }
    return 0;
  }
  get viewportIntersectionArea() {
    const viewportRect = this._options.viewportRect;
    return viewportRect.getIntersectionArea(this._rect);
  }
  get _rect() {
    if (this._cachedRect) {
      return this._cachedRect;
    }
    this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top);
    return this._cachedRect;
  }
  get _absoluteRect() {
    if (this._cachedAbsoluteRect) {
      return this._cachedAbsoluteRect;
    }
    this._cachedAbsoluteRect = this._rect.toAbsoluteRect();
    return this._cachedAbsoluteRect;
  }
};

// node_modules/@ckeditor/ckeditor5-utils/src/dom/remove.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function remove(node) {
  const parent2 = node.parentNode;
  if (parent2) {
    parent2.removeChild(node);
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function scrollViewportToShowTarget({target, viewportOffset = 0, ancestorOffset = 0, alignToTop, forceScroll}) {
  const targetWindow = getWindow(target);
  let currentWindow = targetWindow;
  let currentFrame = null;
  viewportOffset = normalizeViewportOffset(viewportOffset);
  while (currentWindow) {
    let firstAncestorToScroll;
    if (currentWindow == targetWindow) {
      firstAncestorToScroll = getParentElement(target);
    } else {
      firstAncestorToScroll = getParentElement(currentFrame);
    }
    scrollAncestorsToShowRect({
      parent: firstAncestorToScroll,
      getRect: () => {
        return getRectRelativeToWindow(target, currentWindow);
      },
      alignToTop,
      ancestorOffset,
      forceScroll
    });
    const targetRect = getRectRelativeToWindow(target, currentWindow);
    scrollWindowToShowRect({
      window: currentWindow,
      rect: targetRect,
      viewportOffset,
      alignToTop,
      forceScroll
    });
    if (currentWindow.parent != currentWindow) {
      currentFrame = currentWindow.frameElement;
      currentWindow = currentWindow.parent;
      if (!currentFrame) {
        return;
      }
    } else {
      currentWindow = null;
    }
  }
}
function scrollAncestorsToShowTarget(target, ancestorOffset, limiterElement) {
  const targetParent = getParentElement(target);
  scrollAncestorsToShowRect({
    parent: targetParent,
    getRect: () => new rect_default(target),
    ancestorOffset,
    limiterElement
  });
}
function scrollWindowToShowRect({window: window2, rect, alignToTop, forceScroll, viewportOffset}) {
  const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset.bottom);
  const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset.top);
  const viewportRect = new rect_default(window2).excludeScrollbarsAndBorders();
  const rects = [targetShiftedUpRect, targetShiftedDownRect];
  const forceScrollToTop = alignToTop && forceScroll;
  const allRectsFitInViewport = rects.every((rect2) => viewportRect.contains(rect2));
  let {scrollX, scrollY} = window2;
  const initialScrollX = scrollX;
  const initialScrollY = scrollY;
  if (forceScrollToTop) {
    scrollY -= viewportRect.top - rect.top + viewportOffset.top;
  } else if (!allRectsFitInViewport) {
    if (isAbove(targetShiftedUpRect, viewportRect)) {
      scrollY -= viewportRect.top - rect.top + viewportOffset.top;
    } else if (isBelow(targetShiftedDownRect, viewportRect)) {
      if (alignToTop) {
        scrollY += rect.top - viewportRect.top - viewportOffset.top;
      } else {
        scrollY += rect.bottom - viewportRect.bottom + viewportOffset.bottom;
      }
    }
  }
  if (!allRectsFitInViewport) {
    if (isLeftOf(rect, viewportRect)) {
      scrollX -= viewportRect.left - rect.left + viewportOffset.left;
    } else if (isRightOf(rect, viewportRect)) {
      scrollX += rect.right - viewportRect.right + viewportOffset.right;
    }
  }
  if (scrollX != initialScrollX || scrollY !== initialScrollY) {
    window2.scrollTo(scrollX, scrollY);
  }
}
function scrollAncestorsToShowRect({parent: parent2, getRect, alignToTop, forceScroll, ancestorOffset = 0, limiterElement}) {
  const parentWindow = getWindow(parent2);
  const forceScrollToTop = alignToTop && forceScroll;
  let parentRect, targetRect, targetFitsInTarget;
  const limiter = limiterElement || parentWindow.document.body;
  while (parent2 != limiter) {
    targetRect = getRect();
    parentRect = new rect_default(parent2).excludeScrollbarsAndBorders();
    targetFitsInTarget = parentRect.contains(targetRect);
    if (forceScrollToTop) {
      parent2.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
    } else if (!targetFitsInTarget) {
      if (isAbove(targetRect, parentRect)) {
        parent2.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
      } else if (isBelow(targetRect, parentRect)) {
        if (alignToTop) {
          parent2.scrollTop += targetRect.top - parentRect.top - ancestorOffset;
        } else {
          parent2.scrollTop += targetRect.bottom - parentRect.bottom + ancestorOffset;
        }
      }
    }
    if (!targetFitsInTarget) {
      if (isLeftOf(targetRect, parentRect)) {
        parent2.scrollLeft -= parentRect.left - targetRect.left + ancestorOffset;
      } else if (isRightOf(targetRect, parentRect)) {
        parent2.scrollLeft += targetRect.right - parentRect.right + ancestorOffset;
      }
    }
    parent2 = parent2.parentNode;
  }
}
function isBelow(firstRect, secondRect) {
  return firstRect.bottom > secondRect.bottom;
}
function isAbove(firstRect, secondRect) {
  return firstRect.top < secondRect.top;
}
function isLeftOf(firstRect, secondRect) {
  return firstRect.left < secondRect.left;
}
function isRightOf(firstRect, secondRect) {
  return firstRect.right > secondRect.right;
}
function getWindow(elementOrRange) {
  if (isRange(elementOrRange)) {
    return elementOrRange.startContainer.ownerDocument.defaultView;
  } else {
    return elementOrRange.ownerDocument.defaultView;
  }
}
function getParentElement(elementOrRange) {
  if (isRange(elementOrRange)) {
    let parent2 = elementOrRange.commonAncestorContainer;
    if (isText(parent2)) {
      parent2 = parent2.parentNode;
    }
    return parent2;
  } else {
    return elementOrRange.parentNode;
  }
}
function getRectRelativeToWindow(target, relativeWindow) {
  const targetWindow = getWindow(target);
  const rect = new rect_default(target);
  if (targetWindow === relativeWindow) {
    return rect;
  } else {
    let currentWindow = targetWindow;
    while (currentWindow != relativeWindow) {
      const frame = currentWindow.frameElement;
      const frameRect = new rect_default(frame).excludeScrollbarsAndBorders();
      rect.moveBy(frameRect.left, frameRect.top);
      currentWindow = currentWindow.parent;
    }
  }
  return rect;
}
function normalizeViewportOffset(viewportOffset) {
  if (typeof viewportOffset === "number") {
    return {
      top: viewportOffset,
      bottom: viewportOffset,
      left: viewportOffset,
      right: viewportOffset
    };
  }
  return viewportOffset;
}

// node_modules/@ckeditor/ckeditor5-utils/src/keyboard.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var modifiersToGlyphsMac = {
  ctrl: "\u2303",
  cmd: "\u2318",
  alt: "\u2325",
  shift: "\u21E7"
};
var modifiersToGlyphsNonMac = {
  ctrl: "Ctrl+",
  alt: "Alt+",
  shift: "Shift+"
};
var keyCodes = generateKnownKeyCodes();
var keyCodeNames = Object.fromEntries(Object.entries(keyCodes).map(([name, code]) => [code, name.charAt(0).toUpperCase() + name.slice(1)]));
function getCode(key) {
  let keyCode;
  if (typeof key == "string") {
    keyCode = keyCodes[key.toLowerCase()];
    if (!keyCode) {
      throw new ckeditorerror_default("keyboard-unknown-key", null, {key});
    }
  } else {
    keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0) + (key.metaKey ? keyCodes.cmd : 0);
  }
  return keyCode;
}
function parseKeystroke(keystroke) {
  if (typeof keystroke == "string") {
    keystroke = splitKeystrokeText(keystroke);
  }
  return keystroke.map((key) => typeof key == "string" ? getEnvKeyCode(key) : key).reduce((key, sum) => sum + key, 0);
}
function getEnvKeystrokeText(keystroke) {
  let keystrokeCode = parseKeystroke(keystroke);
  const modifiersToGlyphs = Object.entries(env_default.isMac || env_default.isiOS ? modifiersToGlyphsMac : modifiersToGlyphsNonMac);
  const modifiers = modifiersToGlyphs.reduce((modifiers2, [name, glyph]) => {
    if ((keystrokeCode & keyCodes[name]) != 0) {
      keystrokeCode &= ~keyCodes[name];
      modifiers2 += glyph;
    }
    return modifiers2;
  }, "");
  return modifiers + (keystrokeCode ? keyCodeNames[keystrokeCode] : "");
}
function isArrowKeyCode(keyCode) {
  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
}
function getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection) {
  const isLtrContent = contentLanguageDirection === "ltr";
  switch (keyCode) {
    case keyCodes.arrowleft:
      return isLtrContent ? "left" : "right";
    case keyCodes.arrowright:
      return isLtrContent ? "right" : "left";
    case keyCodes.arrowup:
      return "up";
    case keyCodes.arrowdown:
      return "down";
  }
}
function getEnvKeyCode(key) {
  if (key.endsWith("!")) {
    return getCode(key.slice(0, -1));
  }
  const code = getCode(key);
  return (env_default.isMac || env_default.isiOS) && code == keyCodes.ctrl ? keyCodes.cmd : code;
}
function isForwardArrowKeyCode(keyCode, contentLanguageDirection) {
  const localizedKeyCodeDirection = getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection);
  return localizedKeyCodeDirection === "down" || localizedKeyCodeDirection === "right";
}
function generateKnownKeyCodes() {
  const keyCodes2 = {
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    space: 32,
    esc: 27,
    tab: 9,
    ctrl: 1114112,
    shift: 2228224,
    alt: 4456448,
    cmd: 8912896
  };
  for (let code = 65; code <= 90; code++) {
    const letter = String.fromCharCode(code);
    keyCodes2[letter.toLowerCase()] = code;
  }
  for (let code = 48; code <= 57; code++) {
    keyCodes2[code - 48] = code;
  }
  for (let code = 112; code <= 123; code++) {
    keyCodes2["f" + (code - 111)] = code;
  }
  for (const char of "`-=[];',./\\") {
    keyCodes2[char] = char.charCodeAt(0);
  }
  return keyCodes2;
}
function splitKeystrokeText(keystroke) {
  return keystroke.split("+").map((key) => key.trim());
}

// node_modules/@ckeditor/ckeditor5-utils/src/language.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var RTL_LANGUAGE_CODES = [
  "ar",
  "ara",
  "fa",
  "per",
  "fas",
  "he",
  "heb",
  "ku",
  "kur",
  "ug",
  "uig"
];
function getLanguageDirection(languageCode) {
  return RTL_LANGUAGE_CODES.includes(languageCode) ? "rtl" : "ltr";
}

// node_modules/@ckeditor/ckeditor5-utils/src/toarray.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function toArray(data) {
  return Array.isArray(data) ? data : [data];
}

// node_modules/@ckeditor/ckeditor5-utils/src/translation-service.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
/* istanbul ignore else -- @preserve */
if (!global_default.window.CKEDITOR_TRANSLATIONS) {
  global_default.window.CKEDITOR_TRANSLATIONS = {};
}
function _translate(language, message, quantity = 1) {
  if (typeof quantity !== "number") {
    throw new ckeditorerror_default("translation-service-quantity-not-a-number", null, {quantity});
  }
  const numberOfLanguages = getNumberOfLanguages();
  if (numberOfLanguages === 1) {
    language = Object.keys(global_default.window.CKEDITOR_TRANSLATIONS)[0];
  }
  const messageId = message.id || message.string;
  if (numberOfLanguages === 0 || !hasTranslation(language, messageId)) {
    if (quantity !== 1) {
      return message.plural;
    }
    return message.string;
  }
  const dictionary = global_default.window.CKEDITOR_TRANSLATIONS[language].dictionary;
  const getPluralForm = global_default.window.CKEDITOR_TRANSLATIONS[language].getPluralForm || ((n) => n === 1 ? 0 : 1);
  const translation = dictionary[messageId];
  if (typeof translation === "string") {
    return translation;
  }
  const pluralFormIndex = Number(getPluralForm(quantity));
  return translation[pluralFormIndex];
}
function hasTranslation(language, messageId) {
  return !!global_default.window.CKEDITOR_TRANSLATIONS[language] && !!global_default.window.CKEDITOR_TRANSLATIONS[language].dictionary[messageId];
}
function getNumberOfLanguages() {
  return Object.keys(global_default.window.CKEDITOR_TRANSLATIONS).length;
}

// node_modules/@ckeditor/ckeditor5-utils/src/locale.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Locale = class {
  constructor({uiLanguage = "en", contentLanguage} = {}) {
    this.uiLanguage = uiLanguage;
    this.contentLanguage = contentLanguage || this.uiLanguage;
    this.uiLanguageDirection = getLanguageDirection(this.uiLanguage);
    this.contentLanguageDirection = getLanguageDirection(this.contentLanguage);
    this.t = (message, values) => this._t(message, values);
  }
  get language() {
    console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.");
    return this.uiLanguage;
  }
  _t(message, values = []) {
    values = toArray(values);
    if (typeof message === "string") {
      message = {string: message};
    }
    const hasPluralForm = !!message.plural;
    const quantity = hasPluralForm ? values[0] : 1;
    const translatedString = _translate(this.uiLanguage, message, quantity);
    return interpolateString(translatedString, values);
  }
};
var locale_default = Locale;
function interpolateString(string, values) {
  return string.replace(/%(\d+)/g, (match, index) => {
    return index < values.length ? values[index] : match;
  });
}

// node_modules/@ckeditor/ckeditor5-utils/src/collection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Collection = class extends EmitterMixin() {
  constructor(initialItemsOrOptions = {}, options = {}) {
    super();
    const hasInitialItems = isIterable(initialItemsOrOptions);
    if (!hasInitialItems) {
      options = initialItemsOrOptions;
    }
    this._items = [];
    this._itemMap = new Map();
    this._idProperty = options.idProperty || "id";
    this._bindToExternalToInternalMap = new WeakMap();
    this._bindToInternalToExternalMap = new WeakMap();
    this._skippedIndexesFromExternal = [];
    if (hasInitialItems) {
      for (const item of initialItemsOrOptions) {
        this._items.push(item);
        this._itemMap.set(this._getItemIdBeforeAdding(item), item);
      }
    }
  }
  get length() {
    return this._items.length;
  }
  get first() {
    return this._items[0] || null;
  }
  get last() {
    return this._items[this.length - 1] || null;
  }
  add(item, index) {
    return this.addMany([item], index);
  }
  addMany(items, index) {
    if (index === void 0) {
      index = this._items.length;
    } else if (index > this._items.length || index < 0) {
      throw new ckeditorerror_default("collection-add-item-invalid-index", this);
    }
    let offset = 0;
    for (const item of items) {
      const itemId = this._getItemIdBeforeAdding(item);
      const currentItemIndex = index + offset;
      this._items.splice(currentItemIndex, 0, item);
      this._itemMap.set(itemId, item);
      this.fire("add", item, currentItemIndex);
      offset++;
    }
    this.fire("change", {
      added: items,
      removed: [],
      index
    });
    return this;
  }
  get(idOrIndex) {
    let item;
    if (typeof idOrIndex == "string") {
      item = this._itemMap.get(idOrIndex);
    } else if (typeof idOrIndex == "number") {
      item = this._items[idOrIndex];
    } else {
      throw new ckeditorerror_default("collection-get-invalid-arg", this);
    }
    return item || null;
  }
  has(itemOrId) {
    if (typeof itemOrId == "string") {
      return this._itemMap.has(itemOrId);
    } else {
      const idProperty = this._idProperty;
      const id = itemOrId[idProperty];
      return id && this._itemMap.has(id);
    }
  }
  getIndex(itemOrId) {
    let item;
    if (typeof itemOrId == "string") {
      item = this._itemMap.get(itemOrId);
    } else {
      item = itemOrId;
    }
    return item ? this._items.indexOf(item) : -1;
  }
  remove(subject) {
    const [item, index] = this._remove(subject);
    this.fire("change", {
      added: [],
      removed: [item],
      index
    });
    return item;
  }
  map(callback, ctx) {
    return this._items.map(callback, ctx);
  }
  find(callback, ctx) {
    return this._items.find(callback, ctx);
  }
  filter(callback, ctx) {
    return this._items.filter(callback, ctx);
  }
  clear() {
    if (this._bindToCollection) {
      this.stopListening(this._bindToCollection);
      this._bindToCollection = null;
    }
    const removedItems = Array.from(this._items);
    while (this.length) {
      this._remove(0);
    }
    this.fire("change", {
      added: [],
      removed: removedItems,
      index: 0
    });
  }
  bindTo(externalCollection) {
    if (this._bindToCollection) {
      throw new ckeditorerror_default("collection-bind-to-rebind", this);
    }
    this._bindToCollection = externalCollection;
    return {
      as: (Class) => {
        this._setUpBindToBinding((item) => new Class(item));
      },
      using: (callbackOrProperty) => {
        if (typeof callbackOrProperty == "function") {
          this._setUpBindToBinding(callbackOrProperty);
        } else {
          this._setUpBindToBinding((item) => item[callbackOrProperty]);
        }
      }
    };
  }
  _setUpBindToBinding(factory) {
    const externalCollection = this._bindToCollection;
    const addItem = (evt, externalItem, index) => {
      const isExternalBoundToThis = externalCollection._bindToCollection == this;
      const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);
      if (isExternalBoundToThis && externalItemBound) {
        this._bindToExternalToInternalMap.set(externalItem, externalItemBound);
        this._bindToInternalToExternalMap.set(externalItemBound, externalItem);
      } else {
        const item = factory(externalItem);
        if (!item) {
          this._skippedIndexesFromExternal.push(index);
          return;
        }
        let finalIndex = index;
        for (const skipped of this._skippedIndexesFromExternal) {
          if (index > skipped) {
            finalIndex--;
          }
        }
        for (const skipped of externalCollection._skippedIndexesFromExternal) {
          if (finalIndex >= skipped) {
            finalIndex++;
          }
        }
        this._bindToExternalToInternalMap.set(externalItem, item);
        this._bindToInternalToExternalMap.set(item, externalItem);
        this.add(item, finalIndex);
        for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {
          if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {
            externalCollection._skippedIndexesFromExternal[i]++;
          }
        }
      }
    };
    for (const externalItem of externalCollection) {
      addItem(null, externalItem, externalCollection.getIndex(externalItem));
    }
    this.listenTo(externalCollection, "add", addItem);
    this.listenTo(externalCollection, "remove", (evt, externalItem, index) => {
      const item = this._bindToExternalToInternalMap.get(externalItem);
      if (item) {
        this.remove(item);
      }
      this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {
        if (index < skipped) {
          result.push(skipped - 1);
        }
        if (index > skipped) {
          result.push(skipped);
        }
        return result;
      }, []);
    });
  }
  _getItemIdBeforeAdding(item) {
    const idProperty = this._idProperty;
    let itemId;
    if (idProperty in item) {
      itemId = item[idProperty];
      if (typeof itemId != "string") {
        throw new ckeditorerror_default("collection-add-invalid-id", this);
      }
      if (this.get(itemId)) {
        throw new ckeditorerror_default("collection-add-item-already-exists", this);
      }
    } else {
      item[idProperty] = itemId = uid();
    }
    return itemId;
  }
  _remove(subject) {
    let index, id, item;
    let itemDoesNotExist = false;
    const idProperty = this._idProperty;
    if (typeof subject == "string") {
      id = subject;
      item = this._itemMap.get(id);
      itemDoesNotExist = !item;
      if (item) {
        index = this._items.indexOf(item);
      }
    } else if (typeof subject == "number") {
      index = subject;
      item = this._items[index];
      itemDoesNotExist = !item;
      if (item) {
        id = item[idProperty];
      }
    } else {
      item = subject;
      id = item[idProperty];
      index = this._items.indexOf(item);
      itemDoesNotExist = index == -1 || !this._itemMap.get(id);
    }
    if (itemDoesNotExist) {
      throw new ckeditorerror_default("collection-remove-404", this);
    }
    this._items.splice(index, 1);
    this._itemMap.delete(id);
    const externalItem = this._bindToInternalToExternalMap.get(item);
    this._bindToInternalToExternalMap.delete(item);
    this._bindToExternalToInternalMap.delete(externalItem);
    this.fire("remove", item, index);
    return [item, index];
  }
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
};
var collection_default = Collection;

// node_modules/@ckeditor/ckeditor5-utils/src/first.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function first(iterator) {
  const iteratorItem = iterator.next();
  if (iteratorItem.done) {
    return null;
  }
  return iteratorItem.value;
}

// node_modules/@ckeditor/ckeditor5-utils/src/focustracker.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var FocusTracker = class extends DomEmitterMixin(ObservableMixin()) {
  constructor() {
    super();
    this._elements = new Set();
    this._nextEventLoopTimeout = null;
    this.set("isFocused", false);
    this.set("focusedElement", null);
  }
  add(element) {
    if (this._elements.has(element)) {
      throw new ckeditorerror_default("focustracker-add-element-already-exist", this);
    }
    this.listenTo(element, "focus", () => this._focus(element), {useCapture: true});
    this.listenTo(element, "blur", () => this._blur(), {useCapture: true});
    this._elements.add(element);
  }
  remove(element) {
    if (element === this.focusedElement) {
      this._blur();
    }
    if (this._elements.has(element)) {
      this.stopListening(element);
      this._elements.delete(element);
    }
  }
  destroy() {
    this.stopListening();
  }
  _focus(element) {
    clearTimeout(this._nextEventLoopTimeout);
    this.focusedElement = element;
    this.isFocused = true;
  }
  _blur() {
    clearTimeout(this._nextEventLoopTimeout);
    this._nextEventLoopTimeout = setTimeout(() => {
      this.focusedElement = null;
      this.isFocused = false;
    }, 0);
  }
};
var focustracker_default = FocusTracker;

// node_modules/@ckeditor/ckeditor5-utils/src/keystrokehandler.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var KeystrokeHandler = class {
  constructor() {
    this._listener = new (DomEmitterMixin())();
  }
  listenTo(emitter) {
    this._listener.listenTo(emitter, "keydown", (evt, keyEvtData) => {
      this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
    });
  }
  set(keystroke, callback, options = {}) {
    const keyCode = parseKeystroke(keystroke);
    const priority = options.priority;
    this._listener.listenTo(this._listener, "_keydown:" + keyCode, (evt, keyEvtData) => {
      callback(keyEvtData, () => {
        keyEvtData.preventDefault();
        keyEvtData.stopPropagation();
        evt.stop();
      });
      evt.return = true;
    }, {priority});
  }
  press(keyEvtData) {
    return !!this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
  }
  stopListening(emitter) {
    this._listener.stopListening(emitter);
  }
  destroy() {
    this.stopListening();
  }
};
var keystrokehandler_default = KeystrokeHandler;

// node_modules/@ckeditor/ckeditor5-utils/src/objecttomap.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function objectToMap(obj) {
  const map = new Map();
  for (const key in obj) {
    map.set(key, obj[key]);
  }
  return map;
}

// node_modules/@ckeditor/ckeditor5-utils/src/tomap.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function toMap(data) {
  if (isIterable(data)) {
    return new Map(data);
  } else {
    return objectToMap(data);
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/splicearray.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BIG_CHUNK_SIZE = 1e4;
function spliceArray(target, source, start, count2) {
  if (Math.max(source.length, target.length) > BIG_CHUNK_SIZE) {
    return target.slice(0, start).concat(source).concat(target.slice(start + count2, target.length));
  } else {
    const newTarget = Array.from(target);
    newTarget.splice(start, count2, ...source);
    return newTarget;
  }
}

// node_modules/@ckeditor/ckeditor5-utils/src/delay.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function delay(func, wait) {
  let timer;
  function delayed(...args) {
    delayed.cancel();
    timer = setTimeout(() => func(...args), wait);
  }
  delayed.cancel = () => {
    clearTimeout(timer);
  };
  return delayed;
}

// node_modules/@ckeditor/ckeditor5-utils/src/verifylicense.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function verifyLicense(token) {
  function oldTokenCheck(token2) {
    if (token2.length >= 40 && token2.length <= 255) {
      return "VALID";
    } else {
      return "INVALID";
    }
  }
  if (!token) {
    return "INVALID";
  }
  let decryptedData = "";
  try {
    decryptedData = atob(token);
  } catch (e) {
    return "INVALID";
  }
  const splittedDecryptedData = decryptedData.split("-");
  const firstElement = splittedDecryptedData[0];
  const secondElement = splittedDecryptedData[1];
  if (!secondElement) {
    return oldTokenCheck(token);
  }
  try {
    atob(secondElement);
  } catch (e) {
    try {
      atob(firstElement);
      if (!atob(firstElement).length) {
        return oldTokenCheck(token);
      }
    } catch (e2) {
      return oldTokenCheck(token);
    }
  }
  if (firstElement.length < 40 || firstElement.length > 255) {
    return "INVALID";
  }
  let decryptedSecondElement = "";
  try {
    atob(firstElement);
    decryptedSecondElement = atob(secondElement);
  } catch (e) {
    return "INVALID";
  }
  if (decryptedSecondElement.length !== 8) {
    return "INVALID";
  }
  const year = Number(decryptedSecondElement.substring(0, 4));
  const monthIndex = Number(decryptedSecondElement.substring(4, 6)) - 1;
  const day = Number(decryptedSecondElement.substring(6, 8));
  const date = new Date(year, monthIndex, day);
  if (date < releaseDate || isNaN(Number(date))) {
    return "INVALID";
  }
  return "VALID";
}

// node_modules/@ckeditor/ckeditor5-utils/src/unicode.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function isCombiningMark(character) {
  return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(character);
}
function isHighSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\ud800-\udbff]/.test(character);
}
function isLowSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\udc00-\udfff]/.test(character);
}
function isInsideSurrogatePair(string, offset) {
  return isHighSurrogateHalf(string.charAt(offset - 1)) && isLowSurrogateHalf(string.charAt(offset));
}
function isInsideCombinedSymbol(string, offset) {
  return isCombiningMark(string.charAt(offset));
}
var EMOJI_PATTERN = buildEmojiRegexp();
function isInsideEmojiSequence(string, offset) {
  const matches = String(string).matchAll(EMOJI_PATTERN);
  return Array.from(matches).some((match) => match.index < offset && offset < match.index + match[0].length);
}
function buildEmojiRegexp() {
  const parts = [
    /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
    /\p{Emoji}\u{FE0F}?\u{20E3}/u,
    /\p{Emoji}\u{FE0F}/u,
    /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u
  ];
  const flagSequence = /\p{Regional_Indicator}{2}/u.source;
  const emoji = "(?:" + parts.map((part) => part.source).join("|") + ")";
  const sequence = `${flagSequence}|${emoji}(?:\u200D${emoji})*`;
  return new RegExp(sequence, "ug");
}

// node_modules/@ckeditor/ckeditor5-utils/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-core/src/plugin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Plugin = class extends ObservableMixin() {
  constructor(editor) {
    super();
    this._disableStack = new Set();
    this.editor = editor;
    this.set("isEnabled", true);
  }
  forceDisabled(id) {
    this._disableStack.add(id);
    if (this._disableStack.size == 1) {
      this.on("set:isEnabled", forceDisable, {priority: "highest"});
      this.isEnabled = false;
    }
  }
  clearForceDisabled(id) {
    this._disableStack.delete(id);
    if (this._disableStack.size == 0) {
      this.off("set:isEnabled", forceDisable);
      this.isEnabled = true;
    }
  }
  destroy() {
    this.stopListening();
  }
  static get isContextPlugin() {
    return false;
  }
};
var plugin_default = Plugin;
function forceDisable(evt) {
  evt.return = false;
  evt.stop();
}

// node_modules/@ckeditor/ckeditor5-core/src/command.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Command = class extends ObservableMixin() {
  constructor(editor) {
    super();
    this.editor = editor;
    this.set("value", void 0);
    this.set("isEnabled", false);
    this._affectsData = true;
    this._isEnabledBasedOnSelection = true;
    this._disableStack = new Set();
    this.decorate("execute");
    this.listenTo(this.editor.model.document, "change", () => {
      this.refresh();
    });
    this.listenTo(editor, "change:isReadOnly", () => {
      this.refresh();
    });
    this.on("set:isEnabled", (evt) => {
      if (!this.affectsData) {
        return;
      }
      const selection = editor.model.document.selection;
      const selectionInGraveyard = selection.getFirstPosition().root.rootName == "$graveyard";
      const canEditAtSelection = !selectionInGraveyard && editor.model.canEditAt(selection);
      if (editor.isReadOnly || this._isEnabledBasedOnSelection && !canEditAtSelection) {
        evt.return = false;
        evt.stop();
      }
    }, {priority: "highest"});
    this.on("execute", (evt) => {
      if (!this.isEnabled) {
        evt.stop();
      }
    }, {priority: "high"});
  }
  get affectsData() {
    return this._affectsData;
  }
  set affectsData(affectsData) {
    this._affectsData = affectsData;
  }
  refresh() {
    this.isEnabled = true;
  }
  forceDisabled(id) {
    this._disableStack.add(id);
    if (this._disableStack.size == 1) {
      this.on("set:isEnabled", forceDisable2, {priority: "highest"});
      this.isEnabled = false;
    }
  }
  clearForceDisabled(id) {
    this._disableStack.delete(id);
    if (this._disableStack.size == 0) {
      this.off("set:isEnabled", forceDisable2);
      this.refresh();
    }
  }
  execute(...args) {
    return void 0;
  }
  destroy() {
    this.stopListening();
  }
};
var command_default = Command;
function forceDisable2(evt) {
  evt.return = false;
  evt.stop();
}

// node_modules/@ckeditor/ckeditor5-core/src/multicommand.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MultiCommand = class extends command_default {
  constructor() {
    super(...arguments);
    this._childCommandsDefinitions = [];
  }
  refresh() {
  }
  execute(...args) {
    const command = this._getFirstEnabledCommand();
    return !!command && command.execute(args);
  }
  registerChildCommand(command, options = {}) {
    insertToPriorityArray(this._childCommandsDefinitions, {command, priority: options.priority || "normal"});
    command.on("change:isEnabled", () => this._checkEnabled());
    this._checkEnabled();
  }
  _checkEnabled() {
    this.isEnabled = !!this._getFirstEnabledCommand();
  }
  _getFirstEnabledCommand() {
    const commandDefinition = this._childCommandsDefinitions.find(({command}) => command.isEnabled);
    return commandDefinition && commandDefinition.command;
  }
};
var multicommand_default = MultiCommand;

// node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var PluginCollection = class extends EmitterMixin() {
  constructor(context, availablePlugins = [], contextPlugins = []) {
    super();
    this._plugins = new Map();
    this._context = context;
    this._availablePlugins = new Map();
    for (const PluginConstructor of availablePlugins) {
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
    this._contextPlugins = new Map();
    for (const [PluginConstructor, pluginInstance] of contextPlugins) {
      this._contextPlugins.set(PluginConstructor, pluginInstance);
      this._contextPlugins.set(pluginInstance, PluginConstructor);
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
  }
  *[Symbol.iterator]() {
    for (const entry of this._plugins) {
      if (typeof entry[0] == "function") {
        yield entry;
      }
    }
  }
  get(key) {
    const plugin = this._plugins.get(key);
    if (!plugin) {
      let pluginName = key;
      if (typeof key == "function") {
        pluginName = key.pluginName || key.name;
      }
      throw new ckeditorerror_default("plugincollection-plugin-not-loaded", this._context, {plugin: pluginName});
    }
    return plugin;
  }
  has(key) {
    return this._plugins.has(key);
  }
  init(plugins, pluginsToRemove = [], pluginsSubstitutions = []) {
    const that = this;
    const context = this._context;
    findAvailablePluginConstructors(plugins);
    validatePlugins(plugins);
    const pluginsToLoad = plugins.filter((plugin) => !isPluginRemoved(plugin, pluginsToRemove));
    const pluginConstructors = [...getPluginConstructors(pluginsToLoad)];
    substitutePlugins(pluginConstructors, pluginsSubstitutions);
    const pluginInstances = loadPlugins(pluginConstructors);
    return initPlugins(pluginInstances, "init").then(() => initPlugins(pluginInstances, "afterInit")).then(() => pluginInstances);
    function isPluginConstructor(plugin) {
      return typeof plugin === "function";
    }
    function isContextPlugin(plugin) {
      return isPluginConstructor(plugin) && !!plugin.isContextPlugin;
    }
    function isPluginRemoved(plugin, pluginsToRemove2) {
      return pluginsToRemove2.some((removedPlugin) => {
        if (removedPlugin === plugin) {
          return true;
        }
        if (getPluginName(plugin) === removedPlugin) {
          return true;
        }
        if (getPluginName(removedPlugin) === plugin) {
          return true;
        }
        return false;
      });
    }
    function getPluginName(plugin) {
      return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;
    }
    function findAvailablePluginConstructors(plugins2, processed = new Set()) {
      plugins2.forEach((plugin) => {
        if (!isPluginConstructor(plugin)) {
          return;
        }
        if (processed.has(plugin)) {
          return;
        }
        processed.add(plugin);
        if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {
          that._availablePlugins.set(plugin.pluginName, plugin);
        }
        if (plugin.requires) {
          findAvailablePluginConstructors(plugin.requires, processed);
        }
      });
    }
    function getPluginConstructors(plugins2, processed = new Set()) {
      return plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);
      }).reduce((result, plugin) => {
        if (processed.has(plugin)) {
          return result;
        }
        processed.add(plugin);
        if (plugin.requires) {
          validatePlugins(plugin.requires, plugin);
          getPluginConstructors(plugin.requires, processed).forEach((plugin2) => result.add(plugin2));
        }
        return result.add(plugin);
      }, new Set());
    }
    function validatePlugins(plugins2, parentPluginConstructor = null) {
      plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;
      }).forEach((plugin) => {
        checkMissingPlugin(plugin, parentPluginConstructor);
        checkContextPlugin(plugin, parentPluginConstructor);
        checkRemovedPlugin(plugin, parentPluginConstructor);
      });
    }
    function checkMissingPlugin(plugin, parentPluginConstructor) {
      if (isPluginConstructor(plugin)) {
        return;
      }
      if (parentPluginConstructor) {
        throw new ckeditorerror_default("plugincollection-soft-required", context, {missingPlugin: plugin, requiredBy: getPluginName(parentPluginConstructor)});
      }
      throw new ckeditorerror_default("plugincollection-plugin-not-found", context, {plugin});
    }
    function checkContextPlugin(plugin, parentPluginConstructor) {
      if (!isContextPlugin(parentPluginConstructor)) {
        return;
      }
      if (isContextPlugin(plugin)) {
        return;
      }
      throw new ckeditorerror_default("plugincollection-context-required", context, {plugin: getPluginName(plugin), requiredBy: getPluginName(parentPluginConstructor)});
    }
    function checkRemovedPlugin(plugin, parentPluginConstructor) {
      if (!parentPluginConstructor) {
        return;
      }
      if (!isPluginRemoved(plugin, pluginsToRemove)) {
        return;
      }
      throw new ckeditorerror_default("plugincollection-required", context, {plugin: getPluginName(plugin), requiredBy: getPluginName(parentPluginConstructor)});
    }
    function loadPlugins(pluginConstructors2) {
      return pluginConstructors2.map((PluginConstructor) => {
        let pluginInstance = that._contextPlugins.get(PluginConstructor);
        pluginInstance = pluginInstance || new PluginConstructor(context);
        that._add(PluginConstructor, pluginInstance);
        return pluginInstance;
      });
    }
    function initPlugins(pluginInstances2, method) {
      return pluginInstances2.reduce((promise, plugin) => {
        if (!plugin[method]) {
          return promise;
        }
        if (that._contextPlugins.has(plugin)) {
          return promise;
        }
        return promise.then(plugin[method].bind(plugin));
      }, Promise.resolve());
    }
    function substitutePlugins(pluginConstructors2, pluginsSubstitutions2) {
      for (const pluginItem of pluginsSubstitutions2) {
        if (typeof pluginItem != "function") {
          throw new ckeditorerror_default("plugincollection-replace-plugin-invalid-type", null, {pluginItem});
        }
        const pluginName = pluginItem.pluginName;
        if (!pluginName) {
          throw new ckeditorerror_default("plugincollection-replace-plugin-missing-name", null, {pluginItem});
        }
        if (pluginItem.requires && pluginItem.requires.length) {
          throw new ckeditorerror_default("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {pluginName});
        }
        const pluginToReplace = that._availablePlugins.get(pluginName);
        if (!pluginToReplace) {
          throw new ckeditorerror_default("plugincollection-plugin-for-replacing-not-exist", null, {pluginName});
        }
        const indexInPluginConstructors = pluginConstructors2.indexOf(pluginToReplace);
        if (indexInPluginConstructors === -1) {
          if (that._contextPlugins.has(pluginToReplace)) {
            return;
          }
          throw new ckeditorerror_default("plugincollection-plugin-for-replacing-not-loaded", null, {pluginName});
        }
        if (pluginToReplace.requires && pluginToReplace.requires.length) {
          throw new ckeditorerror_default("plugincollection-replaced-plugin-cannot-have-dependencies", null, {pluginName});
        }
        pluginConstructors2.splice(indexInPluginConstructors, 1, pluginItem);
        that._availablePlugins.set(pluginName, pluginItem);
      }
    }
  }
  destroy() {
    const promises = [];
    for (const [, pluginInstance] of this) {
      if (typeof pluginInstance.destroy == "function" && !this._contextPlugins.has(pluginInstance)) {
        promises.push(pluginInstance.destroy());
      }
    }
    return Promise.all(promises);
  }
  _add(PluginConstructor, plugin) {
    this._plugins.set(PluginConstructor, plugin);
    const pluginName = PluginConstructor.pluginName;
    if (!pluginName) {
      return;
    }
    if (this._plugins.has(pluginName)) {
      throw new ckeditorerror_default("plugincollection-plugin-name-conflict", null, {pluginName, plugin1: this._plugins.get(pluginName).constructor, plugin2: PluginConstructor});
    }
    this._plugins.set(pluginName, plugin);
  }
};
var plugincollection_default = PluginCollection;

// node_modules/@ckeditor/ckeditor5-core/src/context.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Context = class {
  constructor(config) {
    this._contextOwner = null;
    this.config = new config_default(config, this.constructor.defaultConfig);
    const availablePlugins = this.constructor.builtinPlugins;
    this.config.define("plugins", availablePlugins);
    this.plugins = new plugincollection_default(this, availablePlugins);
    const languageConfig = this.config.get("language") || {};
    this.locale = new locale_default({
      uiLanguage: typeof languageConfig === "string" ? languageConfig : languageConfig.ui,
      contentLanguage: this.config.get("language.content")
    });
    this.t = this.locale.t;
    this.editors = new collection_default();
  }
  initPlugins() {
    const plugins = this.config.get("plugins") || [];
    const substitutePlugins = this.config.get("substitutePlugins") || [];
    for (const Plugin2 of plugins.concat(substitutePlugins)) {
      if (typeof Plugin2 != "function") {
        throw new ckeditorerror_default("context-initplugins-constructor-only", null, {Plugin: Plugin2});
      }
      if (Plugin2.isContextPlugin !== true) {
        throw new ckeditorerror_default("context-initplugins-invalid-plugin", null, {Plugin: Plugin2});
      }
    }
    return this.plugins.init(plugins, [], substitutePlugins);
  }
  destroy() {
    return Promise.all(Array.from(this.editors, (editor) => editor.destroy())).then(() => this.plugins.destroy());
  }
  _addEditor(editor, isContextOwner) {
    if (this._contextOwner) {
      throw new ckeditorerror_default("context-addeditor-private-context");
    }
    this.editors.add(editor);
    if (isContextOwner) {
      this._contextOwner = editor;
    }
  }
  _removeEditor(editor) {
    if (this.editors.has(editor)) {
      this.editors.remove(editor);
    }
    if (this._contextOwner === editor) {
      return this.destroy();
    }
    return Promise.resolve();
  }
  _getEditorConfig() {
    const result = {};
    for (const name of this.config.names()) {
      if (!["plugins", "removePlugins", "extraPlugins"].includes(name)) {
        result[name] = this.config.get(name);
      }
    }
    return result;
  }
  static create(config) {
    return new Promise((resolve) => {
      const context = new this(config);
      resolve(context.initPlugins().then(() => context));
    });
  }
};
var context_default = Context;

// node_modules/@ckeditor/ckeditor5-core/src/contextplugin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ContextPlugin = class extends ObservableMixin() {
  constructor(context) {
    super();
    this.context = context;
  }
  destroy() {
    this.stopListening();
  }
  static get isContextPlugin() {
    return true;
  }
};
var contextplugin_default = ContextPlugin;

// node_modules/@ckeditor/ckeditor5-engine/src/view/placeholder.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var documentPlaceholders = new WeakMap();
var hasDisplayedPlaceholderDeprecationWarning = false;
function enablePlaceholder({view, element, text, isDirectHost = true, keepOnFocus = false}) {
  const doc = view.document;
  if (!documentPlaceholders.has(doc)) {
    documentPlaceholders.set(doc, new Map());
    doc.registerPostFixer((writer) => updateDocumentPlaceholders(doc, writer));
    doc.on("change:isComposing", () => {
      view.change((writer) => updateDocumentPlaceholders(doc, writer));
    }, {priority: "high"});
  }
  if (element.is("editableElement")) {
    element.on("change:placeholder", (evtInfo, evt, text2) => {
      setPlaceholder(text2);
    });
  }
  if (element.placeholder) {
    setPlaceholder(element.placeholder);
  } else if (text) {
    setPlaceholder(text);
  }
  if (text) {
    showPlaceholderTextDeprecationWarning();
  }
  function setPlaceholder(text2) {
    documentPlaceholders.get(doc).set(element, {
      text: text2,
      isDirectHost,
      keepOnFocus,
      hostElement: isDirectHost ? element : null
    });
    view.change((writer) => updateDocumentPlaceholders(doc, writer));
  }
}
function disablePlaceholder(view, element) {
  const doc = element.document;
  if (!documentPlaceholders.has(doc)) {
    return;
  }
  view.change((writer) => {
    const placeholders = documentPlaceholders.get(doc);
    const config = placeholders.get(element);
    writer.removeAttribute("data-placeholder", config.hostElement);
    hidePlaceholder(writer, config.hostElement);
    placeholders.delete(element);
  });
}
function showPlaceholder(writer, element) {
  if (!element.hasClass("ck-placeholder")) {
    writer.addClass("ck-placeholder", element);
    return true;
  }
  return false;
}
function hidePlaceholder(writer, element) {
  if (element.hasClass("ck-placeholder")) {
    writer.removeClass("ck-placeholder", element);
    return true;
  }
  return false;
}
function needsPlaceholder(element, keepOnFocus) {
  if (!element.isAttached()) {
    return false;
  }
  const hasContent = Array.from(element.getChildren()).some((element2) => !element2.is("uiElement"));
  if (hasContent) {
    return false;
  }
  const doc = element.document;
  const viewSelection = doc.selection;
  const selectionAnchor = viewSelection.anchor;
  if (doc.isComposing && selectionAnchor && selectionAnchor.parent === element) {
    return false;
  }
  if (keepOnFocus) {
    return true;
  }
  if (!doc.isFocused) {
    return true;
  }
  return !!selectionAnchor && selectionAnchor.parent !== element;
}
function updateDocumentPlaceholders(doc, writer) {
  const placeholders = documentPlaceholders.get(doc);
  const directHostElements = [];
  let wasViewModified = false;
  for (const [element, config] of placeholders) {
    if (config.isDirectHost) {
      directHostElements.push(element);
      if (updatePlaceholder(writer, element, config)) {
        wasViewModified = true;
      }
    }
  }
  for (const [element, config] of placeholders) {
    if (config.isDirectHost) {
      continue;
    }
    const hostElement = getChildPlaceholderHostSubstitute(element);
    if (!hostElement) {
      continue;
    }
    if (directHostElements.includes(hostElement)) {
      continue;
    }
    config.hostElement = hostElement;
    if (updatePlaceholder(writer, element, config)) {
      wasViewModified = true;
    }
  }
  return wasViewModified;
}
function updatePlaceholder(writer, element, config) {
  const {text, isDirectHost, hostElement} = config;
  let wasViewModified = false;
  if (hostElement.getAttribute("data-placeholder") !== text) {
    writer.setAttribute("data-placeholder", text, hostElement);
    wasViewModified = true;
  }
  const isOnlyChild = isDirectHost || element.childCount == 1;
  if (isOnlyChild && needsPlaceholder(hostElement, config.keepOnFocus)) {
    if (showPlaceholder(writer, hostElement)) {
      wasViewModified = true;
    }
  } else if (hidePlaceholder(writer, hostElement)) {
    wasViewModified = true;
  }
  return wasViewModified;
}
function getChildPlaceholderHostSubstitute(parent2) {
  if (parent2.childCount) {
    const firstChild = parent2.getChild(0);
    if (firstChild.is("element") && !firstChild.is("uiElement") && !firstChild.is("attributeElement")) {
      return firstChild;
    }
  }
  return null;
}
function showPlaceholderTextDeprecationWarning() {
  if (!hasDisplayedPlaceholderDeprecationWarning) {
    logWarning("enableplaceholder-deprecated-text-option");
  }
  hasDisplayedPlaceholderDeprecationWarning = true;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/typecheckable.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TypeCheckable = class {
  is() {
    throw new Error("is() method is abstract");
  }
};
var typecheckable_default = TypeCheckable;

// node_modules/@ckeditor/ckeditor5-engine/src/view/node.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Node2 = class extends EmitterMixin(typecheckable_default) {
  constructor(document2) {
    super();
    this.document = document2;
    this.parent = null;
  }
  get index() {
    let pos;
    if (!this.parent) {
      return null;
    }
    if ((pos = this.parent.getChildIndex(this)) == -1) {
      throw new ckeditorerror_default("view-node-not-found-in-parent", this);
    }
    return pos;
  }
  get nextSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index + 1) || null;
  }
  get previousSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index - 1) || null;
  }
  get root() {
    let root2 = this;
    while (root2.parent) {
      root2 = root2.parent;
    }
    return root2;
  }
  isAttached() {
    return this.root.is("rootElement");
  }
  getPath() {
    const path = [];
    let node = this;
    while (node.parent) {
      path.unshift(node.index);
      node = node.parent;
    }
    return path;
  }
  getAncestors(options = {}) {
    const ancestors = [];
    let parent2 = options.includeSelf ? this : this.parent;
    while (parent2) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent2);
      parent2 = parent2.parent;
    }
    return ancestors;
  }
  getCommonAncestor(node, options = {}) {
    const ancestorsA = this.getAncestors(options);
    const ancestorsB = node.getAncestors(options);
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  isBefore(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    const thisPath = this.getPath();
    const nodePath = node.getPath();
    const result = compareArrays(thisPath, nodePath);
    switch (result) {
      case "prefix":
        return true;
      case "extension":
        return false;
      default:
        return thisPath[result] < nodePath[result];
    }
  }
  isAfter(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    return !this.isBefore(node);
  }
  _remove() {
    this.parent._removeChildren(this.index);
  }
  _fireChange(type, node) {
    this.fire(`change:${type}`, node);
    if (this.parent) {
      this.parent._fireChange(type, node);
    }
  }
  toJSON() {
    const json = clone_default(this);
    delete json.parent;
    return json;
  }
};
var node_default = Node2;
Node2.prototype.is = function(type) {
  return type === "node" || type === "view:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/text.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Text = class extends node_default {
  constructor(document2, data) {
    super(document2);
    this._textData = data;
  }
  get data() {
    return this._textData;
  }
  get _data() {
    return this.data;
  }
  set _data(data) {
    this._fireChange("text", this);
    this._textData = data;
  }
  isSimilar(otherNode) {
    if (!(otherNode instanceof Text)) {
      return false;
    }
    return this === otherNode || this.data === otherNode.data;
  }
  _clone() {
    return new Text(this.document, this.data);
  }
};
var text_default = Text;
Text.prototype.is = function(type) {
  return type === "$text" || type === "view:$text" || type === "text" || type === "view:text" || type === "node" || type === "view:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/textproxy.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TextProxy = class extends typecheckable_default {
  constructor(textNode, offsetInText, length) {
    super();
    this.textNode = textNode;
    if (offsetInText < 0 || offsetInText > textNode.data.length) {
      throw new ckeditorerror_default("view-textproxy-wrong-offsetintext", this);
    }
    if (length < 0 || offsetInText + length > textNode.data.length) {
      throw new ckeditorerror_default("view-textproxy-wrong-length", this);
    }
    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    this.offsetInText = offsetInText;
  }
  get offsetSize() {
    return this.data.length;
  }
  get isPartial() {
    return this.data.length !== this.textNode.data.length;
  }
  get parent() {
    return this.textNode.parent;
  }
  get root() {
    return this.textNode.root;
  }
  get document() {
    return this.textNode.document;
  }
  getAncestors(options = {}) {
    const ancestors = [];
    let parent2 = options.includeSelf ? this.textNode : this.parent;
    while (parent2 !== null) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent2);
      parent2 = parent2.parent;
    }
    return ancestors;
  }
};
var textproxy_default = TextProxy;
TextProxy.prototype.is = function(type) {
  return type === "$textProxy" || type === "view:$textProxy" || type === "textProxy" || type === "view:textProxy";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Matcher = class {
  constructor(...pattern) {
    this._patterns = [];
    this.add(...pattern);
  }
  add(...pattern) {
    for (let item of pattern) {
      if (typeof item == "string" || item instanceof RegExp) {
        item = {name: item};
      }
      this._patterns.push(item);
    }
  }
  match(...element) {
    for (const singleElement of element) {
      for (const pattern of this._patterns) {
        const match = isElementMatching(singleElement, pattern);
        if (match) {
          return {
            element: singleElement,
            pattern,
            match
          };
        }
      }
    }
    return null;
  }
  matchAll(...element) {
    const results = [];
    for (const singleElement of element) {
      for (const pattern of this._patterns) {
        const match = isElementMatching(singleElement, pattern);
        if (match) {
          results.push({
            element: singleElement,
            pattern,
            match
          });
        }
      }
    }
    return results.length > 0 ? results : null;
  }
  getElementName() {
    if (this._patterns.length !== 1) {
      return null;
    }
    const pattern = this._patterns[0];
    const name = pattern.name;
    return typeof pattern != "function" && name && !(name instanceof RegExp) ? name : null;
  }
};
var matcher_default = Matcher;
function isElementMatching(element, pattern) {
  if (typeof pattern == "function") {
    return pattern(element);
  }
  const match = {};
  if (pattern.name) {
    match.name = matchName(pattern.name, element.name);
    if (!match.name) {
      return null;
    }
  }
  if (pattern.attributes) {
    match.attributes = matchAttributes(pattern.attributes, element);
    if (!match.attributes) {
      return null;
    }
  }
  if (pattern.classes) {
    match.classes = matchClasses(pattern.classes, element);
    if (!match.classes) {
      return null;
    }
  }
  if (pattern.styles) {
    match.styles = matchStyles(pattern.styles, element);
    if (!match.styles) {
      return null;
    }
  }
  return match;
}
function matchName(pattern, name) {
  if (pattern instanceof RegExp) {
    return !!name.match(pattern);
  }
  return pattern === name;
}
function matchPatterns(patterns, keys2, valueGetter) {
  const normalizedPatterns = normalizePatterns(patterns);
  const normalizedItems = Array.from(keys2);
  const match = [];
  normalizedPatterns.forEach(([patternKey, patternValue]) => {
    normalizedItems.forEach((itemKey) => {
      if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {
        match.push(itemKey);
      }
    });
  });
  if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {
    return void 0;
  }
  return match;
}
function normalizePatterns(patterns) {
  if (Array.isArray(patterns)) {
    return patterns.map((pattern) => {
      if (isPlainObject_default(pattern)) {
        if (pattern.key === void 0 || pattern.value === void 0) {
          logWarning("matcher-pattern-missing-key-or-value", pattern);
        }
        return [pattern.key, pattern.value];
      }
      return [pattern, true];
    });
  }
  if (isPlainObject_default(patterns)) {
    return Object.entries(patterns);
  }
  return [[patterns, true]];
}
function isKeyMatched(patternKey, itemKey) {
  return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);
}
function isValueMatched(patternValue, itemKey, valueGetter) {
  if (patternValue === true) {
    return true;
  }
  const itemValue = valueGetter(itemKey);
  return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);
}
function matchAttributes(patterns, element) {
  const attributeKeys = new Set(element.getAttributeKeys());
  if (isPlainObject_default(patterns)) {
    if (patterns.style !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-style-key", patterns);
    }
    if (patterns.class !== void 0) {
      logWarning("matcher-pattern-deprecated-attributes-class-key", patterns);
    }
  } else {
    attributeKeys.delete("style");
    attributeKeys.delete("class");
  }
  return matchPatterns(patterns, attributeKeys, (key) => element.getAttribute(key));
}
function matchClasses(patterns, element) {
  return matchPatterns(patterns, element.getClassNames(), () => {
  });
}
function matchStyles(patterns, element) {
  return matchPatterns(patterns, element.getStyleNames(true), (key) => element.getStyle(key));
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var StylesMap = class {
  constructor(styleProcessor) {
    this._styles = {};
    this._styleProcessor = styleProcessor;
  }
  get isEmpty() {
    const entries = Object.entries(this._styles);
    const from = Array.from(entries);
    return !from.length;
  }
  get size() {
    if (this.isEmpty) {
      return 0;
    }
    return this.getStyleNames().length;
  }
  setTo(inlineStyle) {
    this.clear();
    const parsedStyles = Array.from(parseInlineStyles(inlineStyle).entries());
    for (const [key, value] of parsedStyles) {
      this._styleProcessor.toNormalizedForm(key, value, this._styles);
    }
  }
  has(name) {
    if (this.isEmpty) {
      return false;
    }
    const styles = this._styleProcessor.getReducedForm(name, this._styles);
    const propertyDescriptor = styles.find(([property]) => property === name);
    return Array.isArray(propertyDescriptor);
  }
  set(nameOrObject, valueOrObject) {
    if (isObject_default(nameOrObject)) {
      for (const [key, value] of Object.entries(nameOrObject)) {
        this._styleProcessor.toNormalizedForm(key, value, this._styles);
      }
    } else {
      this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
    }
  }
  remove(name) {
    const path = toPath(name);
    unset_default(this._styles, path);
    delete this._styles[name];
    this._cleanEmptyObjectsOnPath(path);
  }
  getNormalized(name) {
    return this._styleProcessor.getNormalized(name, this._styles);
  }
  toString() {
    if (this.isEmpty) {
      return "";
    }
    return this._getStylesEntries().map((arr) => arr.join(":")).sort().join(";") + ";";
  }
  getAsString(propertyName) {
    if (this.isEmpty) {
      return;
    }
    if (this._styles[propertyName] && !isObject_default(this._styles[propertyName])) {
      return this._styles[propertyName];
    }
    const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);
    const propertyDescriptor = styles.find(([property]) => property === propertyName);
    if (Array.isArray(propertyDescriptor)) {
      return propertyDescriptor[1];
    }
  }
  getStyleNames(expand = false) {
    if (this.isEmpty) {
      return [];
    }
    if (expand) {
      return this._styleProcessor.getStyleNames(this._styles);
    }
    const entries = this._getStylesEntries();
    return entries.map(([key]) => key);
  }
  clear() {
    this._styles = {};
  }
  _getStylesEntries() {
    const parsed = [];
    const keys2 = Object.keys(this._styles);
    for (const key of keys2) {
      parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));
    }
    return parsed;
  }
  _cleanEmptyObjectsOnPath(path) {
    const pathParts = path.split(".");
    const isChildPath = pathParts.length > 1;
    if (!isChildPath) {
      return;
    }
    const parentPath = pathParts.splice(0, pathParts.length - 1).join(".");
    const parentObject = get_default(this._styles, parentPath);
    if (!parentObject) {
      return;
    }
    const isParentEmpty = !Array.from(Object.keys(parentObject)).length;
    if (isParentEmpty) {
      this.remove(parentPath);
    }
  }
};
var stylesmap_default = StylesMap;
var StylesProcessor = class {
  constructor() {
    this._normalizers = new Map();
    this._extractors = new Map();
    this._reducers = new Map();
    this._consumables = new Map();
  }
  toNormalizedForm(name, propertyValue, styles) {
    if (isObject_default(propertyValue)) {
      appendStyleValue(styles, toPath(name), propertyValue);
      return;
    }
    if (this._normalizers.has(name)) {
      const normalizer = this._normalizers.get(name);
      const {path, value} = normalizer(propertyValue);
      appendStyleValue(styles, path, value);
    } else {
      appendStyleValue(styles, name, propertyValue);
    }
  }
  getNormalized(name, styles) {
    if (!name) {
      return merge_default({}, styles);
    }
    if (styles[name] !== void 0) {
      return styles[name];
    }
    if (this._extractors.has(name)) {
      const extractor = this._extractors.get(name);
      if (typeof extractor === "string") {
        return get_default(styles, extractor);
      }
      const value = extractor(name, styles);
      if (value) {
        return value;
      }
    }
    return get_default(styles, toPath(name));
  }
  getReducedForm(name, styles) {
    const normalizedValue = this.getNormalized(name, styles);
    if (normalizedValue === void 0) {
      return [];
    }
    if (this._reducers.has(name)) {
      const reducer = this._reducers.get(name);
      return reducer(normalizedValue);
    }
    return [[name, normalizedValue]];
  }
  getStyleNames(styles) {
    const expandedStyleNames = Array.from(this._consumables.keys()).filter((name) => {
      const style = this.getNormalized(name, styles);
      if (style && typeof style == "object") {
        return Object.keys(style).length;
      }
      return style;
    });
    const styleNamesKeysSet = new Set([
      ...expandedStyleNames,
      ...Object.keys(styles)
    ]);
    return Array.from(styleNamesKeysSet.values());
  }
  getRelatedStyles(name) {
    return this._consumables.get(name) || [];
  }
  setNormalizer(name, callback) {
    this._normalizers.set(name, callback);
  }
  setExtractor(name, callbackOrPath) {
    this._extractors.set(name, callbackOrPath);
  }
  setReducer(name, callback) {
    this._reducers.set(name, callback);
  }
  setStyleRelation(shorthandName, styleNames) {
    this._mapStyleNames(shorthandName, styleNames);
    for (const alsoName of styleNames) {
      this._mapStyleNames(alsoName, [shorthandName]);
    }
  }
  _mapStyleNames(name, styleNames) {
    if (!this._consumables.has(name)) {
      this._consumables.set(name, []);
    }
    this._consumables.get(name).push(...styleNames);
  }
};
function parseInlineStyles(stylesString) {
  let quoteType = null;
  let propertyNameStart = 0;
  let propertyValueStart = 0;
  let propertyName = null;
  const stylesMap = new Map();
  if (stylesString === "") {
    return stylesMap;
  }
  if (stylesString.charAt(stylesString.length - 1) != ";") {
    stylesString = stylesString + ";";
  }
  for (let i = 0; i < stylesString.length; i++) {
    const char = stylesString.charAt(i);
    if (quoteType === null) {
      switch (char) {
        case ":":
          if (!propertyName) {
            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);
            propertyValueStart = i + 1;
          }
          break;
        case '"':
        case "'":
          quoteType = char;
          break;
        case ";": {
          const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);
          if (propertyName) {
            stylesMap.set(propertyName.trim(), propertyValue.trim());
          }
          propertyName = null;
          propertyNameStart = i + 1;
          break;
        }
      }
    } else if (char === quoteType) {
      quoteType = null;
    }
  }
  return stylesMap;
}
function toPath(name) {
  return name.replace("-", ".");
}
function appendStyleValue(stylesObject, nameOrPath, valueOrObject) {
  let valueToSet = valueOrObject;
  if (isObject_default(valueOrObject)) {
    valueToSet = merge_default({}, get_default(stylesObject, nameOrPath), valueOrObject);
  }
  set_default(stylesObject, nameOrPath, valueToSet);
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/element.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Element = class extends node_default {
  constructor(document2, name, attrs, children) {
    super(document2);
    this._unsafeAttributesToRender = [];
    this._customProperties = new Map();
    this.name = name;
    this._attrs = parseAttributes(attrs);
    this._children = [];
    if (children) {
      this._insertChild(0, children);
    }
    this._classes = new Set();
    if (this._attrs.has("class")) {
      const classString = this._attrs.get("class");
      parseClasses(this._classes, classString);
      this._attrs.delete("class");
    }
    this._styles = new stylesmap_default(this.document.stylesProcessor);
    if (this._attrs.has("style")) {
      this._styles.setTo(this._attrs.get("style"));
      this._attrs.delete("style");
    }
  }
  get childCount() {
    return this._children.length;
  }
  get isEmpty() {
    return this._children.length === 0;
  }
  getChild(index) {
    return this._children[index];
  }
  getChildIndex(node) {
    return this._children.indexOf(node);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  *getAttributeKeys() {
    if (this._classes.size > 0) {
      yield "class";
    }
    if (!this._styles.isEmpty) {
      yield "style";
    }
    yield* this._attrs.keys();
  }
  *getAttributes() {
    yield* this._attrs.entries();
    if (this._classes.size > 0) {
      yield ["class", this.getAttribute("class")];
    }
    if (!this._styles.isEmpty) {
      yield ["style", this.getAttribute("style")];
    }
  }
  getAttribute(key) {
    if (key == "class") {
      if (this._classes.size > 0) {
        return [...this._classes].join(" ");
      }
      return void 0;
    }
    if (key == "style") {
      const inlineStyle = this._styles.toString();
      return inlineStyle == "" ? void 0 : inlineStyle;
    }
    return this._attrs.get(key);
  }
  hasAttribute(key) {
    if (key == "class") {
      return this._classes.size > 0;
    }
    if (key == "style") {
      return !this._styles.isEmpty;
    }
    return this._attrs.has(key);
  }
  isSimilar(otherElement) {
    if (!(otherElement instanceof Element)) {
      return false;
    }
    if (this === otherElement) {
      return true;
    }
    if (this.name != otherElement.name) {
      return false;
    }
    if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
      return false;
    }
    for (const [key, value] of this._attrs) {
      if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
        return false;
      }
    }
    for (const className of this._classes) {
      if (!otherElement._classes.has(className)) {
        return false;
      }
    }
    for (const property of this._styles.getStyleNames()) {
      if (!otherElement._styles.has(property) || otherElement._styles.getAsString(property) !== this._styles.getAsString(property)) {
        return false;
      }
    }
    return true;
  }
  hasClass(...className) {
    for (const name of className) {
      if (!this._classes.has(name)) {
        return false;
      }
    }
    return true;
  }
  getClassNames() {
    return this._classes.keys();
  }
  getStyle(property) {
    return this._styles.getAsString(property);
  }
  getNormalizedStyle(property) {
    return this._styles.getNormalized(property);
  }
  getStyleNames(expand) {
    return this._styles.getStyleNames(expand);
  }
  hasStyle(...property) {
    for (const name of property) {
      if (!this._styles.has(name)) {
        return false;
      }
    }
    return true;
  }
  findAncestor(...patterns) {
    const matcher = new matcher_default(...patterns);
    let parent2 = this.parent;
    while (parent2 && !parent2.is("documentFragment")) {
      if (matcher.match(parent2)) {
        return parent2;
      }
      parent2 = parent2.parent;
    }
    return null;
  }
  getCustomProperty(key) {
    return this._customProperties.get(key);
  }
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  getIdentity() {
    const classes = Array.from(this._classes).sort().join(",");
    const styles = this._styles.toString();
    const attributes = Array.from(this._attrs).map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
    return this.name + (classes == "" ? "" : ` class="${classes}"`) + (!styles ? "" : ` style="${styles}"`) + (attributes == "" ? "" : ` ${attributes}`);
  }
  shouldRenderUnsafeAttribute(attributeName) {
    return this._unsafeAttributesToRender.includes(attributeName);
  }
  _clone(deep = false) {
    const childrenClone = [];
    if (deep) {
      for (const child of this.getChildren()) {
        childrenClone.push(child._clone(deep));
      }
    }
    const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);
    cloned._classes = new Set(this._classes);
    cloned._styles.set(this._styles.getNormalized());
    cloned._customProperties = new Map(this._customProperties);
    cloned.getFillerOffset = this.getFillerOffset;
    cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;
    return cloned;
  }
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  _insertChild(index, items) {
    this._fireChange("children", this);
    let count2 = 0;
    const nodes = normalize(this.document, items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
      node.document = this.document;
      this._children.splice(index, 0, node);
      index++;
      count2++;
    }
    return count2;
  }
  _removeChildren(index, howMany = 1) {
    this._fireChange("children", this);
    for (let i = index; i < index + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index, howMany);
  }
  _setAttribute(key, value) {
    const stringValue = String(value);
    this._fireChange("attributes", this);
    if (key == "class") {
      parseClasses(this._classes, stringValue);
    } else if (key == "style") {
      this._styles.setTo(stringValue);
    } else {
      this._attrs.set(key, stringValue);
    }
  }
  _removeAttribute(key) {
    this._fireChange("attributes", this);
    if (key == "class") {
      if (this._classes.size > 0) {
        this._classes.clear();
        return true;
      }
      return false;
    }
    if (key == "style") {
      if (!this._styles.isEmpty) {
        this._styles.clear();
        return true;
      }
      return false;
    }
    return this._attrs.delete(key);
  }
  _addClass(className) {
    this._fireChange("attributes", this);
    for (const name of toArray(className)) {
      this._classes.add(name);
    }
  }
  _removeClass(className) {
    this._fireChange("attributes", this);
    for (const name of toArray(className)) {
      this._classes.delete(name);
    }
  }
  _setStyle(property, value) {
    this._fireChange("attributes", this);
    if (typeof property != "string") {
      this._styles.set(property);
    } else {
      this._styles.set(property, value);
    }
  }
  _removeStyle(property) {
    this._fireChange("attributes", this);
    for (const name of toArray(property)) {
      this._styles.remove(name);
    }
  }
  _setCustomProperty(key, value) {
    this._customProperties.set(key, value);
  }
  _removeCustomProperty(key) {
    return this._customProperties.delete(key);
  }
};
var element_default = Element;
Element.prototype.is = function(type, name) {
  if (!name) {
    return type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "element" || type === "view:element");
  }
};
function parseAttributes(attrs) {
  const attrsMap = toMap(attrs);
  for (const [key, value] of attrsMap) {
    if (value === null) {
      attrsMap.delete(key);
    } else if (typeof value != "string") {
      attrsMap.set(key, String(value));
    }
  }
  return attrsMap;
}
function parseClasses(classesSet, classesString) {
  const classArray = classesString.split(/\s+/);
  classesSet.clear();
  classArray.forEach((name) => classesSet.add(name));
}
function normalize(document2, nodes) {
  if (typeof nodes == "string") {
    return [new text_default(document2, nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new text_default(document2, node);
    }
    if (node instanceof textproxy_default) {
      return new text_default(document2, node.data);
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/containerelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ContainerElement = class extends element_default {
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset;
  }
};
var containerelement_default = ContainerElement;
ContainerElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset() {
  const children = [...this.getChildren()];
  const lastChild = children[this.childCount - 1];
  if (lastChild && lastChild.is("element", "br")) {
    return this.childCount;
  }
  for (const child of children) {
    if (!child.is("uiElement")) {
      return null;
    }
  }
  return this.childCount;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/editableelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EditableElement = class extends ObservableMixin(containerelement_default) {
  constructor(document2, name, attributes, children) {
    super(document2, name, attributes, children);
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("placeholder", void 0);
    this.bind("isReadOnly").to(document2);
    this.bind("isFocused").to(document2, "isFocused", (isFocused) => isFocused && document2.selection.editableElement == this);
    this.listenTo(document2.selection, "change", () => {
      this.isFocused = document2.isFocused && document2.selection.editableElement == this;
    });
  }
  destroy() {
    this.stopListening();
  }
};
var editableelement_default = EditableElement;
EditableElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/rooteditableelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var rootNameSymbol = Symbol("rootName");
var RootEditableElement = class extends editableelement_default {
  constructor(document2, name) {
    super(document2, name);
    this.rootName = "main";
  }
  get rootName() {
    return this.getCustomProperty(rootNameSymbol);
  }
  set rootName(rootName) {
    this._setCustomProperty(rootNameSymbol, rootName);
  }
  set _name(name) {
    this.name = name;
  }
};
var rooteditableelement_default = RootEditableElement;
RootEditableElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rootElement" || type === "view:rootElement" || type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "rootElement" || type === "view:rootElement" || type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TreeWalker = class {
  constructor(options = {}) {
    if (!options.boundaries && !options.startPosition) {
      throw new ckeditorerror_default("view-tree-walker-no-start-position", null);
    }
    if (options.direction && options.direction != "forward" && options.direction != "backward") {
      throw new ckeditorerror_default("view-tree-walker-unknown-direction", options.startPosition, {direction: options.direction});
    }
    this.boundaries = options.boundaries || null;
    if (options.startPosition) {
      this._position = position_default._createAt(options.startPosition);
    } else {
      this._position = position_default._createAt(options.boundaries[options.direction == "backward" ? "end" : "start"]);
    }
    this.direction = options.direction || "forward";
    this.singleCharacters = !!options.singleCharacters;
    this.shallow = !!options.shallow;
    this.ignoreElementEnd = !!options.ignoreElementEnd;
    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  [Symbol.iterator]() {
    return this;
  }
  get position() {
    return this._position;
  }
  skip(skip) {
    let nextResult;
    let prevPosition;
    do {
      prevPosition = this.position;
      nextResult = this.next();
    } while (!nextResult.done && skip(nextResult.value));
    if (!nextResult.done) {
      this._position = prevPosition;
    }
  }
  next() {
    if (this.direction == "forward") {
      return this._next();
    } else {
      return this._previous();
    }
  }
  _next() {
    let position = this.position.clone();
    const previousPosition = this.position;
    const parent2 = position.parent;
    if (parent2.parent === null && position.offset === parent2.childCount) {
      return {done: true, value: void 0};
    }
    if (parent2 === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
      return {done: true, value: void 0};
    }
    let node;
    if (parent2 instanceof text_default) {
      if (position.isAtEnd) {
        this._position = position_default._createAfter(parent2);
        return this._next();
      }
      node = parent2.data[position.offset];
    } else {
      node = parent2.getChild(position.offset);
    }
    if (node instanceof element_default) {
      if (!this.shallow) {
        position = new position_default(node, 0);
      } else {
        if (this.boundaries && this.boundaries.end.isBefore(position)) {
          return {done: true, value: void 0};
        }
        position.offset++;
      }
      this._position = position;
      return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
    }
    if (node instanceof text_default) {
      if (this.singleCharacters) {
        position = new position_default(node, 0);
        this._position = position;
        return this._next();
      }
      let charactersCount = node.data.length;
      let item;
      if (node == this._boundaryEndParent) {
        charactersCount = this.boundaries.end.offset;
        item = new textproxy_default(node, 0, charactersCount);
        position = position_default._createAfter(item);
      } else {
        item = new textproxy_default(node, 0, node.data.length);
        position.offset++;
      }
      this._position = position;
      return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    if (typeof node == "string") {
      let textLength;
      if (this.singleCharacters) {
        textLength = 1;
      } else {
        const endOffset = parent2 === this._boundaryEndParent ? this.boundaries.end.offset : parent2.data.length;
        textLength = endOffset - position.offset;
      }
      const textProxy = new textproxy_default(parent2, position.offset, textLength);
      position.offset += textLength;
      this._position = position;
      return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
    }
    position = position_default._createAfter(parent2);
    this._position = position;
    if (this.ignoreElementEnd) {
      return this._next();
    }
    return this._formatReturnValue("elementEnd", parent2, previousPosition, position);
  }
  _previous() {
    let position = this.position.clone();
    const previousPosition = this.position;
    const parent2 = position.parent;
    if (parent2.parent === null && position.offset === 0) {
      return {done: true, value: void 0};
    }
    if (parent2 == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
      return {done: true, value: void 0};
    }
    let node;
    if (parent2 instanceof text_default) {
      if (position.isAtStart) {
        this._position = position_default._createBefore(parent2);
        return this._previous();
      }
      node = parent2.data[position.offset - 1];
    } else {
      node = parent2.getChild(position.offset - 1);
    }
    if (node instanceof element_default) {
      if (this.shallow) {
        position.offset--;
        this._position = position;
        return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
      }
      position = new position_default(node, node.childCount);
      this._position = position;
      if (this.ignoreElementEnd) {
        return this._previous();
      }
      return this._formatReturnValue("elementEnd", node, previousPosition, position);
    }
    if (node instanceof text_default) {
      if (this.singleCharacters) {
        position = new position_default(node, node.data.length);
        this._position = position;
        return this._previous();
      }
      let charactersCount = node.data.length;
      let item;
      if (node == this._boundaryStartParent) {
        const offset = this.boundaries.start.offset;
        item = new textproxy_default(node, offset, node.data.length - offset);
        charactersCount = item.data.length;
        position = position_default._createBefore(item);
      } else {
        item = new textproxy_default(node, 0, node.data.length);
        position.offset--;
      }
      this._position = position;
      return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    if (typeof node == "string") {
      let textLength;
      if (!this.singleCharacters) {
        const startOffset = parent2 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
        textLength = position.offset - startOffset;
      } else {
        textLength = 1;
      }
      position.offset -= textLength;
      const textProxy = new textproxy_default(parent2, position.offset, textLength);
      this._position = position;
      return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
    }
    position = position_default._createBefore(parent2);
    this._position = position;
    return this._formatReturnValue("elementStart", parent2, previousPosition, position, 1);
  }
  _formatReturnValue(type, item, previousPosition, nextPosition, length) {
    if (item instanceof textproxy_default) {
      if (item.offsetInText + item.data.length == item.textNode.data.length) {
        if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
          nextPosition = position_default._createAfter(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = position_default._createAfter(item.textNode);
        }
      }
      if (item.offsetInText === 0) {
        if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
          nextPosition = position_default._createBefore(item.textNode);
          this._position = nextPosition;
        } else {
          previousPosition = position_default._createBefore(item.textNode);
        }
      }
    }
    return {
      done: false,
      value: {
        type,
        item,
        previousPosition,
        nextPosition,
        length
      }
    };
  }
};
var treewalker_default = TreeWalker;

// node_modules/@ckeditor/ckeditor5-engine/src/view/position.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Position = class extends typecheckable_default {
  constructor(parent2, offset) {
    super();
    this.parent = parent2;
    this.offset = offset;
  }
  get nodeAfter() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset) || null;
  }
  get nodeBefore() {
    if (this.parent.is("$text")) {
      return null;
    }
    return this.parent.getChild(this.offset - 1) || null;
  }
  get isAtStart() {
    return this.offset === 0;
  }
  get isAtEnd() {
    const endOffset = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
    return this.offset === endOffset;
  }
  get root() {
    return this.parent.root;
  }
  get editableElement() {
    let editable = this.parent;
    while (!(editable instanceof editableelement_default)) {
      if (editable.parent) {
        editable = editable.parent;
      } else {
        return null;
      }
    }
    return editable;
  }
  getShiftedBy(shift) {
    const shifted = Position._createAt(this);
    const offset = shifted.offset + shift;
    shifted.offset = offset < 0 ? 0 : offset;
    return shifted;
  }
  getLastMatchingPosition(skip, options = {}) {
    options.startPosition = this;
    const treeWalker = new treewalker_default(options);
    treeWalker.skip(skip);
    return treeWalker.position;
  }
  getAncestors() {
    if (this.parent.is("documentFragment")) {
      return [this.parent];
    } else {
      return this.parent.getAncestors({includeSelf: true});
    }
  }
  getCommonAncestor(position) {
    const ancestorsA = this.getAncestors();
    const ancestorsB = position.getAncestors();
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  isEqual(otherPosition) {
    return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
  }
  isBefore(otherPosition) {
    return this.compareWith(otherPosition) == "before";
  }
  isAfter(otherPosition) {
    return this.compareWith(otherPosition) == "after";
  }
  compareWith(otherPosition) {
    if (this.root !== otherPosition.root) {
      return "different";
    }
    if (this.isEqual(otherPosition)) {
      return "same";
    }
    const thisPath = this.parent.is("node") ? this.parent.getPath() : [];
    const otherPath = otherPosition.parent.is("node") ? otherPosition.parent.getPath() : [];
    thisPath.push(this.offset);
    otherPath.push(otherPosition.offset);
    const result = compareArrays(thisPath, otherPath);
    switch (result) {
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return thisPath[result] < otherPath[result] ? "before" : "after";
    }
  }
  getWalker(options = {}) {
    options.startPosition = this;
    return new treewalker_default(options);
  }
  clone() {
    return new Position(this.parent, this.offset);
  }
  static _createAt(itemOrPosition, offset) {
    if (itemOrPosition instanceof Position) {
      return new this(itemOrPosition.parent, itemOrPosition.offset);
    } else {
      const node = itemOrPosition;
      if (offset == "end") {
        offset = node.is("$text") ? node.data.length : node.childCount;
      } else if (offset == "before") {
        return this._createBefore(node);
      } else if (offset == "after") {
        return this._createAfter(node);
      } else if (offset !== 0 && !offset) {
        throw new ckeditorerror_default("view-createpositionat-offset-required", node);
      }
      return new Position(node, offset);
    }
  }
  static _createAfter(item) {
    if (item.is("$textProxy")) {
      return new Position(item.textNode, item.offsetInText + item.data.length);
    }
    if (!item.parent) {
      throw new ckeditorerror_default("view-position-after-root", item, {root: item});
    }
    return new Position(item.parent, item.index + 1);
  }
  static _createBefore(item) {
    if (item.is("$textProxy")) {
      return new Position(item.textNode, item.offsetInText);
    }
    if (!item.parent) {
      throw new ckeditorerror_default("view-position-before-root", item, {root: item});
    }
    return new Position(item.parent, item.index);
  }
};
var position_default = Position;
Position.prototype.is = function(type) {
  return type === "position" || type === "view:position";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/range.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Range = class extends typecheckable_default {
  constructor(start, end = null) {
    super();
    this.start = start.clone();
    this.end = end ? end.clone() : start.clone();
  }
  *[Symbol.iterator]() {
    yield* new treewalker_default({boundaries: this, ignoreElementEnd: true});
  }
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  get isFlat() {
    return this.start.parent === this.end.parent;
  }
  get root() {
    return this.start.root;
  }
  getEnlarged() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip, {direction: "backward"});
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip);
    if (start.parent.is("$text") && start.isAtStart) {
      start = position_default._createBefore(start.parent);
    }
    if (end.parent.is("$text") && end.isAtEnd) {
      end = position_default._createAfter(end.parent);
    }
    return new Range(start, end);
  }
  getTrimmed() {
    let start = this.start.getLastMatchingPosition(enlargeTrimSkip);
    if (start.isAfter(this.end) || start.isEqual(this.end)) {
      return new Range(start, start);
    }
    let end = this.end.getLastMatchingPosition(enlargeTrimSkip, {direction: "backward"});
    const nodeAfterStart = start.nodeAfter;
    const nodeBeforeEnd = end.nodeBefore;
    if (nodeAfterStart && nodeAfterStart.is("$text")) {
      start = new position_default(nodeAfterStart, 0);
    }
    if (nodeBeforeEnd && nodeBeforeEnd.is("$text")) {
      end = new position_default(nodeBeforeEnd, nodeBeforeEnd.data.length);
    }
    return new Range(start, end);
  }
  isEqual(otherRange) {
    return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
  }
  containsPosition(position) {
    return position.isAfter(this.start) && position.isBefore(this.end);
  }
  containsRange(otherRange, loose = false) {
    if (otherRange.isCollapsed) {
      loose = false;
    }
    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
    return containsStart && containsEnd;
  }
  getDifference(otherRange) {
    const ranges = [];
    if (this.isIntersecting(otherRange)) {
      if (this.containsPosition(otherRange.start)) {
        ranges.push(new Range(this.start, otherRange.start));
      }
      if (this.containsPosition(otherRange.end)) {
        ranges.push(new Range(otherRange.end, this.end));
      }
    } else {
      ranges.push(this.clone());
    }
    return ranges;
  }
  getIntersection(otherRange) {
    if (this.isIntersecting(otherRange)) {
      let commonRangeStart = this.start;
      let commonRangeEnd = this.end;
      if (this.containsPosition(otherRange.start)) {
        commonRangeStart = otherRange.start;
      }
      if (this.containsPosition(otherRange.end)) {
        commonRangeEnd = otherRange.end;
      }
      return new Range(commonRangeStart, commonRangeEnd);
    }
    return null;
  }
  getWalker(options = {}) {
    options.boundaries = this;
    return new treewalker_default(options);
  }
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  getContainedElement() {
    if (this.isCollapsed) {
      return null;
    }
    let nodeAfterStart = this.start.nodeAfter;
    let nodeBeforeEnd = this.end.nodeBefore;
    if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
      nodeAfterStart = this.start.parent.nextSibling;
    }
    if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
      nodeBeforeEnd = this.end.parent.previousSibling;
    }
    if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
      return nodeAfterStart;
    }
    return null;
  }
  clone() {
    return new Range(this.start, this.end);
  }
  *getItems(options = {}) {
    options.boundaries = this;
    options.ignoreElementEnd = true;
    const treeWalker = new treewalker_default(options);
    for (const value of treeWalker) {
      yield value.item;
    }
  }
  *getPositions(options = {}) {
    options.boundaries = this;
    const treeWalker = new treewalker_default(options);
    yield treeWalker.position;
    for (const value of treeWalker) {
      yield value.nextPosition;
    }
  }
  isIntersecting(otherRange) {
    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
  }
  static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
    return new this(new position_default(startElement, startOffset), new position_default(endElement, endOffset));
  }
  static _createFromPositionAndShift(position, shift) {
    const start = position;
    const end = position.getShiftedBy(shift);
    return shift > 0 ? new this(start, end) : new this(end, start);
  }
  static _createIn(element) {
    return this._createFromParentsAndOffsets(element, 0, element, element.childCount);
  }
  static _createOn(item) {
    const size = item.is("$textProxy") ? item.offsetSize : 1;
    return this._createFromPositionAndShift(position_default._createBefore(item), size);
  }
};
var range_default = Range;
Range.prototype.is = function(type) {
  return type === "range" || type === "view:range";
};
function enlargeTrimSkip(value) {
  if (value.item.is("attributeElement") || value.item.is("uiElement")) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/selection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Selection = class extends EmitterMixin(typecheckable_default) {
  constructor(...args) {
    super();
    this._ranges = [];
    this._lastRangeBackward = false;
    this._isFake = false;
    this._fakeSelectionLabel = "";
    if (args.length) {
      this.setTo(...args);
    }
  }
  get isFake() {
    return this._isFake;
  }
  get fakeSelectionLabel() {
    return this._fakeSelectionLabel;
  }
  get anchor() {
    if (!this._ranges.length) {
      return null;
    }
    const range = this._ranges[this._ranges.length - 1];
    const anchor = this._lastRangeBackward ? range.end : range.start;
    return anchor.clone();
  }
  get focus() {
    if (!this._ranges.length) {
      return null;
    }
    const range = this._ranges[this._ranges.length - 1];
    const focus = this._lastRangeBackward ? range.start : range.end;
    return focus.clone();
  }
  get isCollapsed() {
    return this.rangeCount === 1 && this._ranges[0].isCollapsed;
  }
  get rangeCount() {
    return this._ranges.length;
  }
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  get editableElement() {
    if (this.anchor) {
      return this.anchor.editableElement;
    }
    return null;
  }
  *getRanges() {
    for (const range of this._ranges) {
      yield range.clone();
    }
  }
  getFirstRange() {
    let first2 = null;
    for (const range of this._ranges) {
      if (!first2 || range.start.isBefore(first2.start)) {
        first2 = range;
      }
    }
    return first2 ? first2.clone() : null;
  }
  getLastRange() {
    let last2 = null;
    for (const range of this._ranges) {
      if (!last2 || range.end.isAfter(last2.end)) {
        last2 = range;
      }
    }
    return last2 ? last2.clone() : null;
  }
  getFirstPosition() {
    const firstRange = this.getFirstRange();
    return firstRange ? firstRange.start.clone() : null;
  }
  getLastPosition() {
    const lastRange = this.getLastRange();
    return lastRange ? lastRange.end.clone() : null;
  }
  isEqual(otherSelection) {
    if (this.isFake != otherSelection.isFake) {
      return false;
    }
    if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
      return false;
    }
    if (this.rangeCount != otherSelection.rangeCount) {
      return false;
    } else if (this.rangeCount === 0) {
      return true;
    }
    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
      return false;
    }
    for (const thisRange of this._ranges) {
      let found = false;
      for (const otherRange of otherSelection._ranges) {
        if (thisRange.isEqual(otherRange)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  isSimilar(otherSelection) {
    if (this.isBackward != otherSelection.isBackward) {
      return false;
    }
    const numOfRangesA = count(this.getRanges());
    const numOfRangesB = count(otherSelection.getRanges());
    if (numOfRangesA != numOfRangesB) {
      return false;
    }
    if (numOfRangesA == 0) {
      return true;
    }
    for (let rangeA of this.getRanges()) {
      rangeA = rangeA.getTrimmed();
      let found = false;
      for (let rangeB of otherSelection.getRanges()) {
        rangeB = rangeB.getTrimmed();
        if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  getSelectedElement() {
    if (this.rangeCount !== 1) {
      return null;
    }
    return this.getFirstRange().getContainedElement();
  }
  setTo(...args) {
    let [selectable, placeOrOffset, options] = args;
    if (typeof placeOrOffset == "object") {
      options = placeOrOffset;
      placeOrOffset = void 0;
    }
    if (selectable === null) {
      this._setRanges([]);
      this._setFakeOptions(options);
    } else if (selectable instanceof Selection || selectable instanceof documentselection_default) {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
      this._setFakeOptions({fake: selectable.isFake, label: selectable.fakeSelectionLabel});
    } else if (selectable instanceof range_default) {
      this._setRanges([selectable], options && options.backward);
      this._setFakeOptions(options);
    } else if (selectable instanceof position_default) {
      this._setRanges([new range_default(selectable)]);
      this._setFakeOptions(options);
    } else if (selectable instanceof node_default) {
      const backward = !!options && !!options.backward;
      let range;
      if (placeOrOffset === void 0) {
        throw new ckeditorerror_default("view-selection-setto-required-second-parameter", this);
      } else if (placeOrOffset == "in") {
        range = range_default._createIn(selectable);
      } else if (placeOrOffset == "on") {
        range = range_default._createOn(selectable);
      } else {
        range = new range_default(position_default._createAt(selectable, placeOrOffset));
      }
      this._setRanges([range], backward);
      this._setFakeOptions(options);
    } else if (isIterable(selectable)) {
      this._setRanges(selectable, options && options.backward);
      this._setFakeOptions(options);
    } else {
      throw new ckeditorerror_default("view-selection-setto-not-selectable", this);
    }
    this.fire("change");
  }
  setFocus(itemOrPosition, offset) {
    if (this.anchor === null) {
      throw new ckeditorerror_default("view-selection-setfocus-no-ranges", this);
    }
    const newFocus = position_default._createAt(itemOrPosition, offset);
    if (newFocus.compareWith(this.focus) == "same") {
      return;
    }
    const anchor = this.anchor;
    this._ranges.pop();
    if (newFocus.compareWith(anchor) == "before") {
      this._addRange(new range_default(newFocus, anchor), true);
    } else {
      this._addRange(new range_default(anchor, newFocus));
    }
    this.fire("change");
  }
  _setRanges(newRanges, isLastBackward = false) {
    newRanges = Array.from(newRanges);
    this._ranges = [];
    for (const range of newRanges) {
      this._addRange(range);
    }
    this._lastRangeBackward = !!isLastBackward;
  }
  _setFakeOptions(options = {}) {
    this._isFake = !!options.fake;
    this._fakeSelectionLabel = options.fake ? options.label || "" : "";
  }
  _addRange(range, isBackward = false) {
    if (!(range instanceof range_default)) {
      throw new ckeditorerror_default("view-selection-add-range-not-range", this);
    }
    this._pushRange(range);
    this._lastRangeBackward = !!isBackward;
  }
  _pushRange(range) {
    for (const storedRange of this._ranges) {
      if (range.isIntersecting(storedRange)) {
        throw new ckeditorerror_default("view-selection-range-intersects", this, {addedRange: range, intersectingRange: storedRange});
      }
    }
    this._ranges.push(new range_default(range.start, range.end));
  }
};
var selection_default = Selection;
Selection.prototype.is = function(type) {
  return type === "selection" || type === "view:selection";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/documentselection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DocumentSelection = class extends EmitterMixin(typecheckable_default) {
  constructor(...args) {
    super();
    this._selection = new selection_default();
    this._selection.delegate("change").to(this);
    if (args.length) {
      this._selection.setTo(...args);
    }
  }
  get isFake() {
    return this._selection.isFake;
  }
  get fakeSelectionLabel() {
    return this._selection.fakeSelectionLabel;
  }
  get anchor() {
    return this._selection.anchor;
  }
  get focus() {
    return this._selection.focus;
  }
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  get rangeCount() {
    return this._selection.rangeCount;
  }
  get isBackward() {
    return this._selection.isBackward;
  }
  get editableElement() {
    return this._selection.editableElement;
  }
  get _ranges() {
    return this._selection._ranges;
  }
  *getRanges() {
    yield* this._selection.getRanges();
  }
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  getLastRange() {
    return this._selection.getLastRange();
  }
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  isEqual(otherSelection) {
    return this._selection.isEqual(otherSelection);
  }
  isSimilar(otherSelection) {
    return this._selection.isSimilar(otherSelection);
  }
  _setTo(...args) {
    this._selection.setTo(...args);
  }
  _setFocus(itemOrPosition, offset) {
    this._selection.setFocus(itemOrPosition, offset);
  }
};
var documentselection_default = DocumentSelection;
DocumentSelection.prototype.is = function(type) {
  return type === "selection" || type == "documentSelection" || type == "view:selection" || type == "view:documentSelection";
};

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/bubblingeventinfo.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BubblingEventInfo = class extends eventinfo_default {
  constructor(source, name, startRange) {
    super(source, name);
    this.startRange = startRange;
    this._eventPhase = "none";
    this._currentTarget = null;
  }
  get eventPhase() {
    return this._eventPhase;
  }
  get currentTarget() {
    return this._currentTarget;
  }
};
var bubblingeventinfo_default = BubblingEventInfo;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/bubblingemittermixin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var contextsSymbol = Symbol("bubbling contexts");
function BubblingEmitterMixin(base) {
  class Mixin extends base {
    fire(eventOrInfo, ...eventArgs) {
      try {
        const eventInfo = eventOrInfo instanceof eventinfo_default ? eventOrInfo : new eventinfo_default(this, eventOrInfo);
        const eventContexts = getBubblingContexts(this);
        if (!eventContexts.size) {
          return;
        }
        updateEventInfo(eventInfo, "capturing", this);
        if (fireListenerFor(eventContexts, "$capture", eventInfo, ...eventArgs)) {
          return eventInfo.return;
        }
        const startRange = eventInfo.startRange || this.selection.getFirstRange();
        const selectedElement = startRange ? startRange.getContainedElement() : null;
        const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;
        let node = selectedElement || getDeeperRangeParent(startRange);
        updateEventInfo(eventInfo, "atTarget", node);
        if (!isCustomContext) {
          if (fireListenerFor(eventContexts, "$text", eventInfo, ...eventArgs)) {
            return eventInfo.return;
          }
          updateEventInfo(eventInfo, "bubbling", node);
        }
        while (node) {
          if (node.is("rootElement")) {
            if (fireListenerFor(eventContexts, "$root", eventInfo, ...eventArgs)) {
              return eventInfo.return;
            }
          } else if (node.is("element")) {
            if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {
              return eventInfo.return;
            }
          }
          if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {
            return eventInfo.return;
          }
          node = node.parent;
          updateEventInfo(eventInfo, "bubbling", node);
        }
        updateEventInfo(eventInfo, "bubbling", this);
        fireListenerFor(eventContexts, "$document", eventInfo, ...eventArgs);
        return eventInfo.return;
      } catch (err) {
        /* istanbul ignore next -- @preserve */
        ckeditorerror_default.rethrowUnexpectedError(err, this);
      }
    }
    _addEventListener(event, callback, options) {
      const contexts = toArray(options.context || "$document");
      const eventContexts = getBubblingContexts(this);
      for (const context of contexts) {
        let emitter = eventContexts.get(context);
        if (!emitter) {
          emitter = new (EmitterMixin())();
          eventContexts.set(context, emitter);
        }
        this.listenTo(emitter, event, callback, options);
      }
    }
    _removeEventListener(event, callback) {
      const eventContexts = getBubblingContexts(this);
      for (const emitter of eventContexts.values()) {
        this.stopListening(emitter, event, callback);
      }
    }
  }
  return Mixin;
}
{
  const mixin = BubblingEmitterMixin(Object);
  ["fire", "_addEventListener", "_removeEventListener"].forEach((key) => {
    BubblingEmitterMixin[key] = mixin.prototype[key];
  });
}
function updateEventInfo(eventInfo, eventPhase, currentTarget) {
  if (eventInfo instanceof bubblingeventinfo_default) {
    eventInfo._eventPhase = eventPhase;
    eventInfo._currentTarget = currentTarget;
  }
}
function fireListenerFor(eventContexts, context, eventInfo, ...eventArgs) {
  const emitter = typeof context == "string" ? eventContexts.get(context) : getCustomContext(eventContexts, context);
  if (!emitter) {
    return false;
  }
  emitter.fire(eventInfo, ...eventArgs);
  return eventInfo.stop.called;
}
function getCustomContext(eventContexts, node) {
  for (const [context, emitter] of eventContexts) {
    if (typeof context == "function" && context(node)) {
      return emitter;
    }
  }
  return null;
}
function getBubblingContexts(source) {
  if (!source[contextsSymbol]) {
    source[contextsSymbol] = new Map();
  }
  return source[contextsSymbol];
}
function getDeeperRangeParent(range) {
  if (!range) {
    return null;
  }
  const startParent = range.start.parent;
  const endParent = range.end.parent;
  const startPath = startParent.getPath();
  const endPath = endParent.getPath();
  return startPath.length > endPath.length ? startParent : endParent;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/document.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Document = class extends BubblingEmitterMixin(ObservableMixin()) {
  constructor(stylesProcessor) {
    super();
    this._postFixers = new Set();
    this.selection = new documentselection_default();
    this.roots = new collection_default({idProperty: "rootName"});
    this.stylesProcessor = stylesProcessor;
    this.set("isReadOnly", false);
    this.set("isFocused", false);
    this.set("isSelecting", false);
    this.set("isComposing", false);
  }
  getRoot(name = "main") {
    return this.roots.get(name);
  }
  registerPostFixer(postFixer) {
    this._postFixers.add(postFixer);
  }
  destroy() {
    this.roots.map((root2) => root2.destroy());
    this.stopListening();
  }
  _callPostFixers(writer) {
    let wasFixed = false;
    do {
      for (const callback of this._postFixers) {
        wasFixed = callback(writer);
        if (wasFixed) {
          break;
        }
      }
    } while (wasFixed);
  }
};
var document_default = Document;

// node_modules/@ckeditor/ckeditor5-engine/src/view/attributeelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DEFAULT_PRIORITY = 10;
var AttributeElement = class extends element_default {
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this._priority = DEFAULT_PRIORITY;
    this._id = null;
    this._clonesGroup = null;
    this.getFillerOffset = getFillerOffset2;
  }
  get priority() {
    return this._priority;
  }
  get id() {
    return this._id;
  }
  getElementsWithSameId() {
    if (this.id === null) {
      throw new ckeditorerror_default("attribute-element-get-elements-with-same-id-no-id", this);
    }
    return new Set(this._clonesGroup);
  }
  isSimilar(otherElement) {
    if (this.id !== null || otherElement.id !== null) {
      return this.id === otherElement.id;
    }
    return super.isSimilar(otherElement) && this.priority == otherElement.priority;
  }
  _clone(deep = false) {
    const cloned = super._clone(deep);
    cloned._priority = this._priority;
    cloned._id = this._id;
    return cloned;
  }
};
var attributeelement_default = AttributeElement;
AttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY;
AttributeElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "attributeElement" || type === "view:attributeElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "attributeElement" || type === "view:attributeElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset2() {
  if (nonUiChildrenCount(this)) {
    return null;
  }
  let element = this.parent;
  while (element && element.is("attributeElement")) {
    if (nonUiChildrenCount(element) > 1) {
      return null;
    }
    element = element.parent;
  }
  if (!element || nonUiChildrenCount(element) > 1) {
    return null;
  }
  return this.childCount;
}
function nonUiChildrenCount(element) {
  return Array.from(element.getChildren()).filter((element2) => !element2.is("uiElement")).length;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/emptyelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EmptyElement = class extends element_default {
  constructor(document2, name, attributes, children) {
    super(document2, name, attributes, children);
    this.getFillerOffset = getFillerOffset3;
  }
  _insertChild(index, items) {
    if (items && (items instanceof node_default || Array.from(items).length > 0)) {
      throw new ckeditorerror_default("view-emptyelement-cannot-add", [this, items]);
    }
    return 0;
  }
};
var emptyelement_default = EmptyElement;
EmptyElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "emptyElement" || type === "view:emptyElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "emptyElement" || type === "view:emptyElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset3() {
  return null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/uielement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var UIElement = class extends element_default {
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset4;
  }
  _insertChild(index, items) {
    if (items && (items instanceof node_default || Array.from(items).length > 0)) {
      throw new ckeditorerror_default("view-uielement-cannot-add", [this, items]);
    }
    return 0;
  }
  render(domDocument, domConverter) {
    return this.toDomElement(domDocument);
  }
  toDomElement(domDocument) {
    const domElement = domDocument.createElement(this.name);
    for (const key of this.getAttributeKeys()) {
      domElement.setAttribute(key, this.getAttribute(key));
    }
    return domElement;
  }
};
var uielement_default = UIElement;
UIElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "uiElement" || type === "view:uiElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "uiElement" || type === "view:uiElement" || type === "element" || type === "view:element");
  }
};
function injectUiElementHandling(view) {
  view.document.on("arrowKey", (evt, data) => jumpOverUiElement(evt, data, view.domConverter), {priority: "low"});
}
function getFillerOffset4() {
  return null;
}
function jumpOverUiElement(evt, data, domConverter) {
  if (data.keyCode == keyCodes.arrowright) {
    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
    const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;
    if (domSelectionCollapsed || data.shiftKey) {
      const domParent = domSelection.focusNode;
      const domOffset = domSelection.focusOffset;
      const viewPosition = domConverter.domPositionToView(domParent, domOffset);
      if (viewPosition === null) {
        return;
      }
      let jumpedOverAnyUiElement = false;
      const nextViewPosition = viewPosition.getLastMatchingPosition((value) => {
        if (value.item.is("uiElement")) {
          jumpedOverAnyUiElement = true;
        }
        if (value.item.is("uiElement") || value.item.is("attributeElement")) {
          return true;
        }
        return false;
      });
      if (jumpedOverAnyUiElement) {
        const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);
        if (domSelectionCollapsed) {
          domSelection.collapse(newDomPosition.parent, newDomPosition.offset);
        } else {
          domSelection.extend(newDomPosition.parent, newDomPosition.offset);
        }
      }
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/rawelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var RawElement = class extends element_default {
  constructor(document2, name, attrs, children) {
    super(document2, name, attrs, children);
    this.getFillerOffset = getFillerOffset5;
  }
  _insertChild(index, items) {
    if (items && (items instanceof node_default || Array.from(items).length > 0)) {
      throw new ckeditorerror_default("view-rawelement-cannot-add", [this, items]);
    }
    return 0;
  }
  render(domElement, domConverter) {
  }
};
var rawelement_default = RawElement;
RawElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rawElement" || type === "view:rawElement" || type === this.name || type === "view:" + this.name || type === "element" || type === "view:element" || type === "node" || type === "view:node";
  } else {
    return name === this.name && (type === "rawElement" || type === "view:rawElement" || type === "element" || type === "view:element");
  }
};
function getFillerOffset5() {
  return null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/documentfragment.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DocumentFragment = class extends EmitterMixin(typecheckable_default) {
  constructor(document2, children) {
    super();
    this._children = [];
    this._customProperties = new Map();
    this.document = document2;
    if (children) {
      this._insertChild(0, children);
    }
  }
  [Symbol.iterator]() {
    return this._children[Symbol.iterator]();
  }
  get childCount() {
    return this._children.length;
  }
  get isEmpty() {
    return this.childCount === 0;
  }
  get root() {
    return this;
  }
  get parent() {
    return null;
  }
  get name() {
    return void 0;
  }
  getCustomProperty(key) {
    return this._customProperties.get(key);
  }
  *getCustomProperties() {
    yield* this._customProperties.entries();
  }
  _appendChild(items) {
    return this._insertChild(this.childCount, items);
  }
  getChild(index) {
    return this._children[index];
  }
  getChildIndex(node) {
    return this._children.indexOf(node);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  _insertChild(index, items) {
    this._fireChange("children", this);
    let count2 = 0;
    const nodes = normalize2(this.document, items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
      this._children.splice(index, 0, node);
      index++;
      count2++;
    }
    return count2;
  }
  _removeChildren(index, howMany = 1) {
    this._fireChange("children", this);
    for (let i = index; i < index + howMany; i++) {
      this._children[i].parent = null;
    }
    return this._children.splice(index, howMany);
  }
  _fireChange(type, node) {
    this.fire("change:" + type, node);
  }
  _setCustomProperty(key, value) {
    this._customProperties.set(key, value);
  }
  _removeCustomProperty(key) {
    return this._customProperties.delete(key);
  }
};
var documentfragment_default = DocumentFragment;
DocumentFragment.prototype.is = function(type) {
  return type === "documentFragment" || type === "view:documentFragment";
};
function normalize2(document2, nodes) {
  if (typeof nodes == "string") {
    return [new text_default(document2, nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new text_default(document2, node);
    }
    if (node instanceof textproxy_default) {
      return new text_default(document2, node.data);
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DowncastWriter = class {
  constructor(document2) {
    this._cloneGroups = new Map();
    this._slotFactory = null;
    this.document = document2;
  }
  setSelection(...args) {
    this.document.selection._setTo(...args);
  }
  setSelectionFocus(itemOrPosition, offset) {
    this.document.selection._setFocus(itemOrPosition, offset);
  }
  createDocumentFragment(children) {
    return new documentfragment_default(this.document, children);
  }
  createText(data) {
    return new text_default(this.document, data);
  }
  createAttributeElement(name, attributes, options = {}) {
    const attributeElement = new attributeelement_default(this.document, name, attributes);
    if (typeof options.priority === "number") {
      attributeElement._priority = options.priority;
    }
    if (options.id) {
      attributeElement._id = options.id;
    }
    if (options.renderUnsafeAttributes) {
      attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return attributeElement;
  }
  createContainerElement(name, attributes, childrenOrOptions = {}, options = {}) {
    let children = null;
    if (isPlainObject_default(childrenOrOptions)) {
      options = childrenOrOptions;
    } else {
      children = childrenOrOptions;
    }
    const containerElement = new containerelement_default(this.document, name, attributes, children);
    if (options.renderUnsafeAttributes) {
      containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return containerElement;
  }
  createEditableElement(name, attributes, options = {}) {
    const editableElement = new editableelement_default(this.document, name, attributes);
    if (options.renderUnsafeAttributes) {
      editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return editableElement;
  }
  createEmptyElement(name, attributes, options = {}) {
    const emptyElement = new emptyelement_default(this.document, name, attributes);
    if (options.renderUnsafeAttributes) {
      emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return emptyElement;
  }
  createUIElement(name, attributes, renderFunction) {
    const uiElement = new uielement_default(this.document, name, attributes);
    if (renderFunction) {
      uiElement.render = renderFunction;
    }
    return uiElement;
  }
  createRawElement(name, attributes, renderFunction, options = {}) {
    const rawElement = new rawelement_default(this.document, name, attributes);
    if (renderFunction) {
      rawElement.render = renderFunction;
    }
    if (options.renderUnsafeAttributes) {
      rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
    }
    return rawElement;
  }
  setAttribute(key, value, element) {
    element._setAttribute(key, value);
  }
  removeAttribute(key, element) {
    element._removeAttribute(key);
  }
  addClass(className, element) {
    element._addClass(className);
  }
  removeClass(className, element) {
    element._removeClass(className);
  }
  setStyle(property, value, element) {
    if (isPlainObject_default(property) && element === void 0) {
      value._setStyle(property);
    } else {
      element._setStyle(property, value);
    }
  }
  removeStyle(property, element) {
    element._removeStyle(property);
  }
  setCustomProperty(key, value, element) {
    element._setCustomProperty(key, value);
  }
  removeCustomProperty(key, element) {
    return element._removeCustomProperty(key);
  }
  breakAttributes(positionOrRange) {
    if (positionOrRange instanceof position_default) {
      return this._breakAttributes(positionOrRange);
    } else {
      return this._breakAttributesRange(positionOrRange);
    }
  }
  breakContainer(position) {
    const element = position.parent;
    if (!element.is("containerElement")) {
      throw new ckeditorerror_default("view-writer-break-non-container-element", this.document);
    }
    if (!element.parent) {
      throw new ckeditorerror_default("view-writer-break-root", this.document);
    }
    if (position.isAtStart) {
      return position_default._createBefore(element);
    } else if (!position.isAtEnd) {
      const newElement = element._clone(false);
      this.insert(position_default._createAfter(element), newElement);
      const sourceRange = new range_default(position, position_default._createAt(element, "end"));
      const targetPosition = new position_default(newElement, 0);
      this.move(sourceRange, targetPosition);
    }
    return position_default._createAfter(element);
  }
  mergeAttributes(position) {
    const positionOffset = position.offset;
    const positionParent = position.parent;
    if (positionParent.is("$text")) {
      return position;
    }
    if (positionParent.is("attributeElement") && positionParent.childCount === 0) {
      const parent2 = positionParent.parent;
      const offset = positionParent.index;
      positionParent._remove();
      this._removeFromClonedElementsGroup(positionParent);
      return this.mergeAttributes(new position_default(parent2, offset));
    }
    const nodeBefore = positionParent.getChild(positionOffset - 1);
    const nodeAfter = positionParent.getChild(positionOffset);
    if (!nodeBefore || !nodeAfter) {
      return position;
    }
    if (nodeBefore.is("$text") && nodeAfter.is("$text")) {
      return mergeTextNodes(nodeBefore, nodeAfter);
    } else if (nodeBefore.is("attributeElement") && nodeAfter.is("attributeElement") && nodeBefore.isSimilar(nodeAfter)) {
      const count2 = nodeBefore.childCount;
      nodeBefore._appendChild(nodeAfter.getChildren());
      nodeAfter._remove();
      this._removeFromClonedElementsGroup(nodeAfter);
      return this.mergeAttributes(new position_default(nodeBefore, count2));
    }
    return position;
  }
  mergeContainers(position) {
    const prev = position.nodeBefore;
    const next = position.nodeAfter;
    if (!prev || !next || !prev.is("containerElement") || !next.is("containerElement")) {
      throw new ckeditorerror_default("view-writer-merge-containers-invalid-position", this.document);
    }
    const lastChild = prev.getChild(prev.childCount - 1);
    const newPosition = lastChild instanceof text_default ? position_default._createAt(lastChild, "end") : position_default._createAt(prev, "end");
    this.move(range_default._createIn(next), position_default._createAt(prev, "end"));
    this.remove(range_default._createOn(next));
    return newPosition;
  }
  insert(position, nodes) {
    nodes = isIterable(nodes) ? [...nodes] : [nodes];
    validateNodesToInsert(nodes, this.document);
    const nodeGroups = nodes.reduce((groups, node) => {
      const lastGroup = groups[groups.length - 1];
      const breakAttributes = !node.is("uiElement");
      if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {
        groups.push({
          breakAttributes,
          nodes: [node]
        });
      } else {
        lastGroup.nodes.push(node);
      }
      return groups;
    }, []);
    let start = null;
    let end = position;
    for (const {nodes: nodes2, breakAttributes} of nodeGroups) {
      const range = this._insertNodes(end, nodes2, breakAttributes);
      if (!start) {
        start = range.start;
      }
      end = range.end;
    }
    if (!start) {
      return new range_default(position);
    }
    return new range_default(start, end);
  }
  remove(rangeOrItem) {
    const range = rangeOrItem instanceof range_default ? rangeOrItem : range_default._createOn(rangeOrItem);
    validateRangeContainer(range, this.document);
    if (range.isCollapsed) {
      return new documentfragment_default(this.document);
    }
    const {start: breakStart, end: breakEnd} = this._breakAttributesRange(range, true);
    const parentContainer = breakStart.parent;
    const count2 = breakEnd.offset - breakStart.offset;
    const removed = parentContainer._removeChildren(breakStart.offset, count2);
    for (const node of removed) {
      this._removeFromClonedElementsGroup(node);
    }
    const mergePosition = this.mergeAttributes(breakStart);
    range.start = mergePosition;
    range.end = mergePosition.clone();
    return new documentfragment_default(this.document, removed);
  }
  clear(range, element) {
    validateRangeContainer(range, this.document);
    const walker = range.getWalker({
      direction: "backward",
      ignoreElementEnd: true
    });
    for (const current of walker) {
      const item = current.item;
      let rangeToRemove;
      if (item.is("element") && element.isSimilar(item)) {
        rangeToRemove = range_default._createOn(item);
      } else if (!current.nextPosition.isAfter(range.start) && item.is("$textProxy")) {
        const parentElement = item.getAncestors().find((ancestor) => {
          return ancestor.is("element") && element.isSimilar(ancestor);
        });
        if (parentElement) {
          rangeToRemove = range_default._createIn(parentElement);
        }
      }
      if (rangeToRemove) {
        if (rangeToRemove.end.isAfter(range.end)) {
          rangeToRemove.end = range.end;
        }
        if (rangeToRemove.start.isBefore(range.start)) {
          rangeToRemove.start = range.start;
        }
        this.remove(rangeToRemove);
      }
    }
  }
  move(sourceRange, targetPosition) {
    let nodes;
    if (targetPosition.isAfter(sourceRange.end)) {
      targetPosition = this._breakAttributes(targetPosition, true);
      const parent2 = targetPosition.parent;
      const countBefore = parent2.childCount;
      sourceRange = this._breakAttributesRange(sourceRange, true);
      nodes = this.remove(sourceRange);
      targetPosition.offset += parent2.childCount - countBefore;
    } else {
      nodes = this.remove(sourceRange);
    }
    return this.insert(targetPosition, nodes);
  }
  wrap(range, attribute) {
    if (!(attribute instanceof attributeelement_default)) {
      throw new ckeditorerror_default("view-writer-wrap-invalid-attribute", this.document);
    }
    validateRangeContainer(range, this.document);
    if (!range.isCollapsed) {
      return this._wrapRange(range, attribute);
    } else {
      let position = range.start;
      if (position.parent.is("element") && !_hasNonUiChildren(position.parent)) {
        position = position.getLastMatchingPosition((value) => value.item.is("uiElement"));
      }
      position = this._wrapPosition(position, attribute);
      const viewSelection = this.document.selection;
      if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {
        this.setSelection(position);
      }
      return new range_default(position);
    }
  }
  unwrap(range, attribute) {
    if (!(attribute instanceof attributeelement_default)) {
      throw new ckeditorerror_default("view-writer-unwrap-invalid-attribute", this.document);
    }
    validateRangeContainer(range, this.document);
    if (range.isCollapsed) {
      return range;
    }
    const {start: breakStart, end: breakEnd} = this._breakAttributesRange(range, true);
    const parentContainer = breakStart.parent;
    const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
    const start = this.mergeAttributes(newRange.start);
    if (!start.isEqual(newRange.start)) {
      newRange.end.offset--;
    }
    const end = this.mergeAttributes(newRange.end);
    return new range_default(start, end);
  }
  rename(newName, viewElement) {
    const newElement = new containerelement_default(this.document, newName, viewElement.getAttributes());
    this.insert(position_default._createAfter(viewElement), newElement);
    this.move(range_default._createIn(viewElement), position_default._createAt(newElement, 0));
    this.remove(range_default._createOn(viewElement));
    return newElement;
  }
  clearClonedElementsGroup(groupName) {
    this._cloneGroups.delete(groupName);
  }
  createPositionAt(itemOrPosition, offset) {
    return position_default._createAt(itemOrPosition, offset);
  }
  createPositionAfter(item) {
    return position_default._createAfter(item);
  }
  createPositionBefore(item) {
    return position_default._createBefore(item);
  }
  createRange(start, end) {
    return new range_default(start, end);
  }
  createRangeOn(item) {
    return range_default._createOn(item);
  }
  createRangeIn(element) {
    return range_default._createIn(element);
  }
  createSelection(...args) {
    return new selection_default(...args);
  }
  createSlot(modeOrFilter = "children") {
    if (!this._slotFactory) {
      throw new ckeditorerror_default("view-writer-invalid-create-slot-context", this.document);
    }
    return this._slotFactory(this, modeOrFilter);
  }
  _registerSlotFactory(slotFactory) {
    this._slotFactory = slotFactory;
  }
  _clearSlotFactory() {
    this._slotFactory = null;
  }
  _insertNodes(position, nodes, breakAttributes) {
    let parentElement;
    if (breakAttributes) {
      parentElement = getParentContainer(position);
    } else {
      parentElement = position.parent.is("$text") ? position.parent.parent : position.parent;
    }
    if (!parentElement) {
      throw new ckeditorerror_default("view-writer-invalid-position-container", this.document);
    }
    let insertionPosition;
    if (breakAttributes) {
      insertionPosition = this._breakAttributes(position, true);
    } else {
      insertionPosition = position.parent.is("$text") ? breakTextNode(position) : position;
    }
    const length = parentElement._insertChild(insertionPosition.offset, nodes);
    for (const node of nodes) {
      this._addToClonedElementsGroup(node);
    }
    const endPosition = insertionPosition.getShiftedBy(length);
    const start = this.mergeAttributes(insertionPosition);
    if (!start.isEqual(insertionPosition)) {
      endPosition.offset--;
    }
    const end = this.mergeAttributes(endPosition);
    return new range_default(start, end);
  }
  _wrapChildren(parent2, startOffset, endOffset, wrapElement) {
    let i = startOffset;
    const wrapPositions = [];
    while (i < endOffset) {
      const child = parent2.getChild(i);
      const isText2 = child.is("$text");
      const isAttribute = child.is("attributeElement");
      if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {
        wrapPositions.push(new position_default(parent2, i));
      } else if (isText2 || !isAttribute || shouldABeOutsideB(wrapElement, child)) {
        const newAttribute = wrapElement._clone();
        child._remove();
        newAttribute._appendChild(child);
        parent2._insertChild(i, newAttribute);
        this._addToClonedElementsGroup(newAttribute);
        wrapPositions.push(new position_default(parent2, i));
      } else {
        this._wrapChildren(child, 0, child.childCount, wrapElement);
      }
      i++;
    }
    let offsetChange = 0;
    for (const position of wrapPositions) {
      position.offset -= offsetChange;
      if (position.offset == startOffset) {
        continue;
      }
      const newPosition = this.mergeAttributes(position);
      if (!newPosition.isEqual(position)) {
        offsetChange++;
        endOffset--;
      }
    }
    return range_default._createFromParentsAndOffsets(parent2, startOffset, parent2, endOffset);
  }
  _unwrapChildren(parent2, startOffset, endOffset, unwrapElement) {
    let i = startOffset;
    const unwrapPositions = [];
    while (i < endOffset) {
      const child = parent2.getChild(i);
      if (!child.is("attributeElement")) {
        i++;
        continue;
      }
      if (child.isSimilar(unwrapElement)) {
        const unwrapped = child.getChildren();
        const count2 = child.childCount;
        child._remove();
        parent2._insertChild(i, unwrapped);
        this._removeFromClonedElementsGroup(child);
        unwrapPositions.push(new position_default(parent2, i), new position_default(parent2, i + count2));
        i += count2;
        endOffset += count2 - 1;
        continue;
      }
      if (this._unwrapAttributeElement(unwrapElement, child)) {
        unwrapPositions.push(new position_default(parent2, i), new position_default(parent2, i + 1));
        i++;
        continue;
      }
      this._unwrapChildren(child, 0, child.childCount, unwrapElement);
      i++;
    }
    let offsetChange = 0;
    for (const position of unwrapPositions) {
      position.offset -= offsetChange;
      if (position.offset == startOffset || position.offset == endOffset) {
        continue;
      }
      const newPosition = this.mergeAttributes(position);
      if (!newPosition.isEqual(position)) {
        offsetChange++;
        endOffset--;
      }
    }
    return range_default._createFromParentsAndOffsets(parent2, startOffset, parent2, endOffset);
  }
  _wrapRange(range, attribute) {
    const {start: breakStart, end: breakEnd} = this._breakAttributesRange(range, true);
    const parentContainer = breakStart.parent;
    const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
    const start = this.mergeAttributes(newRange.start);
    if (!start.isEqual(newRange.start)) {
      newRange.end.offset--;
    }
    const end = this.mergeAttributes(newRange.end);
    return new range_default(start, end);
  }
  _wrapPosition(position, attribute) {
    if (attribute.isSimilar(position.parent)) {
      return movePositionToTextNode(position.clone());
    }
    if (position.parent.is("$text")) {
      position = breakTextNode(position);
    }
    const fakeElement = this.createAttributeElement("_wrapPosition-fake-element");
    fakeElement._priority = Number.POSITIVE_INFINITY;
    fakeElement.isSimilar = () => false;
    position.parent._insertChild(position.offset, fakeElement);
    const wrapRange = new range_default(position, position.getShiftedBy(1));
    this.wrap(wrapRange, attribute);
    const newPosition = new position_default(fakeElement.parent, fakeElement.index);
    fakeElement._remove();
    const nodeBefore = newPosition.nodeBefore;
    const nodeAfter = newPosition.nodeAfter;
    if (nodeBefore instanceof text_default && nodeAfter instanceof text_default) {
      return mergeTextNodes(nodeBefore, nodeAfter);
    }
    return movePositionToTextNode(newPosition);
  }
  _wrapAttributeElement(wrapper, toWrap) {
    if (!canBeJoined(wrapper, toWrap)) {
      return false;
    }
    if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {
      return false;
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {
        return false;
      }
    }
    for (const key of wrapper.getStyleNames()) {
      if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {
        return false;
      }
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      if (!toWrap.hasAttribute(key)) {
        this.setAttribute(key, wrapper.getAttribute(key), toWrap);
      }
    }
    for (const key of wrapper.getStyleNames()) {
      if (!toWrap.hasStyle(key)) {
        this.setStyle(key, wrapper.getStyle(key), toWrap);
      }
    }
    for (const key of wrapper.getClassNames()) {
      if (!toWrap.hasClass(key)) {
        this.addClass(key, toWrap);
      }
    }
    return true;
  }
  _unwrapAttributeElement(wrapper, toUnwrap) {
    if (!canBeJoined(wrapper, toUnwrap)) {
      return false;
    }
    if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {
      return false;
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {
        return false;
      }
    }
    if (!toUnwrap.hasClass(...wrapper.getClassNames())) {
      return false;
    }
    for (const key of wrapper.getStyleNames()) {
      if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {
        return false;
      }
    }
    for (const key of wrapper.getAttributeKeys()) {
      if (key === "class" || key === "style") {
        continue;
      }
      this.removeAttribute(key, toUnwrap);
    }
    this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap);
    this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);
    return true;
  }
  _breakAttributesRange(range, forceSplitText = false) {
    const rangeStart = range.start;
    const rangeEnd = range.end;
    validateRangeContainer(range, this.document);
    if (range.isCollapsed) {
      const position = this._breakAttributes(range.start, forceSplitText);
      return new range_default(position, position);
    }
    const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);
    const count2 = breakEnd.parent.childCount;
    const breakStart = this._breakAttributes(rangeStart, forceSplitText);
    breakEnd.offset += breakEnd.parent.childCount - count2;
    return new range_default(breakStart, breakEnd);
  }
  _breakAttributes(position, forceSplitText = false) {
    const positionOffset = position.offset;
    const positionParent = position.parent;
    if (position.parent.is("emptyElement")) {
      throw new ckeditorerror_default("view-writer-cannot-break-empty-element", this.document);
    }
    if (position.parent.is("uiElement")) {
      throw new ckeditorerror_default("view-writer-cannot-break-ui-element", this.document);
    }
    if (position.parent.is("rawElement")) {
      throw new ckeditorerror_default("view-writer-cannot-break-raw-element", this.document);
    }
    if (!forceSplitText && positionParent.is("$text") && isContainerOrFragment(positionParent.parent)) {
      return position.clone();
    }
    if (isContainerOrFragment(positionParent)) {
      return position.clone();
    }
    if (positionParent.is("$text")) {
      return this._breakAttributes(breakTextNode(position), forceSplitText);
    }
    const length = positionParent.childCount;
    if (positionOffset == length) {
      const newPosition = new position_default(positionParent.parent, positionParent.index + 1);
      return this._breakAttributes(newPosition, forceSplitText);
    } else {
      if (positionOffset === 0) {
        const newPosition = new position_default(positionParent.parent, positionParent.index);
        return this._breakAttributes(newPosition, forceSplitText);
      } else {
        const offsetAfter = positionParent.index + 1;
        const clonedNode = positionParent._clone();
        positionParent.parent._insertChild(offsetAfter, clonedNode);
        this._addToClonedElementsGroup(clonedNode);
        const count2 = positionParent.childCount - positionOffset;
        const nodesToMove = positionParent._removeChildren(positionOffset, count2);
        clonedNode._appendChild(nodesToMove);
        const newPosition = new position_default(positionParent.parent, offsetAfter);
        return this._breakAttributes(newPosition, forceSplitText);
      }
    }
  }
  _addToClonedElementsGroup(element) {
    if (!element.root.is("rootElement")) {
      return;
    }
    if (element.is("element")) {
      for (const child of element.getChildren()) {
        this._addToClonedElementsGroup(child);
      }
    }
    const id = element.id;
    if (!id) {
      return;
    }
    let group = this._cloneGroups.get(id);
    if (!group) {
      group = new Set();
      this._cloneGroups.set(id, group);
    }
    group.add(element);
    element._clonesGroup = group;
  }
  _removeFromClonedElementsGroup(element) {
    if (element.is("element")) {
      for (const child of element.getChildren()) {
        this._removeFromClonedElementsGroup(child);
      }
    }
    const id = element.id;
    if (!id) {
      return;
    }
    const group = this._cloneGroups.get(id);
    if (!group) {
      return;
    }
    group.delete(element);
  }
};
var downcastwriter_default = DowncastWriter;
function _hasNonUiChildren(parent2) {
  return Array.from(parent2.getChildren()).some((child) => !child.is("uiElement"));
}
function getParentContainer(position) {
  let parent2 = position.parent;
  while (!isContainerOrFragment(parent2)) {
    if (!parent2) {
      return void 0;
    }
    parent2 = parent2.parent;
  }
  return parent2;
}
function shouldABeOutsideB(a, b) {
  if (a.priority < b.priority) {
    return true;
  } else if (a.priority > b.priority) {
    return false;
  }
  return a.getIdentity() < b.getIdentity();
}
function movePositionToTextNode(position) {
  const nodeBefore = position.nodeBefore;
  if (nodeBefore && nodeBefore.is("$text")) {
    return new position_default(nodeBefore, nodeBefore.data.length);
  }
  const nodeAfter = position.nodeAfter;
  if (nodeAfter && nodeAfter.is("$text")) {
    return new position_default(nodeAfter, 0);
  }
  return position;
}
function breakTextNode(position) {
  if (position.offset == position.parent.data.length) {
    return new position_default(position.parent.parent, position.parent.index + 1);
  }
  if (position.offset === 0) {
    return new position_default(position.parent.parent, position.parent.index);
  }
  const textToMove = position.parent.data.slice(position.offset);
  position.parent._data = position.parent.data.slice(0, position.offset);
  position.parent.parent._insertChild(position.parent.index + 1, new text_default(position.root.document, textToMove));
  return new position_default(position.parent.parent, position.parent.index + 1);
}
function mergeTextNodes(t1, t2) {
  const nodeBeforeLength = t1.data.length;
  t1._data += t2.data;
  t2._remove();
  return new position_default(t1, nodeBeforeLength);
}
var validNodesToInsert = [text_default, attributeelement_default, containerelement_default, emptyelement_default, rawelement_default, uielement_default];
function validateNodesToInsert(nodes, errorContext) {
  for (const node of nodes) {
    if (!validNodesToInsert.some((validNode) => node instanceof validNode)) {
      throw new ckeditorerror_default("view-writer-insert-invalid-node-type", errorContext);
    }
    if (!node.is("$text")) {
      validateNodesToInsert(node.getChildren(), errorContext);
    }
  }
}
function isContainerOrFragment(node) {
  return node && (node.is("containerElement") || node.is("documentFragment"));
}
function validateRangeContainer(range, errorContext) {
  const startContainer = getParentContainer(range.start);
  const endContainer = getParentContainer(range.end);
  if (!startContainer || !endContainer || startContainer !== endContainer) {
    throw new ckeditorerror_default("view-writer-invalid-range-container", errorContext);
  }
}
function canBeJoined(a, b) {
  return a.id === null && b.id === null;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/filler.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var NBSP_FILLER = (domDocument) => domDocument.createTextNode("\xA0");
var MARKED_NBSP_FILLER = (domDocument) => {
  const span = domDocument.createElement("span");
  span.dataset.ckeFiller = "true";
  span.innerText = "\xA0";
  return span;
};
var BR_FILLER = (domDocument) => {
  const fillerBr = domDocument.createElement("br");
  fillerBr.dataset.ckeFiller = "true";
  return fillerBr;
};
var INLINE_FILLER_LENGTH = 7;
var INLINE_FILLER = "\u2060".repeat(INLINE_FILLER_LENGTH);
function startsWithFiller(domNode) {
  if (typeof domNode == "string") {
    return domNode.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
  }
  return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
}
function isInlineFiller(domText) {
  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
}
function getDataWithoutFiller(domText) {
  const data = typeof domText == "string" ? domText : domText.data;
  if (startsWithFiller(domText)) {
    return data.slice(INLINE_FILLER_LENGTH);
  }
  return data;
}
function injectQuirksHandling(view) {
  view.document.on("arrowKey", jumpOverInlineFiller, {priority: "low"});
}
function jumpOverInlineFiller(evt, data) {
  if (data.keyCode == keyCodes.arrowleft) {
    const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
    if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
      const domParent = domSelection.getRangeAt(0).startContainer;
      const domOffset = domSelection.getRangeAt(0).startOffset;
      if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
        domSelection.collapse(domParent, 0);
      }
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/renderer.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Renderer = class extends ObservableMixin() {
  constructor(domConverter, selection) {
    super();
    this.domDocuments = new Set();
    this.markedAttributes = new Set();
    this.markedChildren = new Set();
    this.markedTexts = new Set();
    this._inlineFiller = null;
    this._fakeSelectionContainer = null;
    this.domConverter = domConverter;
    this.selection = selection;
    this.set("isFocused", false);
    this.set("isSelecting", false);
    if (env_default.isBlink && !env_default.isAndroid) {
      this.on("change:isSelecting", () => {
        if (!this.isSelecting) {
          this.render();
        }
      });
    }
    this.set("isComposing", false);
    this.on("change:isComposing", () => {
      if (!this.isComposing) {
        this.render();
      }
    });
  }
  markToSync(type, node) {
    if (type === "text") {
      if (this.domConverter.mapViewToDom(node.parent)) {
        this.markedTexts.add(node);
      }
    } else {
      if (!this.domConverter.mapViewToDom(node)) {
        return;
      }
      if (type === "attributes") {
        this.markedAttributes.add(node);
      } else if (type === "children") {
        this.markedChildren.add(node);
      } else {
        const unreachable = type;
        throw new ckeditorerror_default("view-renderer-unknown-type", this);
      }
    }
  }
  render() {
    if (this.isComposing && !env_default.isAndroid) {
      return;
    }
    let inlineFillerPosition = null;
    const isInlineFillerRenderingPossible = env_default.isBlink && !env_default.isAndroid ? !this.isSelecting : true;
    for (const element of this.markedChildren) {
      this._updateChildrenMappings(element);
    }
    if (isInlineFillerRenderingPossible) {
      if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
        this._removeInlineFiller();
      }
      if (this._inlineFiller) {
        inlineFillerPosition = this._getInlineFillerPosition();
      } else if (this._needsInlineFillerAtSelection()) {
        inlineFillerPosition = this.selection.getFirstPosition();
        this.markedChildren.add(inlineFillerPosition.parent);
      }
    } else if (this._inlineFiller && this._inlineFiller.parentNode) {
      inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);
      if (inlineFillerPosition && inlineFillerPosition.parent.is("$text")) {
        inlineFillerPosition = position_default._createBefore(inlineFillerPosition.parent);
      }
    }
    for (const element of this.markedAttributes) {
      this._updateAttrs(element);
    }
    for (const element of this.markedChildren) {
      this._updateChildren(element, {inlineFillerPosition});
    }
    for (const node of this.markedTexts) {
      if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {
        this._updateText(node, {inlineFillerPosition});
      }
    }
    if (isInlineFillerRenderingPossible) {
      if (inlineFillerPosition) {
        const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);
        const domDocument = fillerDomPosition.parent.ownerDocument;
        if (!startsWithFiller(fillerDomPosition.parent)) {
          this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);
        } else {
          this._inlineFiller = fillerDomPosition.parent;
        }
      } else {
        this._inlineFiller = null;
      }
    }
    this._updateFocus();
    this._updateSelection();
    this.markedTexts.clear();
    this.markedAttributes.clear();
    this.markedChildren.clear();
  }
  _updateChildrenMappings(viewElement) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    const actualDomChildren = Array.from(domElement.childNodes);
    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {withChildren: false}));
    const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
    const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areSimilarElements);
    if (actions.indexOf("update") !== -1) {
      const counter = {equal: 0, insert: 0, delete: 0};
      for (const action of actions) {
        if (action === "update") {
          const insertIndex = counter.equal + counter.insert;
          const deleteIndex = counter.equal + counter.delete;
          const viewChild = viewElement.getChild(insertIndex);
          if (viewChild && !(viewChild.is("uiElement") || viewChild.is("rawElement"))) {
            this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);
          }
          remove(expectedDomChildren[insertIndex]);
          counter.equal++;
        } else {
          counter[action]++;
        }
      }
    }
  }
  _updateElementMappings(viewElement, domElement) {
    this.domConverter.unbindDomElement(domElement);
    this.domConverter.bindElements(domElement, viewElement);
    this.markedChildren.add(viewElement);
    this.markedAttributes.add(viewElement);
  }
  _getInlineFillerPosition() {
    const firstPos = this.selection.getFirstPosition();
    if (firstPos.parent.is("$text")) {
      return position_default._createBefore(firstPos.parent);
    } else {
      return firstPos;
    }
  }
  _isSelectionInInlineFiller() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
      return false;
    }
    const selectionPosition = this.selection.getFirstPosition();
    const position = this.domConverter.viewPositionToDom(selectionPosition);
    if (position && isText(position.parent) && startsWithFiller(position.parent)) {
      return true;
    }
    return false;
  }
  _removeInlineFiller() {
    const domFillerNode = this._inlineFiller;
    if (!startsWithFiller(domFillerNode)) {
      throw new ckeditorerror_default("view-renderer-filler-was-lost", this);
    }
    if (isInlineFiller(domFillerNode)) {
      domFillerNode.remove();
    } else {
      domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
    }
    this._inlineFiller = null;
  }
  _needsInlineFillerAtSelection() {
    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
      return false;
    }
    const selectionPosition = this.selection.getFirstPosition();
    const selectionParent = selectionPosition.parent;
    const selectionOffset = selectionPosition.offset;
    if (!this.domConverter.mapViewToDom(selectionParent.root)) {
      return false;
    }
    if (!selectionParent.is("element")) {
      return false;
    }
    if (!isEditable(selectionParent)) {
      return false;
    }
    if (selectionOffset === selectionParent.getFillerOffset()) {
      return false;
    }
    const nodeBefore = selectionPosition.nodeBefore;
    const nodeAfter = selectionPosition.nodeAfter;
    if (nodeBefore instanceof text_default || nodeAfter instanceof text_default) {
      return false;
    }
    if (env_default.isAndroid && (nodeBefore || nodeAfter)) {
      return false;
    }
    return true;
  }
  _updateText(viewText, options) {
    const domText = this.domConverter.findCorrespondingDomText(viewText);
    const newDomText = this.domConverter.viewToDom(viewText);
    let expectedText = newDomText.data;
    const filler = options.inlineFillerPosition;
    if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {
      expectedText = INLINE_FILLER + expectedText;
    }
    updateTextNode(domText, expectedText);
  }
  _updateAttrs(viewElement) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    const domAttrKeys = Array.from(domElement.attributes).map((attr) => attr.name);
    const viewAttrKeys = viewElement.getAttributeKeys();
    for (const key of viewAttrKeys) {
      this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);
    }
    for (const key of domAttrKeys) {
      if (!viewElement.hasAttribute(key)) {
        this.domConverter.removeDomElementAttribute(domElement, key);
      }
    }
  }
  _updateChildren(viewElement, options) {
    const domElement = this.domConverter.mapViewToDom(viewElement);
    if (!domElement) {
      return;
    }
    if (env_default.isAndroid) {
      let previousDomNode = null;
      for (const domNode of Array.from(domElement.childNodes)) {
        if (previousDomNode && isText(previousDomNode) && isText(domNode)) {
          domElement.normalize();
          break;
        }
        previousDomNode = domNode;
      }
    }
    const inlineFillerPosition = options.inlineFillerPosition;
    const actualDomChildren = domElement.childNodes;
    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {bind: true}));
    if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {
      addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);
    }
    const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
    const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areTextNodes);
    let i = 0;
    const nodesToUnbind = new Set();
    for (const action of actions) {
      if (action === "delete") {
        nodesToUnbind.add(actualDomChildren[i]);
        remove(actualDomChildren[i]);
      } else if (action === "equal" || action === "update") {
        i++;
      }
    }
    i = 0;
    for (const action of actions) {
      if (action === "insert") {
        insertAt(domElement, i, expectedDomChildren[i]);
        i++;
      } else if (action === "update") {
        updateTextNode(actualDomChildren[i], expectedDomChildren[i].data);
        i++;
      } else if (action === "equal") {
        this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));
        i++;
      }
    }
    for (const node of nodesToUnbind) {
      if (!node.parentNode) {
        this.domConverter.unbindDomElement(node);
      }
    }
  }
  _diffNodeLists(actualDomChildren, expectedDomChildren) {
    actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);
    return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter));
  }
  _findUpdateActions(actions, actualDom, expectedDom, comparator) {
    if (actions.indexOf("insert") === -1 || actions.indexOf("delete") === -1) {
      return actions;
    }
    let newActions = [];
    let actualSlice = [];
    let expectedSlice = [];
    const counter = {equal: 0, insert: 0, delete: 0};
    for (const action of actions) {
      if (action === "insert") {
        expectedSlice.push(expectedDom[counter.equal + counter.insert]);
      } else if (action === "delete") {
        actualSlice.push(actualDom[counter.equal + counter.delete]);
      } else {
        newActions = newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action2) => action2 === "equal" ? "update" : action2));
        newActions.push("equal");
        actualSlice = [];
        expectedSlice = [];
      }
      counter[action]++;
    }
    return newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action) => action === "equal" ? "update" : action));
  }
  _markDescendantTextToSync(viewNode) {
    if (!viewNode) {
      return;
    }
    if (viewNode.is("$text")) {
      this.markedTexts.add(viewNode);
    } else if (viewNode.is("element")) {
      for (const child of viewNode.getChildren()) {
        this._markDescendantTextToSync(child);
      }
    }
  }
  _updateSelection() {
    if (env_default.isBlink && !env_default.isAndroid && this.isSelecting && !this.markedChildren.size) {
      return;
    }
    if (this.selection.rangeCount === 0) {
      this._removeDomSelection();
      this._removeFakeSelection();
      return;
    }
    const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement);
    if (!this.isFocused || !domRoot) {
      return;
    }
    if (this.selection.isFake) {
      this._updateFakeSelection(domRoot);
    } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
      this._removeFakeSelection();
      this._updateDomSelection(domRoot);
    } else if (!(this.isComposing && env_default.isAndroid)) {
      this._updateDomSelection(domRoot);
    }
  }
  _updateFakeSelection(domRoot) {
    const domDocument = domRoot.ownerDocument;
    if (!this._fakeSelectionContainer) {
      this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);
    }
    const container = this._fakeSelectionContainer;
    this.domConverter.bindFakeSelection(container, this.selection);
    if (!this._fakeSelectionNeedsUpdate(domRoot)) {
      return;
    }
    if (!container.parentElement || container.parentElement != domRoot) {
      domRoot.appendChild(container);
    }
    container.textContent = this.selection.fakeSelectionLabel || "\xA0";
    const domSelection = domDocument.getSelection();
    const domRange = domDocument.createRange();
    domSelection.removeAllRanges();
    domRange.selectNodeContents(container);
    domSelection.addRange(domRange);
  }
  _updateDomSelection(domRoot) {
    const domSelection = domRoot.ownerDocument.defaultView.getSelection();
    if (!this._domSelectionNeedsUpdate(domSelection)) {
      return;
    }
    const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);
    const focus = this.domConverter.viewPositionToDom(this.selection.focus);
    domSelection.setBaseAndExtent(anchor.parent, anchor.offset, focus.parent, focus.offset);
    if (env_default.isGecko) {
      fixGeckoSelectionAfterBr(focus, domSelection);
    }
  }
  _domSelectionNeedsUpdate(domSelection) {
    if (!this.domConverter.isDomSelectionCorrect(domSelection)) {
      return true;
    }
    const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);
    if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
      return false;
    }
    if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {
      return false;
    }
    return true;
  }
  _fakeSelectionNeedsUpdate(domRoot) {
    const container = this._fakeSelectionContainer;
    const domSelection = domRoot.ownerDocument.getSelection();
    if (!container || container.parentElement !== domRoot) {
      return true;
    }
    if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {
      return true;
    }
    return container.textContent !== this.selection.fakeSelectionLabel;
  }
  _removeDomSelection() {
    for (const doc of this.domDocuments) {
      const domSelection = doc.getSelection();
      if (domSelection.rangeCount) {
        const activeDomElement = doc.activeElement;
        const viewElement = this.domConverter.mapDomToView(activeDomElement);
        if (activeDomElement && viewElement) {
          domSelection.removeAllRanges();
        }
      }
    }
  }
  _removeFakeSelection() {
    const container = this._fakeSelectionContainer;
    if (container) {
      container.remove();
    }
  }
  _updateFocus() {
    if (this.isFocused) {
      const editable = this.selection.editableElement;
      if (editable) {
        this.domConverter.focus(editable);
      }
    }
  }
};
var renderer_default = Renderer;
function isEditable(element) {
  if (element.getAttribute("contenteditable") == "false") {
    return false;
  }
  const parent2 = element.findAncestor((element2) => element2.hasAttribute("contenteditable"));
  return !parent2 || parent2.getAttribute("contenteditable") == "true";
}
function addInlineFiller(domDocument, domParentOrArray, offset) {
  const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;
  const nodeAfterFiller = childNodes[offset];
  if (isText(nodeAfterFiller)) {
    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;
    return nodeAfterFiller;
  } else {
    const fillerNode = domDocument.createTextNode(INLINE_FILLER);
    if (Array.isArray(domParentOrArray)) {
      childNodes.splice(offset, 0, fillerNode);
    } else {
      insertAt(domParentOrArray, offset, fillerNode);
    }
    return fillerNode;
  }
}
function areSimilarElements(node1, node2) {
  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();
}
function areTextNodes(node1, node2) {
  return isNode(node1) && isNode(node2) && isText(node1) && isText(node2);
}
function sameNodes(domConverter, actualDomChild, expectedDomChild) {
  if (actualDomChild === expectedDomChild) {
    return true;
  } else if (isText(actualDomChild) && isText(expectedDomChild)) {
    return actualDomChild.data === expectedDomChild.data;
  } else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {
    return true;
  }
  return false;
}
function fixGeckoSelectionAfterBr(focus, domSelection) {
  const parent2 = focus.parent;
  if (parent2.nodeType != Node.ELEMENT_NODE || focus.offset != parent2.childNodes.length - 1) {
    return;
  }
  const childAtOffset = parent2.childNodes[focus.offset];
  if (childAtOffset && childAtOffset.tagName == "BR") {
    domSelection.addRange(domSelection.getRangeAt(0));
  }
}
function filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {
  const childList = Array.from(domChildList);
  if (childList.length == 0 || !fakeSelectionContainer) {
    return childList;
  }
  const last2 = childList[childList.length - 1];
  if (last2 == fakeSelectionContainer) {
    childList.pop();
  }
  return childList;
}
function createFakeSelectionContainer(domDocument) {
  const container = domDocument.createElement("div");
  container.className = "ck-fake-selection-container";
  Object.assign(container.style, {
    position: "fixed",
    top: 0,
    left: "-9999px",
    width: "42px"
  });
  container.textContent = "\xA0";
  return container;
}
function updateTextNode(domText, expectedText) {
  const actualText = domText.data;
  if (actualText == expectedText) {
    return;
  }
  const actions = fastDiff(actualText, expectedText);
  for (const action of actions) {
    if (action.type === "insert") {
      domText.insertData(action.index, action.values.join(""));
    } else {
      domText.deleteData(action.index, action.howMany);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BR_FILLER_REF = BR_FILLER(global_default.document);
var NBSP_FILLER_REF = NBSP_FILLER(global_default.document);
var MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(global_default.document);
var UNSAFE_ATTRIBUTE_NAME_PREFIX = "data-ck-unsafe-attribute-";
var UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = "data-ck-unsafe-element";
var DomConverter = class {
  constructor(document2, {blockFillerMode, renderingMode = "editing"} = {}) {
    this._domToViewMapping = new WeakMap();
    this._viewToDomMapping = new WeakMap();
    this._fakeSelectionMapping = new WeakMap();
    this._rawContentElementMatcher = new matcher_default();
    this._inlineObjectElementMatcher = new matcher_default();
    this.document = document2;
    this.renderingMode = renderingMode;
    this.blockFillerMode = blockFillerMode || (renderingMode === "editing" ? "br" : "nbsp");
    this.preElements = ["pre"];
    this.blockElements = [
      "address",
      "article",
      "aside",
      "blockquote",
      "caption",
      "center",
      "dd",
      "details",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "legend",
      "li",
      "main",
      "menu",
      "nav",
      "ol",
      "p",
      "pre",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr",
      "ul"
    ];
    this.inlineObjectElements = [
      "object",
      "iframe",
      "input",
      "button",
      "textarea",
      "select",
      "option",
      "video",
      "embed",
      "audio",
      "img",
      "canvas"
    ];
    this.unsafeElements = ["script", "style"];
    this._domDocument = this.renderingMode === "editing" ? global_default.document : global_default.document.implementation.createHTMLDocument("");
  }
  bindFakeSelection(domElement, viewDocumentSelection) {
    this._fakeSelectionMapping.set(domElement, new selection_default(viewDocumentSelection));
  }
  fakeSelectionToView(domElement) {
    return this._fakeSelectionMapping.get(domElement);
  }
  bindElements(domElement, viewElement) {
    this._domToViewMapping.set(domElement, viewElement);
    this._viewToDomMapping.set(viewElement, domElement);
  }
  unbindDomElement(domElement) {
    const viewElement = this._domToViewMapping.get(domElement);
    if (viewElement) {
      this._domToViewMapping.delete(domElement);
      this._viewToDomMapping.delete(viewElement);
      for (const child of Array.from(domElement.children)) {
        this.unbindDomElement(child);
      }
    }
  }
  bindDocumentFragments(domFragment, viewFragment) {
    this._domToViewMapping.set(domFragment, viewFragment);
    this._viewToDomMapping.set(viewFragment, domFragment);
  }
  shouldRenderAttribute(attributeKey, attributeValue, elementName) {
    if (this.renderingMode === "data") {
      return true;
    }
    attributeKey = attributeKey.toLowerCase();
    if (attributeKey.startsWith("on")) {
      return false;
    }
    if (attributeKey === "srcdoc" && attributeValue.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
      return false;
    }
    if (elementName === "img" && (attributeKey === "src" || attributeKey === "srcset")) {
      return true;
    }
    if (elementName === "source" && attributeKey === "srcset") {
      return true;
    }
    if (attributeValue.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
      return false;
    }
    return true;
  }
  setContentOf(domElement, html) {
    if (this.renderingMode === "data") {
      domElement.innerHTML = html;
      return;
    }
    const document2 = new DOMParser().parseFromString(html, "text/html");
    const fragment = document2.createDocumentFragment();
    const bodyChildNodes = document2.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    const treeWalker = document2.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);
    const nodes = [];
    let currentNode;
    while (currentNode = treeWalker.nextNode()) {
      nodes.push(currentNode);
    }
    for (const currentNode2 of nodes) {
      for (const attributeName of currentNode2.getAttributeNames()) {
        this.setDomElementAttribute(currentNode2, attributeName, currentNode2.getAttribute(attributeName));
      }
      const elementName = currentNode2.tagName.toLowerCase();
      if (this._shouldRenameElement(elementName)) {
        _logUnsafeElement(elementName);
        currentNode2.replaceWith(this._createReplacementDomElement(elementName, currentNode2));
      }
    }
    while (domElement.firstChild) {
      domElement.firstChild.remove();
    }
    domElement.append(fragment);
  }
  viewToDom(viewNode, options = {}) {
    if (viewNode.is("$text")) {
      const textData = this._processDataFromViewText(viewNode);
      return this._domDocument.createTextNode(textData);
    } else {
      if (this.mapViewToDom(viewNode)) {
        return this.mapViewToDom(viewNode);
      }
      let domElement;
      if (viewNode.is("documentFragment")) {
        domElement = this._domDocument.createDocumentFragment();
        if (options.bind) {
          this.bindDocumentFragments(domElement, viewNode);
        }
      } else if (viewNode.is("uiElement")) {
        if (viewNode.name === "$comment") {
          domElement = this._domDocument.createComment(viewNode.getCustomProperty("$rawContent"));
        } else {
          domElement = viewNode.render(this._domDocument, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewNode);
        }
        return domElement;
      } else {
        if (this._shouldRenameElement(viewNode.name)) {
          _logUnsafeElement(viewNode.name);
          domElement = this._createReplacementDomElement(viewNode.name);
        } else if (viewNode.hasAttribute("xmlns")) {
          domElement = this._domDocument.createElementNS(viewNode.getAttribute("xmlns"), viewNode.name);
        } else {
          domElement = this._domDocument.createElement(viewNode.name);
        }
        if (viewNode.is("rawElement")) {
          viewNode.render(domElement, this);
        }
        if (options.bind) {
          this.bindElements(domElement, viewNode);
        }
        for (const key of viewNode.getAttributeKeys()) {
          this.setDomElementAttribute(domElement, key, viewNode.getAttribute(key), viewNode);
        }
      }
      if (options.withChildren !== false) {
        for (const child of this.viewChildrenToDom(viewNode, options)) {
          domElement.appendChild(child);
        }
      }
      return domElement;
    }
  }
  setDomElementAttribute(domElement, key, value, relatedViewElement) {
    const shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);
    if (!shouldRenderAttribute) {
      logWarning("domconverter-unsafe-attribute-detected", {domElement, key, value});
    }
    if (!isValidAttributeName(key)) {
      logWarning("domconverter-invalid-attribute-detected", {domElement, key, value});
      return;
    }
    if (domElement.hasAttribute(key) && !shouldRenderAttribute) {
      domElement.removeAttribute(key);
    } else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {
      domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
    }
    domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);
  }
  removeDomElementAttribute(domElement, key) {
    if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {
      return;
    }
    domElement.removeAttribute(key);
    domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
  }
  *viewChildrenToDom(viewElement, options = {}) {
    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
    let offset = 0;
    for (const childView of viewElement.getChildren()) {
      if (fillerPositionOffset === offset) {
        yield this._getBlockFiller();
      }
      const transparentRendering = childView.is("element") && !!childView.getCustomProperty("dataPipeline:transparentRendering") && !first(childView.getAttributes());
      if (transparentRendering && this.renderingMode == "data") {
        yield* this.viewChildrenToDom(childView, options);
      } else {
        if (transparentRendering) {
          logWarning("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {viewElement: childView});
        }
        yield this.viewToDom(childView, options);
      }
      offset++;
    }
    if (fillerPositionOffset === offset) {
      yield this._getBlockFiller();
    }
  }
  viewRangeToDom(viewRange) {
    const domStart = this.viewPositionToDom(viewRange.start);
    const domEnd = this.viewPositionToDom(viewRange.end);
    const domRange = this._domDocument.createRange();
    domRange.setStart(domStart.parent, domStart.offset);
    domRange.setEnd(domEnd.parent, domEnd.offset);
    return domRange;
  }
  viewPositionToDom(viewPosition) {
    const viewParent = viewPosition.parent;
    if (viewParent.is("$text")) {
      const domParent = this.findCorrespondingDomText(viewParent);
      if (!domParent) {
        return null;
      }
      let offset = viewPosition.offset;
      if (startsWithFiller(domParent)) {
        offset += INLINE_FILLER_LENGTH;
      }
      return {parent: domParent, offset};
    } else {
      let domParent, domBefore, domAfter;
      if (viewPosition.offset === 0) {
        domParent = this.mapViewToDom(viewParent);
        if (!domParent) {
          return null;
        }
        domAfter = domParent.childNodes[0];
      } else {
        const nodeBefore = viewPosition.nodeBefore;
        domBefore = nodeBefore.is("$text") ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(nodeBefore);
        if (!domBefore) {
          return null;
        }
        domParent = domBefore.parentNode;
        domAfter = domBefore.nextSibling;
      }
      if (isText(domAfter) && startsWithFiller(domAfter)) {
        return {parent: domAfter, offset: INLINE_FILLER_LENGTH};
      }
      const offset = domBefore ? indexOf(domBefore) + 1 : 0;
      return {parent: domParent, offset};
    }
  }
  domToView(domNode, options = {}) {
    const inlineNodes = [];
    const generator = this._domToView(domNode, options, inlineNodes);
    const node = generator.next().value;
    if (!node) {
      return null;
    }
    generator.next();
    this._processDomInlineNodes(null, inlineNodes, options);
    if (node.is("$text") && node.data.length == 0) {
      return null;
    }
    return node;
  }
  *domChildrenToView(domElement, options = {}, inlineNodes = []) {
    for (let i = 0; i < domElement.childNodes.length; i++) {
      const domChild = domElement.childNodes[i];
      const generator = this._domToView(domChild, options, inlineNodes);
      const viewChild = generator.next().value;
      if (viewChild !== null) {
        if (this._isBlockViewElement(viewChild)) {
          this._processDomInlineNodes(domElement, inlineNodes, options);
        }
        yield viewChild;
        generator.next();
      }
    }
    this._processDomInlineNodes(domElement, inlineNodes, options);
  }
  domSelectionToView(domSelection) {
    if (isGeckoRestrictedDomSelection(domSelection)) {
      return new selection_default([]);
    }
    if (domSelection.rangeCount === 1) {
      let container = domSelection.getRangeAt(0).startContainer;
      if (isText(container)) {
        container = container.parentNode;
      }
      const viewSelection = this.fakeSelectionToView(container);
      if (viewSelection) {
        return viewSelection;
      }
    }
    const isBackward = this.isDomSelectionBackward(domSelection);
    const viewRanges = [];
    for (let i = 0; i < domSelection.rangeCount; i++) {
      const domRange = domSelection.getRangeAt(i);
      const viewRange = this.domRangeToView(domRange);
      if (viewRange) {
        viewRanges.push(viewRange);
      }
    }
    return new selection_default(viewRanges, {backward: isBackward});
  }
  domRangeToView(domRange) {
    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);
    if (viewStart && viewEnd) {
      return new range_default(viewStart, viewEnd);
    }
    return null;
  }
  domPositionToView(domParent, domOffset = 0) {
    if (this.isBlockFiller(domParent)) {
      return this.domPositionToView(domParent.parentNode, indexOf(domParent));
    }
    const viewElement = this.mapDomToView(domParent);
    if (viewElement && (viewElement.is("uiElement") || viewElement.is("rawElement"))) {
      return position_default._createBefore(viewElement);
    }
    if (isText(domParent)) {
      if (isInlineFiller(domParent)) {
        return this.domPositionToView(domParent.parentNode, indexOf(domParent));
      }
      const viewParent = this.findCorrespondingViewText(domParent);
      let offset = domOffset;
      if (!viewParent) {
        return null;
      }
      if (startsWithFiller(domParent)) {
        offset -= INLINE_FILLER_LENGTH;
        offset = offset < 0 ? 0 : offset;
      }
      return new position_default(viewParent, offset);
    } else {
      if (domOffset === 0) {
        const viewParent = this.mapDomToView(domParent);
        if (viewParent) {
          return new position_default(viewParent, 0);
        }
      } else {
        const domBefore = domParent.childNodes[domOffset - 1];
        if (isText(domBefore) && isInlineFiller(domBefore) || domBefore && this.isBlockFiller(domBefore)) {
          return this.domPositionToView(domBefore.parentNode, indexOf(domBefore));
        }
        const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore);
        if (viewBefore && viewBefore.parent) {
          return new position_default(viewBefore.parent, viewBefore.index + 1);
        }
      }
      return null;
    }
  }
  mapDomToView(domElementOrDocumentFragment) {
    const hostElement = this.getHostViewElement(domElementOrDocumentFragment);
    return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);
  }
  findCorrespondingViewText(domText) {
    if (isInlineFiller(domText)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domText);
    if (hostElement) {
      return hostElement;
    }
    const previousSibling = domText.previousSibling;
    if (previousSibling) {
      if (!this.isElement(previousSibling)) {
        return null;
      }
      const viewElement = this.mapDomToView(previousSibling);
      if (viewElement) {
        const nextSibling = viewElement.nextSibling;
        if (nextSibling instanceof text_default) {
          return nextSibling;
        } else {
          return null;
        }
      }
    } else {
      const viewElement = this.mapDomToView(domText.parentNode);
      if (viewElement) {
        const firstChild = viewElement.getChild(0);
        if (firstChild instanceof text_default) {
          return firstChild;
        } else {
          return null;
        }
      }
    }
    return null;
  }
  mapViewToDom(documentFragmentOrElement) {
    return this._viewToDomMapping.get(documentFragmentOrElement);
  }
  findCorrespondingDomText(viewText) {
    const previousSibling = viewText.previousSibling;
    if (previousSibling && this.mapViewToDom(previousSibling)) {
      return this.mapViewToDom(previousSibling).nextSibling;
    }
    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {
      return this.mapViewToDom(viewText.parent).childNodes[0];
    }
    return null;
  }
  focus(viewEditable) {
    const domEditable = this.mapViewToDom(viewEditable);
    if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
      const {scrollX, scrollY} = global_default.window;
      const scrollPositions = [];
      forEachDomElementAncestor(domEditable, (node) => {
        const {scrollLeft, scrollTop} = node;
        scrollPositions.push([scrollLeft, scrollTop]);
      });
      domEditable.focus();
      forEachDomElementAncestor(domEditable, (node) => {
        const [scrollLeft, scrollTop] = scrollPositions.shift();
        node.scrollLeft = scrollLeft;
        node.scrollTop = scrollTop;
      });
      global_default.window.scrollTo(scrollX, scrollY);
    }
  }
  _clearDomSelection() {
    const domEditable = this.mapViewToDom(this.document.selection.editableElement);
    if (!domEditable) {
      return;
    }
    const domSelection = domEditable.ownerDocument.defaultView.getSelection();
    const newViewSelection = this.domSelectionToView(domSelection);
    const selectionInEditable = newViewSelection && newViewSelection.rangeCount > 0;
    if (selectionInEditable) {
      domSelection.removeAllRanges();
    }
  }
  isElement(node) {
    return node && node.nodeType == Node.ELEMENT_NODE;
  }
  isDocumentFragment(node) {
    return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
  }
  isBlockFiller(domNode) {
    if (this.blockFillerMode == "br") {
      return domNode.isEqualNode(BR_FILLER_REF);
    }
    if (domNode.tagName === "BR" && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {
      return true;
    }
    return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);
  }
  isDomSelectionBackward(selection) {
    if (selection.isCollapsed) {
      return false;
    }
    const range = this._domDocument.createRange();
    try {
      range.setStart(selection.anchorNode, selection.anchorOffset);
      range.setEnd(selection.focusNode, selection.focusOffset);
    } catch (e) {
      return false;
    }
    const backward = range.collapsed;
    range.detach();
    return backward;
  }
  getHostViewElement(domNode) {
    const ancestors = getAncestors(domNode);
    ancestors.pop();
    while (ancestors.length) {
      const domNode2 = ancestors.pop();
      const viewNode = this._domToViewMapping.get(domNode2);
      if (viewNode && (viewNode.is("uiElement") || viewNode.is("rawElement"))) {
        return viewNode;
      }
    }
    return null;
  }
  isDomSelectionCorrect(domSelection) {
    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);
  }
  registerRawContentMatcher(pattern) {
    this._rawContentElementMatcher.add(pattern);
  }
  registerInlineObjectMatcher(pattern) {
    this._inlineObjectElementMatcher.add(pattern);
  }
  _getBlockFiller() {
    switch (this.blockFillerMode) {
      case "nbsp":
        return NBSP_FILLER(this._domDocument);
      case "markedNbsp":
        return MARKED_NBSP_FILLER(this._domDocument);
      case "br":
        return BR_FILLER(this._domDocument);
    }
  }
  _isDomSelectionPositionCorrect(domParent, offset) {
    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {
      return false;
    }
    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {
      return false;
    }
    const viewParent = this.mapDomToView(domParent);
    if (viewParent && (viewParent.is("uiElement") || viewParent.is("rawElement"))) {
      return false;
    }
    return true;
  }
  *_domToView(domNode, options, inlineNodes) {
    if (this.isBlockFiller(domNode)) {
      return null;
    }
    const hostElement = this.getHostViewElement(domNode);
    if (hostElement) {
      return hostElement;
    }
    if (isComment(domNode) && options.skipComments) {
      return null;
    }
    if (isText(domNode)) {
      if (isInlineFiller(domNode)) {
        return null;
      } else {
        const textData = domNode.data;
        if (textData === "") {
          return null;
        }
        const textNode = new text_default(this.document, textData);
        inlineNodes.push(textNode);
        return textNode;
      }
    } else {
      let viewElement = this.mapDomToView(domNode);
      if (viewElement) {
        if (this._isInlineObjectElement(viewElement)) {
          inlineNodes.push(viewElement);
        }
        return viewElement;
      }
      if (this.isDocumentFragment(domNode)) {
        viewElement = new documentfragment_default(this.document);
        if (options.bind) {
          this.bindDocumentFragments(domNode, viewElement);
        }
      } else {
        viewElement = this._createViewElement(domNode, options);
        if (options.bind) {
          this.bindElements(domNode, viewElement);
        }
        const attrs = domNode.attributes;
        if (attrs) {
          for (let l = attrs.length, i = 0; i < l; i++) {
            viewElement._setAttribute(attrs[i].name, attrs[i].value);
          }
        }
        if (this._isViewElementWithRawContent(viewElement, options)) {
          viewElement._setCustomProperty("$rawContent", domNode.innerHTML);
          if (!this._isBlockViewElement(viewElement)) {
            inlineNodes.push(viewElement);
          }
          return viewElement;
        }
        if (isComment(domNode)) {
          viewElement._setCustomProperty("$rawContent", domNode.data);
          return viewElement;
        }
      }
      yield viewElement;
      const nestedInlineNodes = [];
      if (options.withChildren !== false) {
        for (const child of this.domChildrenToView(domNode, options, nestedInlineNodes)) {
          viewElement._appendChild(child);
        }
      }
      if (this._isInlineObjectElement(viewElement)) {
        inlineNodes.push(viewElement);
      } else {
        for (const inlineNode of nestedInlineNodes) {
          inlineNodes.push(inlineNode);
        }
      }
    }
  }
  _processDomInlineNodes(domParent, inlineNodes, options) {
    if (!inlineNodes.length) {
      return;
    }
    if (domParent && !this.isDocumentFragment(domParent) && !this._isBlockDomElement(domParent)) {
      return;
    }
    let prevNodeEndsWithSpace = false;
    for (let i = 0; i < inlineNodes.length; i++) {
      const node = inlineNodes[i];
      if (!node.is("$text")) {
        prevNodeEndsWithSpace = false;
        continue;
      }
      let data;
      let nodeEndsWithSpace = false;
      if (_hasViewParentOfType(node, this.preElements)) {
        data = getDataWithoutFiller(node.data);
      } else {
        data = node.data.replace(/[ \n\t\r]{1,}/g, " ");
        nodeEndsWithSpace = /[^\S\u00A0]/.test(data.charAt(data.length - 1));
        const prevNode = i > 0 ? inlineNodes[i - 1] : null;
        const nextNode = i + 1 < inlineNodes.length ? inlineNodes[i + 1] : null;
        const shouldLeftTrim = !prevNode || prevNode.is("element") && prevNode.name == "br" || prevNodeEndsWithSpace;
        const shouldRightTrim = nextNode ? false : !startsWithFiller(node.data);
        if (options.withChildren !== false) {
          if (shouldLeftTrim) {
            data = data.replace(/^ /, "");
          }
          if (shouldRightTrim) {
            data = data.replace(/ $/, "");
          }
        }
        data = getDataWithoutFiller(data);
        data = data.replace(/ \u00A0/g, "  ");
        const isNextNodeInlineObjectElement = nextNode && nextNode.is("element") && nextNode.name != "br";
        const isNextNodeStartingWithSpace = nextNode && nextNode.is("$text") && nextNode.data.charAt(0) == " ";
        if (/[ \u00A0]\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {
          data = data.replace(/\u00A0$/, " ");
        }
        if (shouldLeftTrim || prevNode && prevNode.is("element") && prevNode.name != "br") {
          data = data.replace(/^\u00A0/, " ");
        }
      }
      if (data.length == 0 && node.parent) {
        node._remove();
        inlineNodes.splice(i, 1);
        i--;
      } else {
        node._data = data;
        prevNodeEndsWithSpace = nodeEndsWithSpace;
      }
    }
    inlineNodes.length = 0;
  }
  _processDataFromViewText(node) {
    let data = node.data;
    if (node.getAncestors().some((parent2) => this.preElements.includes(parent2.name))) {
      return data;
    }
    if (data.charAt(0) == " ") {
      const prevNode = this._getTouchingInlineViewNode(node, false);
      const prevEndsWithSpace = prevNode && prevNode.is("$textProxy") && this._nodeEndsWithSpace(prevNode);
      if (prevEndsWithSpace || !prevNode) {
        data = "\xA0" + data.substr(1);
      }
    }
    if (data.charAt(data.length - 1) == " ") {
      const nextNode = this._getTouchingInlineViewNode(node, true);
      const nextStartsWithSpace = nextNode && nextNode.is("$textProxy") && nextNode.data.charAt(0) == " ";
      if (data.charAt(data.length - 2) == " " || !nextNode || nextStartsWithSpace) {
        data = data.substr(0, data.length - 1) + "\xA0";
      }
    }
    return data.replace(/ {2}/g, " \xA0");
  }
  _nodeEndsWithSpace(node) {
    if (node.getAncestors().some((parent2) => this.preElements.includes(parent2.name))) {
      return false;
    }
    const data = this._processDataFromViewText(node);
    return data.charAt(data.length - 1) == " ";
  }
  _getTouchingInlineViewNode(node, getNext) {
    const treeWalker = new treewalker_default({
      startPosition: getNext ? position_default._createAfter(node) : position_default._createBefore(node),
      direction: getNext ? "forward" : "backward"
    });
    for (const value of treeWalker) {
      if (value.item.is("element", "br")) {
        return null;
      } else if (this._isInlineObjectElement(value.item)) {
        return value.item;
      } else if (value.item.is("containerElement")) {
        return null;
      } else if (value.item.is("$textProxy")) {
        return value.item;
      }
    }
    return null;
  }
  _isBlockDomElement(node) {
    return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());
  }
  _isBlockViewElement(node) {
    return node.is("element") && this.blockElements.includes(node.name);
  }
  _isInlineObjectElement(node) {
    if (!node.is("element")) {
      return false;
    }
    return node.name == "br" || this.inlineObjectElements.includes(node.name) || !!this._inlineObjectElementMatcher.match(node);
  }
  _createViewElement(node, options) {
    if (isComment(node)) {
      return new uielement_default(this.document, "$comment");
    }
    const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();
    return new element_default(this.document, viewName);
  }
  _isViewElementWithRawContent(viewElement, options) {
    return options.withChildren !== false && viewElement.is("element") && !!this._rawContentElementMatcher.match(viewElement);
  }
  _shouldRenameElement(elementName) {
    const name = elementName.toLowerCase();
    return this.renderingMode === "editing" && this.unsafeElements.includes(name);
  }
  _createReplacementDomElement(elementName, originalDomElement) {
    const newDomElement = this._domDocument.createElement("span");
    newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);
    if (originalDomElement) {
      while (originalDomElement.firstChild) {
        newDomElement.appendChild(originalDomElement.firstChild);
      }
      for (const attributeName of originalDomElement.getAttributeNames()) {
        newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));
      }
    }
    return newDomElement;
  }
};
var domconverter_default = DomConverter;
function _hasViewParentOfType(node, types) {
  return node.getAncestors().some((parent2) => parent2.is("element") && types.includes(parent2.name));
}
function forEachDomElementAncestor(element, callback) {
  let node = element;
  while (node) {
    callback(node);
    node = node.parentElement;
  }
}
function isNbspBlockFiller(domNode, blockElements) {
  const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);
  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
}
function hasBlockParent(domNode, blockElements) {
  const parent2 = domNode.parentNode;
  return !!parent2 && !!parent2.tagName && blockElements.includes(parent2.tagName.toLowerCase());
}
function _logUnsafeElement(elementName) {
  if (elementName === "script") {
    logWarning("domconverter-unsafe-script-element-detected");
  }
  if (elementName === "style") {
    logWarning("domconverter-unsafe-style-element-detected");
  }
}
function isGeckoRestrictedDomSelection(domSelection) {
  if (!env_default.isGecko) {
    return false;
  }
  if (!domSelection.rangeCount) {
    return false;
  }
  const container = domSelection.getRangeAt(0).startContainer;
  try {
    Object.prototype.toString.call(container);
  } catch (error) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/observer.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Observer = class extends DomEmitterMixin() {
  constructor(view) {
    super();
    this._isEnabled = false;
    this.view = view;
    this.document = view.document;
  }
  get isEnabled() {
    return this._isEnabled;
  }
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  destroy() {
    this.disable();
    this.stopListening();
  }
  checkShouldIgnoreEventFromTarget(domTarget) {
    if (domTarget && domTarget.nodeType === 3) {
      domTarget = domTarget.parentNode;
    }
    if (!domTarget || domTarget.nodeType !== 1) {
      return false;
    }
    return domTarget.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
  }
};
var observer_default = Observer;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventdata.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DomEventData = class {
  constructor(view, domEvent, additionalData) {
    this.view = view;
    this.document = view.document;
    this.domEvent = domEvent;
    this.domTarget = domEvent.target;
    assignIn_default(this, additionalData);
  }
  get target() {
    return this.view.domConverter.mapDomToView(this.domTarget);
  }
  preventDefault() {
    this.domEvent.preventDefault();
  }
  stopPropagation() {
    this.domEvent.stopPropagation();
  }
};
var domeventdata_default = DomEventData;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DomEventObserver = class extends observer_default {
  constructor() {
    super(...arguments);
    this.useCapture = false;
  }
  observe(domElement) {
    const types = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
    types.forEach((type) => {
      this.listenTo(domElement, type, (eventInfo, domEvent) => {
        if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(domEvent.target)) {
          this.onDomEvent(domEvent);
        }
      }, {useCapture: this.useCapture});
    });
  }
  stopObserving(domElement) {
    this.stopListening(domElement);
  }
  fire(eventType, domEvent, additionalData) {
    if (this.isEnabled) {
      this.document.fire(eventType, new domeventdata_default(this.view, domEvent, additionalData));
    }
  }
};
var domeventobserver_default = DomEventObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/keyobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var KeyObserver = class extends domeventobserver_default {
  constructor() {
    super(...arguments);
    this.domEventType = ["keydown", "keyup"];
  }
  onDomEvent(domEvt) {
    const data = {
      keyCode: domEvt.keyCode,
      altKey: domEvt.altKey,
      ctrlKey: domEvt.ctrlKey,
      shiftKey: domEvt.shiftKey,
      metaKey: domEvt.metaKey,
      get keystroke() {
        return getCode(this);
      }
    };
    this.fire(domEvt.type, domEvt, data);
  }
};
var keyobserver_default = KeyObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/fakeselectionobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var FakeSelectionObserver = class extends observer_default {
  constructor(view) {
    super(view);
    this._fireSelectionChangeDoneDebounced = debounce_default((data) => {
      this.document.fire("selectionChangeDone", data);
    }, 200);
  }
  observe() {
    const document2 = this.document;
    document2.on("arrowKey", (eventInfo, data) => {
      const selection = document2.selection;
      if (selection.isFake && this.isEnabled) {
        data.preventDefault();
      }
    }, {context: "$capture"});
    document2.on("arrowKey", (eventInfo, data) => {
      const selection = document2.selection;
      if (selection.isFake && this.isEnabled) {
        this._handleSelectionMove(data.keyCode);
      }
    }, {priority: "lowest"});
  }
  stopObserving() {
  }
  destroy() {
    super.destroy();
    this._fireSelectionChangeDoneDebounced.cancel();
  }
  _handleSelectionMove(keyCode) {
    const selection = this.document.selection;
    const newSelection = new selection_default(selection.getRanges(), {backward: selection.isBackward, fake: false});
    if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {
      newSelection.setTo(newSelection.getFirstPosition());
    }
    if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {
      newSelection.setTo(newSelection.getLastPosition());
    }
    const data = {
      oldSelection: selection,
      newSelection,
      domSelection: null
    };
    this.document.fire("selectionChange", data);
    this._fireSelectionChangeDoneDebounced(data);
  }
};
var fakeselectionobserver_default = FakeSelectionObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mutationobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MutationObserver = class extends observer_default {
  constructor(view) {
    super(view);
    this._config = {
      childList: true,
      characterData: true,
      subtree: true
    };
    this.domConverter = view.domConverter;
    this.renderer = view._renderer;
    this._domElements = new Set();
    this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
  }
  flush() {
    this._onMutations(this._mutationObserver.takeRecords());
  }
  observe(domElement) {
    this._domElements.add(domElement);
    if (this.isEnabled) {
      this._mutationObserver.observe(domElement, this._config);
    }
  }
  stopObserving(domElement) {
    this._domElements.delete(domElement);
    if (this.isEnabled) {
      this._mutationObserver.disconnect();
      for (const domElement2 of this._domElements) {
        this._mutationObserver.observe(domElement2, this._config);
      }
    }
  }
  enable() {
    super.enable();
    for (const domElement of this._domElements) {
      this._mutationObserver.observe(domElement, this._config);
    }
  }
  disable() {
    super.disable();
    this._mutationObserver.disconnect();
  }
  destroy() {
    super.destroy();
    this._mutationObserver.disconnect();
  }
  _onMutations(domMutations) {
    if (domMutations.length === 0) {
      return;
    }
    const domConverter = this.domConverter;
    const mutatedTextNodes = new Set();
    const elementsWithMutatedChildren = new Set();
    for (const mutation of domMutations) {
      const element = domConverter.mapDomToView(mutation.target);
      if (!element) {
        continue;
      }
      if (element.is("uiElement") || element.is("rawElement")) {
        continue;
      }
      if (mutation.type === "childList" && !this._isBogusBrMutation(mutation)) {
        elementsWithMutatedChildren.add(element);
      }
    }
    for (const mutation of domMutations) {
      const element = domConverter.mapDomToView(mutation.target);
      if (element && (element.is("uiElement") || element.is("rawElement"))) {
        continue;
      }
      if (mutation.type === "characterData") {
        const text = domConverter.findCorrespondingViewText(mutation.target);
        if (text && !elementsWithMutatedChildren.has(text.parent)) {
          mutatedTextNodes.add(text);
        } else if (!text && startsWithFiller(mutation.target)) {
          elementsWithMutatedChildren.add(domConverter.mapDomToView(mutation.target.parentNode));
        }
      }
    }
    let hasMutations = false;
    for (const textNode of mutatedTextNodes) {
      hasMutations = true;
      this.renderer.markToSync("text", textNode);
    }
    for (const viewElement of elementsWithMutatedChildren) {
      const domElement = domConverter.mapViewToDom(viewElement);
      const viewChildren = Array.from(viewElement.getChildren());
      const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {withChildren: false}));
      if (!isEqualWith_default(viewChildren, newViewChildren, sameNodes2)) {
        hasMutations = true;
        this.renderer.markToSync("children", viewElement);
      }
    }
    if (hasMutations) {
      this.view.forceRender();
    }
  }
  _isBogusBrMutation(mutation) {
    let addedNode = null;
    if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {
      addedNode = this.domConverter.domToView(mutation.addedNodes[0], {
        withChildren: false
      });
    }
    return addedNode && addedNode.is("element", "br");
  }
};
var mutationobserver_default = MutationObserver;
function sameNodes2(child1, child2) {
  if (Array.isArray(child1)) {
    return;
  }
  if (child1 === child2) {
    return true;
  } else if (child1.is("$text") && child2.is("$text")) {
    return child1.data === child2.data;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/focusobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var FocusObserver = class extends domeventobserver_default {
  constructor(view) {
    super(view);
    this._isFocusChanging = false;
    this.domEventType = ["focus", "blur"];
    this.useCapture = true;
    const document2 = this.document;
    document2.on("focus", () => {
      this._isFocusChanging = true;
      this._renderTimeoutId = setTimeout(() => {
        this.flush();
        view.change(() => {
        });
      }, 50);
    });
    document2.on("blur", (evt, data) => {
      const selectedEditable = document2.selection.editableElement;
      if (selectedEditable === null || selectedEditable === data.target) {
        document2.isFocused = false;
        this._isFocusChanging = false;
        view.change(() => {
        });
      }
    });
  }
  flush() {
    if (this._isFocusChanging) {
      this._isFocusChanging = false;
      this.document.isFocused = true;
    }
  }
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
  destroy() {
    if (this._renderTimeoutId) {
      clearTimeout(this._renderTimeoutId);
    }
    super.destroy();
  }
};
var focusobserver_default = FocusObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/selectionobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SelectionObserver = class extends observer_default {
  constructor(view) {
    super(view);
    this.mutationObserver = view.getObserver(mutationobserver_default);
    this.focusObserver = view.getObserver(focusobserver_default);
    this.selection = this.document.selection;
    this.domConverter = view.domConverter;
    this._documents = new WeakSet();
    this._fireSelectionChangeDoneDebounced = debounce_default((data) => {
      this.document.fire("selectionChangeDone", data);
    }, 200);
    this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
    this._documentIsSelectingInactivityTimeoutDebounced = debounce_default(() => this.document.isSelecting = false, 5e3);
    this._loopbackCounter = 0;
  }
  observe(domElement) {
    const domDocument = domElement.ownerDocument;
    const startDocumentIsSelecting = () => {
      this.document.isSelecting = true;
      this._documentIsSelectingInactivityTimeoutDebounced();
    };
    const endDocumentIsSelecting = () => {
      if (!this.document.isSelecting) {
        return;
      }
      this._handleSelectionChange(null, domDocument);
      this.document.isSelecting = false;
      this._documentIsSelectingInactivityTimeoutDebounced.cancel();
    };
    this.listenTo(domElement, "selectstart", startDocumentIsSelecting, {priority: "highest"});
    this.listenTo(domElement, "keydown", endDocumentIsSelecting, {priority: "highest", useCapture: true});
    this.listenTo(domElement, "keyup", endDocumentIsSelecting, {priority: "highest", useCapture: true});
    if (this._documents.has(domDocument)) {
      return;
    }
    this.listenTo(domDocument, "mouseup", endDocumentIsSelecting, {priority: "highest", useCapture: true});
    this.listenTo(domDocument, "selectionchange", (evt, domEvent) => {
      if (this.document.isComposing && !env_default.isAndroid) {
        return;
      }
      this._handleSelectionChange(domEvent, domDocument);
      this._documentIsSelectingInactivityTimeoutDebounced();
    });
    this._documents.add(domDocument);
  }
  stopObserving(domElement) {
    this.stopListening(domElement);
  }
  destroy() {
    super.destroy();
    clearInterval(this._clearInfiniteLoopInterval);
    this._fireSelectionChangeDoneDebounced.cancel();
    this._documentIsSelectingInactivityTimeoutDebounced.cancel();
  }
  _reportInfiniteLoop() {
  }
  _handleSelectionChange(domEvent, domDocument) {
    if (!this.isEnabled) {
      return;
    }
    const domSelection = domDocument.defaultView.getSelection();
    if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {
      return;
    }
    this.mutationObserver.flush();
    const newViewSelection = this.domConverter.domSelectionToView(domSelection);
    if (newViewSelection.rangeCount == 0) {
      this.view.hasDomSelection = false;
      return;
    }
    this.view.hasDomSelection = true;
    this.focusObserver.flush();
    if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {
      return;
    }
    if (++this._loopbackCounter > 60) {
      this._reportInfiniteLoop();
      return;
    }
    if (this.selection.isSimilar(newViewSelection)) {
      this.view.forceRender();
    } else {
      const data = {
        oldSelection: this.selection,
        newSelection: newViewSelection,
        domSelection
      };
      this.document.fire("selectionChange", data);
      this._fireSelectionChangeDoneDebounced(data);
    }
  }
  _clearInfiniteLoop() {
    this._loopbackCounter = 0;
  }
};
var selectionobserver_default = SelectionObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/compositionobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var CompositionObserver = class extends domeventobserver_default {
  constructor(view) {
    super(view);
    this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
    const document2 = this.document;
    document2.on("compositionstart", () => {
      document2.isComposing = true;
    }, {priority: "low"});
    document2.on("compositionend", () => {
      document2.isComposing = false;
    }, {priority: "low"});
  }
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent, {
      data: domEvent.data
    });
  }
};
var compositionobserver_default = CompositionObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/datatransfer.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DataTransfer = class {
  constructor(nativeDataTransfer, options = {}) {
    this._files = options.cacheFiles ? getFiles(nativeDataTransfer) : null;
    this._native = nativeDataTransfer;
  }
  get files() {
    if (!this._files) {
      this._files = getFiles(this._native);
    }
    return this._files;
  }
  get types() {
    return this._native.types;
  }
  getData(type) {
    return this._native.getData(type);
  }
  setData(type, data) {
    this._native.setData(type, data);
  }
  set effectAllowed(value) {
    this._native.effectAllowed = value;
  }
  get effectAllowed() {
    return this._native.effectAllowed;
  }
  set dropEffect(value) {
    this._native.dropEffect = value;
  }
  get dropEffect() {
    return this._native.dropEffect;
  }
  setDragImage(image, x, y) {
    this._native.setDragImage(image, x, y);
  }
  get isCanceled() {
    return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
  }
};
var datatransfer_default = DataTransfer;
function getFiles(nativeDataTransfer) {
  const files = Array.from(nativeDataTransfer.files || []);
  const items = Array.from(nativeDataTransfer.items || []);
  if (files.length) {
    return files;
  }
  return items.filter((item) => item.kind === "file").map((item) => item.getAsFile());
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/inputobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InputObserver = class extends domeventobserver_default {
  constructor() {
    super(...arguments);
    this.domEventType = "beforeinput";
  }
  onDomEvent(domEvent) {
    const domTargetRanges = domEvent.getTargetRanges();
    const view = this.view;
    const viewDocument = view.document;
    let dataTransfer = null;
    let data = null;
    let targetRanges = [];
    if (domEvent.dataTransfer) {
      dataTransfer = new datatransfer_default(domEvent.dataTransfer);
    }
    if (domEvent.data !== null) {
      data = domEvent.data;
    } else if (dataTransfer) {
      data = dataTransfer.getData("text/plain");
    }
    if (viewDocument.selection.isFake) {
      targetRanges = Array.from(viewDocument.selection.getRanges());
    } else if (domTargetRanges.length) {
      targetRanges = domTargetRanges.map((domRange) => {
        const viewStart = view.domConverter.domPositionToView(domRange.startContainer, domRange.startOffset);
        const viewEnd = view.domConverter.domPositionToView(domRange.endContainer, domRange.endOffset);
        if (viewStart) {
          return view.createRange(viewStart, viewEnd);
        } else if (viewEnd) {
          return view.createRange(viewEnd);
        }
      }).filter((range) => !!range);
    } else if (env_default.isAndroid) {
      const domSelection = domEvent.target.ownerDocument.defaultView.getSelection();
      targetRanges = Array.from(view.domConverter.domSelectionToView(domSelection).getRanges());
    }
    if (env_default.isAndroid && domEvent.inputType == "insertCompositionText" && data && data.endsWith("\n")) {
      this.fire(domEvent.type, domEvent, {
        inputType: "insertParagraph",
        targetRanges: [view.createRange(targetRanges[0].end)]
      });
      return;
    }
    if (domEvent.inputType == "insertText" && data && data.includes("\n")) {
      const parts = data.split(/\n{1,2}/g);
      let partTargetRanges = targetRanges;
      for (let i = 0; i < parts.length; i++) {
        const dataPart = parts[i];
        if (dataPart != "") {
          this.fire(domEvent.type, domEvent, {
            data: dataPart,
            dataTransfer,
            targetRanges: partTargetRanges,
            inputType: domEvent.inputType,
            isComposing: domEvent.isComposing
          });
          partTargetRanges = [viewDocument.selection.getFirstRange()];
        }
        if (i + 1 < parts.length) {
          this.fire(domEvent.type, domEvent, {
            inputType: "insertParagraph",
            targetRanges: partTargetRanges
          });
          partTargetRanges = [viewDocument.selection.getFirstRange()];
        }
      }
      return;
    }
    this.fire(domEvent.type, domEvent, {
      data,
      dataTransfer,
      targetRanges,
      inputType: domEvent.inputType,
      isComposing: domEvent.isComposing
    });
  }
};
var inputobserver_default = InputObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/arrowkeysobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ArrowKeysObserver = class extends observer_default {
  constructor(view) {
    super(view);
    this.document.on("keydown", (event, data) => {
      if (this.isEnabled && isArrowKeyCode(data.keyCode)) {
        const eventInfo = new bubblingeventinfo_default(this.document, "arrowKey", this.document.selection.getFirstRange());
        this.document.fire(eventInfo, data);
        if (eventInfo.stop.called) {
          event.stop();
        }
      }
    });
  }
  observe() {
  }
  stopObserving() {
  }
};
var arrowkeysobserver_default = ArrowKeysObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/tabobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TabObserver = class extends observer_default {
  constructor(view) {
    super(view);
    const doc = this.document;
    doc.on("keydown", (evt, data) => {
      if (!this.isEnabled || data.keyCode != keyCodes.tab || data.ctrlKey) {
        return;
      }
      const event = new bubblingeventinfo_default(doc, "tab", doc.selection.getFirstRange());
      doc.fire(event, data);
      if (event.stop.called) {
        evt.stop();
      }
    });
  }
  observe() {
  }
  stopObserving() {
  }
};
var tabobserver_default = TabObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/view.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var View = class extends ObservableMixin() {
  constructor(stylesProcessor) {
    super();
    this.domRoots = new Map();
    this._initialDomRootAttributes = new WeakMap();
    this._observers = new Map();
    this._ongoingChange = false;
    this._postFixersInProgress = false;
    this._renderingDisabled = false;
    this._hasChangedSinceTheLastRendering = false;
    this.document = new document_default(stylesProcessor);
    this.domConverter = new domconverter_default(this.document);
    this.set("isRenderingInProgress", false);
    this.set("hasDomSelection", false);
    this._renderer = new renderer_default(this.domConverter, this.document.selection);
    this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing");
    this._writer = new downcastwriter_default(this.document);
    this.addObserver(mutationobserver_default);
    this.addObserver(focusobserver_default);
    this.addObserver(selectionobserver_default);
    this.addObserver(keyobserver_default);
    this.addObserver(fakeselectionobserver_default);
    this.addObserver(compositionobserver_default);
    this.addObserver(arrowkeysobserver_default);
    this.addObserver(inputobserver_default);
    this.addObserver(tabobserver_default);
    injectQuirksHandling(this);
    injectUiElementHandling(this);
    this.on("render", () => {
      this._render();
      this.document.fire("layoutChanged");
      this._hasChangedSinceTheLastRendering = false;
    });
    this.listenTo(this.document.selection, "change", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    this.listenTo(this.document, "change:isFocused", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    if (env_default.isiOS) {
      this.listenTo(this.document, "blur", (evt, data) => {
        const relatedViewElement = this.domConverter.mapDomToView(data.domEvent.relatedTarget);
        if (!relatedViewElement) {
          this.domConverter._clearDomSelection();
        }
      });
    }
  }
  attachDomRoot(domRoot, name = "main") {
    const viewRoot = this.document.getRoot(name);
    viewRoot._name = domRoot.tagName.toLowerCase();
    const initialDomRootAttributes = {};
    for (const {name: name2, value} of Array.from(domRoot.attributes)) {
      initialDomRootAttributes[name2] = value;
      if (name2 === "class") {
        this._writer.addClass(value.split(" "), viewRoot);
      } else {
        this._writer.setAttribute(name2, value, viewRoot);
      }
    }
    this._initialDomRootAttributes.set(domRoot, initialDomRootAttributes);
    const updateContenteditableAttribute = () => {
      this._writer.setAttribute("contenteditable", (!viewRoot.isReadOnly).toString(), viewRoot);
      if (viewRoot.isReadOnly) {
        this._writer.addClass("ck-read-only", viewRoot);
      } else {
        this._writer.removeClass("ck-read-only", viewRoot);
      }
    };
    updateContenteditableAttribute();
    this.domRoots.set(name, domRoot);
    this.domConverter.bindElements(domRoot, viewRoot);
    this._renderer.markToSync("children", viewRoot);
    this._renderer.markToSync("attributes", viewRoot);
    this._renderer.domDocuments.add(domRoot.ownerDocument);
    viewRoot.on("change:children", (evt, node) => this._renderer.markToSync("children", node));
    viewRoot.on("change:attributes", (evt, node) => this._renderer.markToSync("attributes", node));
    viewRoot.on("change:text", (evt, node) => this._renderer.markToSync("text", node));
    viewRoot.on("change:isReadOnly", () => this.change(updateContenteditableAttribute));
    viewRoot.on("change", () => {
      this._hasChangedSinceTheLastRendering = true;
    });
    for (const observer of this._observers.values()) {
      observer.observe(domRoot, name);
    }
  }
  detachDomRoot(name) {
    const domRoot = this.domRoots.get(name);
    Array.from(domRoot.attributes).forEach(({name: name2}) => domRoot.removeAttribute(name2));
    const initialDomRootAttributes = this._initialDomRootAttributes.get(domRoot);
    for (const attribute in initialDomRootAttributes) {
      domRoot.setAttribute(attribute, initialDomRootAttributes[attribute]);
    }
    this.domRoots.delete(name);
    this.domConverter.unbindDomElement(domRoot);
    for (const observer of this._observers.values()) {
      observer.stopObserving(domRoot);
    }
  }
  getDomRoot(name = "main") {
    return this.domRoots.get(name);
  }
  addObserver(ObserverConstructor) {
    let observer = this._observers.get(ObserverConstructor);
    if (observer) {
      return observer;
    }
    observer = new ObserverConstructor(this);
    this._observers.set(ObserverConstructor, observer);
    for (const [name, domElement] of this.domRoots) {
      observer.observe(domElement, name);
    }
    observer.enable();
    return observer;
  }
  getObserver(ObserverConstructor) {
    return this._observers.get(ObserverConstructor);
  }
  disableObservers() {
    for (const observer of this._observers.values()) {
      observer.disable();
    }
  }
  enableObservers() {
    for (const observer of this._observers.values()) {
      observer.enable();
    }
  }
  scrollToTheSelection({alignToTop, forceScroll, viewportOffset = 20, ancestorOffset = 20} = {}) {
    const range = this.document.selection.getFirstRange();
    if (!range) {
      return;
    }
    const originalArgs = cloneDeep_default({alignToTop, forceScroll, viewportOffset, ancestorOffset});
    if (typeof viewportOffset === "number") {
      viewportOffset = {
        top: viewportOffset,
        bottom: viewportOffset,
        left: viewportOffset,
        right: viewportOffset
      };
    }
    const options = {
      target: this.domConverter.viewRangeToDom(range),
      viewportOffset,
      ancestorOffset,
      alignToTop,
      forceScroll
    };
    this.fire("scrollToTheSelection", options, originalArgs);
    scrollViewportToShowTarget(options);
  }
  focus() {
    if (!this.document.isFocused) {
      const editable = this.document.selection.editableElement;
      if (editable) {
        this.domConverter.focus(editable);
        this.forceRender();
      } else {
      }
    }
  }
  change(callback) {
    if (this.isRenderingInProgress || this._postFixersInProgress) {
      throw new ckeditorerror_default("cannot-change-view-tree", this);
    }
    try {
      if (this._ongoingChange) {
        return callback(this._writer);
      }
      this._ongoingChange = true;
      const callbackResult = callback(this._writer);
      this._ongoingChange = false;
      if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
        this._postFixersInProgress = true;
        this.document._callPostFixers(this._writer);
        this._postFixersInProgress = false;
        this.fire("render");
      }
      return callbackResult;
    } catch (err) {
      /* istanbul ignore next -- @preserve */
      ckeditorerror_default.rethrowUnexpectedError(err, this);
    }
  }
  forceRender() {
    this._hasChangedSinceTheLastRendering = true;
    this.getObserver(focusobserver_default).flush();
    this.change(() => {
    });
  }
  destroy() {
    for (const observer of this._observers.values()) {
      observer.destroy();
    }
    this.document.destroy();
    this.stopListening();
  }
  createPositionAt(itemOrPosition, offset) {
    return position_default._createAt(itemOrPosition, offset);
  }
  createPositionAfter(item) {
    return position_default._createAfter(item);
  }
  createPositionBefore(item) {
    return position_default._createBefore(item);
  }
  createRange(start, end) {
    return new range_default(start, end);
  }
  createRangeOn(item) {
    return range_default._createOn(item);
  }
  createRangeIn(element) {
    return range_default._createIn(element);
  }
  createSelection(...args) {
    return new selection_default(...args);
  }
  _disableRendering(flag) {
    this._renderingDisabled = flag;
    if (flag == false) {
      this.change(() => {
      });
    }
  }
  _render() {
    this.isRenderingInProgress = true;
    this.disableObservers();
    this._renderer.render();
    this.enableObservers();
    this.isRenderingInProgress = false;
  }
};
var view_default = View;

// node_modules/@ckeditor/ckeditor5-engine/src/model/typecheckable.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TypeCheckable2 = class {
  is() {
    throw new Error("is() method is abstract");
  }
};
var typecheckable_default2 = TypeCheckable2;

// node_modules/@ckeditor/ckeditor5-engine/src/model/node.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Node3 = class extends typecheckable_default2 {
  constructor(attrs) {
    super();
    this.parent = null;
    this._attrs = toMap(attrs);
  }
  get document() {
    return null;
  }
  get index() {
    let pos;
    if (!this.parent) {
      return null;
    }
    if ((pos = this.parent.getChildIndex(this)) === null) {
      throw new ckeditorerror_default("model-node-not-found-in-parent", this);
    }
    return pos;
  }
  get startOffset() {
    let pos;
    if (!this.parent) {
      return null;
    }
    if ((pos = this.parent.getChildStartOffset(this)) === null) {
      throw new ckeditorerror_default("model-node-not-found-in-parent", this);
    }
    return pos;
  }
  get offsetSize() {
    return 1;
  }
  get endOffset() {
    if (!this.parent) {
      return null;
    }
    return this.startOffset + this.offsetSize;
  }
  get nextSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index + 1) || null;
  }
  get previousSibling() {
    const index = this.index;
    return index !== null && this.parent.getChild(index - 1) || null;
  }
  get root() {
    let root2 = this;
    while (root2.parent) {
      root2 = root2.parent;
    }
    return root2;
  }
  isAttached() {
    return this.parent === null ? false : this.root.isAttached();
  }
  getPath() {
    const path = [];
    let node = this;
    while (node.parent) {
      path.unshift(node.startOffset);
      node = node.parent;
    }
    return path;
  }
  getAncestors(options = {}) {
    const ancestors = [];
    let parent2 = options.includeSelf ? this : this.parent;
    while (parent2) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent2);
      parent2 = parent2.parent;
    }
    return ancestors;
  }
  getCommonAncestor(node, options = {}) {
    const ancestorsA = this.getAncestors(options);
    const ancestorsB = node.getAncestors(options);
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  isBefore(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    const thisPath = this.getPath();
    const nodePath = node.getPath();
    const result = compareArrays(thisPath, nodePath);
    switch (result) {
      case "prefix":
        return true;
      case "extension":
        return false;
      default:
        return thisPath[result] < nodePath[result];
    }
  }
  isAfter(node) {
    if (this == node) {
      return false;
    }
    if (this.root !== node.root) {
      return false;
    }
    return !this.isBefore(node);
  }
  hasAttribute(key) {
    return this._attrs.has(key);
  }
  getAttribute(key) {
    return this._attrs.get(key);
  }
  getAttributes() {
    return this._attrs.entries();
  }
  getAttributeKeys() {
    return this._attrs.keys();
  }
  toJSON() {
    const json = {};
    if (this._attrs.size) {
      json.attributes = Array.from(this._attrs).reduce((result, attr) => {
        result[attr[0]] = attr[1];
        return result;
      }, {});
    }
    return json;
  }
  _clone(_deep) {
    return new this.constructor(this._attrs);
  }
  _remove() {
    this.parent._removeChildren(this.index);
  }
  _setAttribute(key, value) {
    this._attrs.set(key, value);
  }
  _setAttributesTo(attrs) {
    this._attrs = toMap(attrs);
  }
  _removeAttribute(key) {
    return this._attrs.delete(key);
  }
  _clearAttributes() {
    this._attrs.clear();
  }
};
var node_default2 = Node3;
Node3.prototype.is = function(type) {
  return type === "node" || type === "model:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/nodelist.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var NodeList = class {
  constructor(nodes) {
    this._nodes = [];
    if (nodes) {
      this._insertNodes(0, nodes);
    }
  }
  [Symbol.iterator]() {
    return this._nodes[Symbol.iterator]();
  }
  get length() {
    return this._nodes.length;
  }
  get maxOffset() {
    return this._nodes.reduce((sum, node) => sum + node.offsetSize, 0);
  }
  getNode(index) {
    return this._nodes[index] || null;
  }
  getNodeIndex(node) {
    const index = this._nodes.indexOf(node);
    return index == -1 ? null : index;
  }
  getNodeStartOffset(node) {
    const index = this.getNodeIndex(node);
    return index === null ? null : this._nodes.slice(0, index).reduce((sum, node2) => sum + node2.offsetSize, 0);
  }
  indexToOffset(index) {
    if (index == this._nodes.length) {
      return this.maxOffset;
    }
    const node = this._nodes[index];
    if (!node) {
      throw new ckeditorerror_default("model-nodelist-index-out-of-bounds", this);
    }
    return this.getNodeStartOffset(node);
  }
  offsetToIndex(offset) {
    let totalOffset = 0;
    for (const node of this._nodes) {
      if (offset >= totalOffset && offset < totalOffset + node.offsetSize) {
        return this.getNodeIndex(node);
      }
      totalOffset += node.offsetSize;
    }
    if (totalOffset != offset) {
      throw new ckeditorerror_default("model-nodelist-offset-out-of-bounds", this, {
        offset,
        nodeList: this
      });
    }
    return this.length;
  }
  _insertNodes(index, nodes) {
    for (const node of nodes) {
      if (!(node instanceof node_default2)) {
        throw new ckeditorerror_default("model-nodelist-insertnodes-not-node", this);
      }
    }
    this._nodes = spliceArray(this._nodes, Array.from(nodes), index, 0);
  }
  _removeNodes(indexStart, howMany = 1) {
    return this._nodes.splice(indexStart, howMany);
  }
  toJSON() {
    return this._nodes.map((node) => node.toJSON());
  }
};
var nodelist_default = NodeList;

// node_modules/@ckeditor/ckeditor5-engine/src/model/text.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Text2 = class extends node_default2 {
  constructor(data, attrs) {
    super(attrs);
    this._data = data || "";
  }
  get offsetSize() {
    return this.data.length;
  }
  get data() {
    return this._data;
  }
  toJSON() {
    const json = super.toJSON();
    json.data = this.data;
    return json;
  }
  _clone() {
    return new Text2(this.data, this.getAttributes());
  }
  static fromJSON(json) {
    return new Text2(json.data, json.attributes);
  }
};
var text_default2 = Text2;
Text2.prototype.is = function(type) {
  return type === "$text" || type === "model:$text" || type === "text" || type === "model:text" || type === "node" || type === "model:node";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/textproxy.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TextProxy2 = class extends typecheckable_default2 {
  constructor(textNode, offsetInText, length) {
    super();
    this.textNode = textNode;
    if (offsetInText < 0 || offsetInText > textNode.offsetSize) {
      throw new ckeditorerror_default("model-textproxy-wrong-offsetintext", this);
    }
    if (length < 0 || offsetInText + length > textNode.offsetSize) {
      throw new ckeditorerror_default("model-textproxy-wrong-length", this);
    }
    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    this.offsetInText = offsetInText;
  }
  get startOffset() {
    return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
  }
  get offsetSize() {
    return this.data.length;
  }
  get endOffset() {
    return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
  }
  get isPartial() {
    return this.offsetSize !== this.textNode.offsetSize;
  }
  get parent() {
    return this.textNode.parent;
  }
  get root() {
    return this.textNode.root;
  }
  getPath() {
    const path = this.textNode.getPath();
    if (path.length > 0) {
      path[path.length - 1] += this.offsetInText;
    }
    return path;
  }
  getAncestors(options = {}) {
    const ancestors = [];
    let parent2 = options.includeSelf ? this : this.parent;
    while (parent2) {
      ancestors[options.parentFirst ? "push" : "unshift"](parent2);
      parent2 = parent2.parent;
    }
    return ancestors;
  }
  hasAttribute(key) {
    return this.textNode.hasAttribute(key);
  }
  getAttribute(key) {
    return this.textNode.getAttribute(key);
  }
  getAttributes() {
    return this.textNode.getAttributes();
  }
  getAttributeKeys() {
    return this.textNode.getAttributeKeys();
  }
};
var textproxy_default2 = TextProxy2;
TextProxy2.prototype.is = function(type) {
  return type === "$textProxy" || type === "model:$textProxy" || type === "textProxy" || type === "model:textProxy";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/element.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Element2 = class extends node_default2 {
  constructor(name, attrs, children) {
    super(attrs);
    this._children = new nodelist_default();
    this.name = name;
    if (children) {
      this._insertChild(0, children);
    }
  }
  get childCount() {
    return this._children.length;
  }
  get maxOffset() {
    return this._children.maxOffset;
  }
  get isEmpty() {
    return this.childCount === 0;
  }
  getChild(index) {
    return this._children.getNode(index);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  getChildIndex(node) {
    return this._children.getNodeIndex(node);
  }
  getChildStartOffset(node) {
    return this._children.getNodeStartOffset(node);
  }
  offsetToIndex(offset) {
    return this._children.offsetToIndex(offset);
  }
  getNodeByPath(relativePath) {
    let node = this;
    for (const index of relativePath) {
      node = node.getChild(node.offsetToIndex(index));
    }
    return node;
  }
  findAncestor(parentName, options = {}) {
    let parent2 = options.includeSelf ? this : this.parent;
    while (parent2) {
      if (parent2.name === parentName) {
        return parent2;
      }
      parent2 = parent2.parent;
    }
    return null;
  }
  toJSON() {
    const json = super.toJSON();
    json.name = this.name;
    if (this._children.length > 0) {
      json.children = [];
      for (const node of this._children) {
        json.children.push(node.toJSON());
      }
    }
    return json;
  }
  _clone(deep = false) {
    const children = deep ? Array.from(this._children).map((node) => node._clone(true)) : void 0;
    return new Element2(this.name, this.getAttributes(), children);
  }
  _appendChild(nodes) {
    this._insertChild(this.childCount, nodes);
  }
  _insertChild(index, items) {
    const nodes = normalize3(items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
    }
    this._children._insertNodes(index, nodes);
  }
  _removeChildren(index, howMany = 1) {
    const nodes = this._children._removeNodes(index, howMany);
    for (const node of nodes) {
      node.parent = null;
    }
    return nodes;
  }
  static fromJSON(json) {
    let children;
    if (json.children) {
      children = [];
      for (const child of json.children) {
        if (child.name) {
          children.push(Element2.fromJSON(child));
        } else {
          children.push(text_default2.fromJSON(child));
        }
      }
    }
    return new Element2(json.name, json.attributes, children);
  }
};
var element_default2 = Element2;
Element2.prototype.is = function(type, name) {
  if (!name) {
    return type === "element" || type === "model:element" || type === "node" || type === "model:node";
  }
  return name === this.name && (type === "element" || type === "model:element");
};
function normalize3(nodes) {
  if (typeof nodes == "string") {
    return [new text_default2(nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new text_default2(node);
    }
    if (node instanceof textproxy_default2) {
      return new text_default2(node.data, node.getAttributes());
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TreeWalker2 = class {
  constructor(options) {
    if (!options || !options.boundaries && !options.startPosition) {
      throw new ckeditorerror_default("model-tree-walker-no-start-position", null);
    }
    const direction = options.direction || "forward";
    if (direction != "forward" && direction != "backward") {
      throw new ckeditorerror_default("model-tree-walker-unknown-direction", options, {direction});
    }
    this.direction = direction;
    this.boundaries = options.boundaries || null;
    if (options.startPosition) {
      this._position = options.startPosition.clone();
    } else {
      this._position = position_default2._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]);
    }
    this.position.stickiness = "toNone";
    this.singleCharacters = !!options.singleCharacters;
    this.shallow = !!options.shallow;
    this.ignoreElementEnd = !!options.ignoreElementEnd;
    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
    this._visitedParent = this.position.parent;
  }
  [Symbol.iterator]() {
    return this;
  }
  get position() {
    return this._position;
  }
  skip(skip) {
    let done, value, prevPosition, prevVisitedParent;
    do {
      prevPosition = this.position;
      prevVisitedParent = this._visitedParent;
      ({done, value} = this.next());
    } while (!done && skip(value));
    if (!done) {
      this._position = prevPosition;
      this._visitedParent = prevVisitedParent;
    }
  }
  next() {
    if (this.direction == "forward") {
      return this._next();
    } else {
      return this._previous();
    }
  }
  _next() {
    const previousPosition = this.position;
    const position = this.position.clone();
    const parent2 = this._visitedParent;
    if (parent2.parent === null && position.offset === parent2.maxOffset) {
      return {done: true, value: void 0};
    }
    if (parent2 === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
      return {done: true, value: void 0};
    }
    const textNodeAtPosition = getTextNodeAtPosition(position, parent2);
    const node = textNodeAtPosition || getNodeAfterPosition(position, parent2, textNodeAtPosition);
    if (node instanceof element_default2) {
      if (!this.shallow) {
        position.path.push(0);
        this._visitedParent = node;
      } else {
        if (this.boundaries && this.boundaries.end.isBefore(position)) {
          return {done: true, value: void 0};
        }
        position.offset++;
      }
      this._position = position;
      return formatReturnValue("elementStart", node, previousPosition, position, 1);
    }
    if (node instanceof text_default2) {
      let charactersCount;
      if (this.singleCharacters) {
        charactersCount = 1;
      } else {
        let offset = node.endOffset;
        if (this._boundaryEndParent == parent2 && this.boundaries.end.offset < offset) {
          offset = this.boundaries.end.offset;
        }
        charactersCount = offset - position.offset;
      }
      const offsetInTextNode = position.offset - node.startOffset;
      const item = new textproxy_default2(node, offsetInTextNode, charactersCount);
      position.offset += charactersCount;
      this._position = position;
      return formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    position.path.pop();
    position.offset++;
    this._position = position;
    this._visitedParent = parent2.parent;
    if (this.ignoreElementEnd) {
      return this._next();
    }
    return formatReturnValue("elementEnd", parent2, previousPosition, position);
  }
  _previous() {
    const previousPosition = this.position;
    const position = this.position.clone();
    const parent2 = this._visitedParent;
    if (parent2.parent === null && position.offset === 0) {
      return {done: true, value: void 0};
    }
    if (parent2 == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
      return {done: true, value: void 0};
    }
    const positionParent = position.parent;
    const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);
    const node = textNodeAtPosition || getNodeBeforePosition(position, positionParent, textNodeAtPosition);
    if (node instanceof element_default2) {
      position.offset--;
      if (this.shallow) {
        this._position = position;
        return formatReturnValue("elementStart", node, previousPosition, position, 1);
      }
      position.path.push(node.maxOffset);
      this._position = position;
      this._visitedParent = node;
      if (this.ignoreElementEnd) {
        return this._previous();
      }
      return formatReturnValue("elementEnd", node, previousPosition, position);
    }
    if (node instanceof text_default2) {
      let charactersCount;
      if (this.singleCharacters) {
        charactersCount = 1;
      } else {
        let offset = node.startOffset;
        if (this._boundaryStartParent == parent2 && this.boundaries.start.offset > offset) {
          offset = this.boundaries.start.offset;
        }
        charactersCount = position.offset - offset;
      }
      const offsetInTextNode = position.offset - node.startOffset;
      const item = new textproxy_default2(node, offsetInTextNode - charactersCount, charactersCount);
      position.offset -= charactersCount;
      this._position = position;
      return formatReturnValue("text", item, previousPosition, position, charactersCount);
    }
    position.path.pop();
    this._position = position;
    this._visitedParent = parent2.parent;
    return formatReturnValue("elementStart", parent2, previousPosition, position, 1);
  }
};
var treewalker_default2 = TreeWalker2;
function formatReturnValue(type, item, previousPosition, nextPosition, length) {
  return {
    done: false,
    value: {
      type,
      item,
      previousPosition,
      nextPosition,
      length
    }
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/position.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Position2 = class extends typecheckable_default2 {
  constructor(root2, path, stickiness = "toNone") {
    super();
    if (!root2.is("element") && !root2.is("documentFragment")) {
      throw new ckeditorerror_default("model-position-root-invalid", root2);
    }
    if (!(path instanceof Array) || path.length === 0) {
      throw new ckeditorerror_default("model-position-path-incorrect-format", root2, {path});
    }
    if (root2.is("rootElement")) {
      path = path.slice();
    } else {
      path = [...root2.getPath(), ...path];
      root2 = root2.root;
    }
    this.root = root2;
    this.path = path;
    this.stickiness = stickiness;
  }
  get offset() {
    return this.path[this.path.length - 1];
  }
  set offset(newOffset) {
    this.path[this.path.length - 1] = newOffset;
  }
  get parent() {
    let parent2 = this.root;
    for (let i = 0; i < this.path.length - 1; i++) {
      parent2 = parent2.getChild(parent2.offsetToIndex(this.path[i]));
      if (!parent2) {
        throw new ckeditorerror_default("model-position-path-incorrect", this, {position: this});
      }
    }
    if (parent2.is("$text")) {
      throw new ckeditorerror_default("model-position-path-incorrect", this, {position: this});
    }
    return parent2;
  }
  get index() {
    return this.parent.offsetToIndex(this.offset);
  }
  get textNode() {
    return getTextNodeAtPosition(this, this.parent);
  }
  get nodeAfter() {
    const parent2 = this.parent;
    return getNodeAfterPosition(this, parent2, getTextNodeAtPosition(this, parent2));
  }
  get nodeBefore() {
    const parent2 = this.parent;
    return getNodeBeforePosition(this, parent2, getTextNodeAtPosition(this, parent2));
  }
  get isAtStart() {
    return this.offset === 0;
  }
  get isAtEnd() {
    return this.offset == this.parent.maxOffset;
  }
  compareWith(otherPosition) {
    if (this.root != otherPosition.root) {
      return "different";
    }
    const result = compareArrays(this.path, otherPosition.path);
    switch (result) {
      case "same":
        return "same";
      case "prefix":
        return "before";
      case "extension":
        return "after";
      default:
        return this.path[result] < otherPosition.path[result] ? "before" : "after";
    }
  }
  getLastMatchingPosition(skip, options = {}) {
    options.startPosition = this;
    const treeWalker = new treewalker_default2(options);
    treeWalker.skip(skip);
    return treeWalker.position;
  }
  getParentPath() {
    return this.path.slice(0, -1);
  }
  getAncestors() {
    const parent2 = this.parent;
    if (parent2.is("documentFragment")) {
      return [parent2];
    } else {
      return parent2.getAncestors({includeSelf: true});
    }
  }
  findAncestor(parentName) {
    const parent2 = this.parent;
    if (parent2.is("element")) {
      return parent2.findAncestor(parentName, {includeSelf: true});
    }
    return null;
  }
  getCommonPath(position) {
    if (this.root != position.root) {
      return [];
    }
    const cmp = compareArrays(this.path, position.path);
    const diffAt = typeof cmp == "string" ? Math.min(this.path.length, position.path.length) : cmp;
    return this.path.slice(0, diffAt);
  }
  getCommonAncestor(position) {
    const ancestorsA = this.getAncestors();
    const ancestorsB = position.getAncestors();
    let i = 0;
    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
      i++;
    }
    return i === 0 ? null : ancestorsA[i - 1];
  }
  getShiftedBy(shift) {
    const shifted = this.clone();
    const offset = shifted.offset + shift;
    shifted.offset = offset < 0 ? 0 : offset;
    return shifted;
  }
  isAfter(otherPosition) {
    return this.compareWith(otherPosition) == "after";
  }
  isBefore(otherPosition) {
    return this.compareWith(otherPosition) == "before";
  }
  isEqual(otherPosition) {
    return this.compareWith(otherPosition) == "same";
  }
  isTouching(otherPosition) {
    if (this.root !== otherPosition.root) {
      return false;
    }
    const commonLevel = Math.min(this.path.length, otherPosition.path.length);
    for (let level = 0; level < commonLevel; level++) {
      const diff2 = this.path[level] - otherPosition.path[level];
      if (diff2 < -1 || diff2 > 1) {
        return false;
      } else if (diff2 === 1) {
        return checkTouchingBranch(otherPosition, this, level);
      } else if (diff2 === -1) {
        return checkTouchingBranch(this, otherPosition, level);
      }
    }
    if (this.path.length === otherPosition.path.length) {
      return true;
    } else if (this.path.length > otherPosition.path.length) {
      return checkOnlyZeroes(this.path, commonLevel);
    } else {
      return checkOnlyZeroes(otherPosition.path, commonLevel);
    }
  }
  hasSameParentAs(position) {
    if (this.root !== position.root) {
      return false;
    }
    const thisParentPath = this.getParentPath();
    const posParentPath = position.getParentPath();
    return compareArrays(thisParentPath, posParentPath) == "same";
  }
  getTransformedByOperation(operation) {
    let result;
    switch (operation.type) {
      case "insert":
        result = this._getTransformedByInsertOperation(operation);
        break;
      case "move":
      case "remove":
      case "reinsert":
        result = this._getTransformedByMoveOperation(operation);
        break;
      case "split":
        result = this._getTransformedBySplitOperation(operation);
        break;
      case "merge":
        result = this._getTransformedByMergeOperation(operation);
        break;
      default:
        result = Position2._createAt(this);
        break;
    }
    return result;
  }
  _getTransformedByInsertOperation(operation) {
    return this._getTransformedByInsertion(operation.position, operation.howMany);
  }
  _getTransformedByMoveOperation(operation) {
    return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);
  }
  _getTransformedBySplitOperation(operation) {
    const movedRange = operation.movedRange;
    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == "toNext";
    if (isContained) {
      return this._getCombined(operation.splitPosition, operation.moveTargetPosition);
    } else {
      if (operation.graveyardPosition) {
        return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);
      } else {
        return this._getTransformedByInsertion(operation.insertionPosition, 1);
      }
    }
  }
  _getTransformedByMergeOperation(operation) {
    const movedRange = operation.movedRange;
    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);
    let pos;
    if (isContained) {
      pos = this._getCombined(operation.sourcePosition, operation.targetPosition);
      if (operation.sourcePosition.isBefore(operation.targetPosition)) {
        pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);
      }
    } else if (this.isEqual(operation.deletionPosition)) {
      pos = Position2._createAt(operation.deletionPosition);
    } else {
      pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);
    }
    return pos;
  }
  _getTransformedByDeletion(deletePosition, howMany) {
    const transformed = Position2._createAt(this);
    if (this.root != deletePosition.root) {
      return transformed;
    }
    if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "same") {
      if (deletePosition.offset < this.offset) {
        if (deletePosition.offset + howMany > this.offset) {
          return null;
        } else {
          transformed.offset -= howMany;
        }
      }
    } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "prefix") {
      const i = deletePosition.path.length - 1;
      if (deletePosition.offset <= this.path[i]) {
        if (deletePosition.offset + howMany > this.path[i]) {
          return null;
        } else {
          transformed.path[i] -= howMany;
        }
      }
    }
    return transformed;
  }
  _getTransformedByInsertion(insertPosition, howMany) {
    const transformed = Position2._createAt(this);
    if (this.root != insertPosition.root) {
      return transformed;
    }
    if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "same") {
      if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != "toPrevious") {
        transformed.offset += howMany;
      }
    } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "prefix") {
      const i = insertPosition.path.length - 1;
      if (insertPosition.offset <= this.path[i]) {
        transformed.path[i] += howMany;
      }
    }
    return transformed;
  }
  _getTransformedByMove(sourcePosition, targetPosition, howMany) {
    targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
    if (sourcePosition.isEqual(targetPosition)) {
      return Position2._createAt(this);
    }
    const transformed = this._getTransformedByDeletion(sourcePosition, howMany);
    const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == "toNext" || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == "toPrevious";
    if (isMoved) {
      return this._getCombined(sourcePosition, targetPosition);
    } else {
      return transformed._getTransformedByInsertion(targetPosition, howMany);
    }
  }
  _getCombined(source, target) {
    const i = source.path.length - 1;
    const combined = Position2._createAt(target);
    combined.stickiness = this.stickiness;
    combined.offset = combined.offset + this.path[i] - source.offset;
    combined.path = [...combined.path, ...this.path.slice(i + 1)];
    return combined;
  }
  toJSON() {
    return {
      root: this.root.toJSON(),
      path: Array.from(this.path),
      stickiness: this.stickiness
    };
  }
  clone() {
    return new this.constructor(this.root, this.path, this.stickiness);
  }
  static _createAt(itemOrPosition, offset, stickiness = "toNone") {
    if (itemOrPosition instanceof Position2) {
      return new Position2(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);
    } else {
      const node = itemOrPosition;
      if (offset == "end") {
        offset = node.maxOffset;
      } else if (offset == "before") {
        return this._createBefore(node, stickiness);
      } else if (offset == "after") {
        return this._createAfter(node, stickiness);
      } else if (offset !== 0 && !offset) {
        throw new ckeditorerror_default("model-createpositionat-offset-required", [this, itemOrPosition]);
      }
      if (!node.is("element") && !node.is("documentFragment")) {
        throw new ckeditorerror_default("model-position-parent-incorrect", [this, itemOrPosition]);
      }
      const path = node.getPath();
      path.push(offset);
      return new this(node.root, path, stickiness);
    }
  }
  static _createAfter(item, stickiness) {
    if (!item.parent) {
      throw new ckeditorerror_default("model-position-after-root", [this, item], {root: item});
    }
    return this._createAt(item.parent, item.endOffset, stickiness);
  }
  static _createBefore(item, stickiness) {
    if (!item.parent) {
      throw new ckeditorerror_default("model-position-before-root", item, {root: item});
    }
    return this._createAt(item.parent, item.startOffset, stickiness);
  }
  static fromJSON(json, doc) {
    if (json.root === "$graveyard") {
      const pos = new Position2(doc.graveyard, json.path);
      pos.stickiness = json.stickiness;
      return pos;
    }
    if (!doc.getRoot(json.root)) {
      throw new ckeditorerror_default("model-position-fromjson-no-root", doc, {rootName: json.root});
    }
    return new Position2(doc.getRoot(json.root), json.path, json.stickiness);
  }
};
var position_default2 = Position2;
Position2.prototype.is = function(type) {
  return type === "position" || type === "model:position";
};
function getTextNodeAtPosition(position, positionParent) {
  const node = positionParent.getChild(positionParent.offsetToIndex(position.offset));
  if (node && node.is("$text") && node.startOffset < position.offset) {
    return node;
  }
  return null;
}
function getNodeAfterPosition(position, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }
  return positionParent.getChild(positionParent.offsetToIndex(position.offset));
}
function getNodeBeforePosition(position, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }
  return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);
}
function checkTouchingBranch(left, right, level) {
  if (level + 1 === left.path.length) {
    return false;
  }
  if (!checkOnlyZeroes(right.path, level + 1)) {
    return false;
  }
  if (!checkOnlyMaxOffset(left, level + 1)) {
    return false;
  }
  return true;
}
function checkOnlyZeroes(arr, idx) {
  while (idx < arr.length) {
    if (arr[idx] !== 0) {
      return false;
    }
    idx++;
  }
  return true;
}
function checkOnlyMaxOffset(pos, level) {
  let parent2 = pos.parent;
  let idx = pos.path.length - 1;
  let add = 0;
  while (idx >= level) {
    if (pos.path[idx] + add !== parent2.maxOffset) {
      return false;
    }
    add = 1;
    idx--;
    parent2 = parent2.parent;
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/range.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Range2 = class extends typecheckable_default2 {
  constructor(start, end) {
    super();
    this.start = position_default2._createAt(start);
    this.end = end ? position_default2._createAt(end) : position_default2._createAt(start);
    this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
    this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
  }
  *[Symbol.iterator]() {
    yield* new treewalker_default2({boundaries: this, ignoreElementEnd: true});
  }
  get isCollapsed() {
    return this.start.isEqual(this.end);
  }
  get isFlat() {
    const startParentPath = this.start.getParentPath();
    const endParentPath = this.end.getParentPath();
    return compareArrays(startParentPath, endParentPath) == "same";
  }
  get root() {
    return this.start.root;
  }
  containsPosition(position) {
    return position.isAfter(this.start) && position.isBefore(this.end);
  }
  containsRange(otherRange, loose = false) {
    if (otherRange.isCollapsed) {
      loose = false;
    }
    const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
    const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
    return containsStart && containsEnd;
  }
  containsItem(item) {
    const pos = position_default2._createBefore(item);
    return this.containsPosition(pos) || this.start.isEqual(pos);
  }
  isEqual(otherRange) {
    return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
  }
  isIntersecting(otherRange) {
    return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
  }
  getDifference(otherRange) {
    const ranges = [];
    if (this.isIntersecting(otherRange)) {
      if (this.containsPosition(otherRange.start)) {
        ranges.push(new Range2(this.start, otherRange.start));
      }
      if (this.containsPosition(otherRange.end)) {
        ranges.push(new Range2(otherRange.end, this.end));
      }
    } else {
      ranges.push(new Range2(this.start, this.end));
    }
    return ranges;
  }
  getIntersection(otherRange) {
    if (this.isIntersecting(otherRange)) {
      let commonRangeStart = this.start;
      let commonRangeEnd = this.end;
      if (this.containsPosition(otherRange.start)) {
        commonRangeStart = otherRange.start;
      }
      if (this.containsPosition(otherRange.end)) {
        commonRangeEnd = otherRange.end;
      }
      return new Range2(commonRangeStart, commonRangeEnd);
    }
    return null;
  }
  getJoined(otherRange, loose = false) {
    let shouldJoin = this.isIntersecting(otherRange);
    if (!shouldJoin) {
      if (this.start.isBefore(otherRange.start)) {
        shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);
      } else {
        shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);
      }
    }
    if (!shouldJoin) {
      return null;
    }
    let startPosition = this.start;
    let endPosition = this.end;
    if (otherRange.start.isBefore(startPosition)) {
      startPosition = otherRange.start;
    }
    if (otherRange.end.isAfter(endPosition)) {
      endPosition = otherRange.end;
    }
    return new Range2(startPosition, endPosition);
  }
  getMinimalFlatRanges() {
    const ranges = [];
    const diffAt = this.start.getCommonPath(this.end).length;
    const pos = position_default2._createAt(this.start);
    let posParent = pos.parent;
    while (pos.path.length > diffAt + 1) {
      const howMany = posParent.maxOffset - pos.offset;
      if (howMany !== 0) {
        ranges.push(new Range2(pos, pos.getShiftedBy(howMany)));
      }
      pos.path = pos.path.slice(0, -1);
      pos.offset++;
      posParent = posParent.parent;
    }
    while (pos.path.length <= this.end.path.length) {
      const offset = this.end.path[pos.path.length - 1];
      const howMany = offset - pos.offset;
      if (howMany !== 0) {
        ranges.push(new Range2(pos, pos.getShiftedBy(howMany)));
      }
      pos.offset = offset;
      pos.path.push(0);
    }
    return ranges;
  }
  getWalker(options = {}) {
    options.boundaries = this;
    return new treewalker_default2(options);
  }
  *getItems(options = {}) {
    options.boundaries = this;
    options.ignoreElementEnd = true;
    const treeWalker = new treewalker_default2(options);
    for (const value of treeWalker) {
      yield value.item;
    }
  }
  *getPositions(options = {}) {
    options.boundaries = this;
    const treeWalker = new treewalker_default2(options);
    yield treeWalker.position;
    for (const value of treeWalker) {
      yield value.nextPosition;
    }
  }
  getTransformedByOperation(operation) {
    switch (operation.type) {
      case "insert":
        return this._getTransformedByInsertOperation(operation);
      case "move":
      case "remove":
      case "reinsert":
        return this._getTransformedByMoveOperation(operation);
      case "split":
        return [this._getTransformedBySplitOperation(operation)];
      case "merge":
        return [this._getTransformedByMergeOperation(operation)];
    }
    return [new Range2(this.start, this.end)];
  }
  getTransformedByOperations(operations2) {
    const ranges = [new Range2(this.start, this.end)];
    for (const operation of operations2) {
      for (let i = 0; i < ranges.length; i++) {
        const result = ranges[i].getTransformedByOperation(operation);
        ranges.splice(i, 1, ...result);
        i += result.length - 1;
      }
    }
    for (let i = 0; i < ranges.length; i++) {
      const range = ranges[i];
      for (let j = i + 1; j < ranges.length; j++) {
        const next = ranges[j];
        if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {
          ranges.splice(j, 1);
        }
      }
    }
    return ranges;
  }
  getCommonAncestor() {
    return this.start.getCommonAncestor(this.end);
  }
  getContainedElement() {
    if (this.isCollapsed) {
      return null;
    }
    const nodeAfterStart = this.start.nodeAfter;
    const nodeBeforeEnd = this.end.nodeBefore;
    if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
      return nodeAfterStart;
    }
    return null;
  }
  toJSON() {
    return {
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  clone() {
    return new this.constructor(this.start, this.end);
  }
  _getTransformedByInsertOperation(operation, spread = false) {
    return this._getTransformedByInsertion(operation.position, operation.howMany, spread);
  }
  _getTransformedByMoveOperation(operation, spread = false) {
    const sourcePosition = operation.sourcePosition;
    const howMany = operation.howMany;
    const targetPosition = operation.targetPosition;
    return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);
  }
  _getTransformedBySplitOperation(operation) {
    const start = this.start._getTransformedBySplitOperation(operation);
    let end = this.end._getTransformedBySplitOperation(operation);
    if (this.end.isEqual(operation.insertionPosition)) {
      end = this.end.getShiftedBy(1);
    }
    if (start.root != end.root) {
      end = this.end.getShiftedBy(-1);
    }
    return new Range2(start, end);
  }
  _getTransformedByMergeOperation(operation) {
    if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {
      return new Range2(this.start);
    }
    let start = this.start._getTransformedByMergeOperation(operation);
    let end = this.end._getTransformedByMergeOperation(operation);
    if (start.root != end.root) {
      end = this.end.getShiftedBy(-1);
    }
    if (start.isAfter(end)) {
      if (operation.sourcePosition.isBefore(operation.targetPosition)) {
        start = position_default2._createAt(end);
        start.offset = 0;
      } else {
        if (!operation.deletionPosition.isEqual(start)) {
          end = operation.deletionPosition;
        }
        start = operation.targetPosition;
      }
      return new Range2(start, end);
    }
    return new Range2(start, end);
  }
  _getTransformedByInsertion(insertPosition, howMany, spread = false) {
    if (spread && this.containsPosition(insertPosition)) {
      return [
        new Range2(this.start, insertPosition),
        new Range2(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))
      ];
    } else {
      const range = new Range2(this.start, this.end);
      range.start = range.start._getTransformedByInsertion(insertPosition, howMany);
      range.end = range.end._getTransformedByInsertion(insertPosition, howMany);
      return [range];
    }
  }
  _getTransformedByMove(sourcePosition, targetPosition, howMany, spread = false) {
    if (this.isCollapsed) {
      const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
      return [new Range2(newPos)];
    }
    const moveRange = Range2._createFromPositionAndShift(sourcePosition, howMany);
    const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
    if (this.containsPosition(targetPosition) && !spread) {
      if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {
        const start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
        const end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);
        return [new Range2(start, end)];
      }
    }
    let result;
    const differenceSet = this.getDifference(moveRange);
    let difference = null;
    const common = this.getIntersection(moveRange);
    if (differenceSet.length == 1) {
      difference = new Range2(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));
    } else if (differenceSet.length == 2) {
      difference = new Range2(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));
    }
    if (difference) {
      result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);
    } else {
      result = [];
    }
    if (common) {
      const transformedCommon = new Range2(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));
      if (result.length == 2) {
        result.splice(1, 0, transformedCommon);
      } else {
        result.push(transformedCommon);
      }
    }
    return result;
  }
  _getTransformedByDeletion(deletePosition, howMany) {
    let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);
    let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);
    if (newStart == null && newEnd == null) {
      return null;
    }
    if (newStart == null) {
      newStart = deletePosition;
    }
    if (newEnd == null) {
      newEnd = deletePosition;
    }
    return new Range2(newStart, newEnd);
  }
  static _createFromPositionAndShift(position, shift) {
    const start = position;
    const end = position.getShiftedBy(shift);
    return shift > 0 ? new this(start, end) : new this(end, start);
  }
  static _createIn(element) {
    return new this(position_default2._createAt(element, 0), position_default2._createAt(element, element.maxOffset));
  }
  static _createOn(item) {
    return this._createFromPositionAndShift(position_default2._createBefore(item), item.offsetSize);
  }
  static _createFromRanges(ranges) {
    if (ranges.length === 0) {
      throw new ckeditorerror_default("range-create-from-ranges-empty-array", null);
    } else if (ranges.length == 1) {
      return ranges[0].clone();
    }
    const ref = ranges[0];
    ranges.sort((a, b) => {
      return a.start.isAfter(b.start) ? 1 : -1;
    });
    const refIndex = ranges.indexOf(ref);
    const result = new this(ref.start, ref.end);
    if (refIndex > 0) {
      for (let i = refIndex - 1; true; i++) {
        if (ranges[i].end.isEqual(result.start)) {
          result.start = position_default2._createAt(ranges[i].start);
        } else {
          break;
        }
      }
    }
    for (let i = refIndex + 1; i < ranges.length; i++) {
      if (ranges[i].start.isEqual(result.end)) {
        result.end = position_default2._createAt(ranges[i].end);
      } else {
        break;
      }
    }
    return result;
  }
  static fromJSON(json, doc) {
    return new this(position_default2.fromJSON(json.start, doc), position_default2.fromJSON(json.end, doc));
  }
};
var range_default2 = Range2;
Range2.prototype.is = function(type) {
  return type === "range" || type === "model:range";
};

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Mapper = class extends EmitterMixin() {
  constructor() {
    super();
    this._modelToViewMapping = new WeakMap();
    this._viewToModelMapping = new WeakMap();
    this._viewToModelLengthCallbacks = new Map();
    this._markerNameToElements = new Map();
    this._elementToMarkerNames = new Map();
    this._deferredBindingRemovals = new Map();
    this._unboundMarkerNames = new Set();
    this.on("modelToViewPosition", (evt, data) => {
      if (data.viewPosition) {
        return;
      }
      const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);
      if (!viewContainer) {
        throw new ckeditorerror_default("mapping-model-position-view-parent-not-found", this, {modelPosition: data.modelPosition});
      }
      data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);
    }, {priority: "low"});
    this.on("viewToModelPosition", (evt, data) => {
      if (data.modelPosition) {
        return;
      }
      const viewBlock = this.findMappedViewAncestor(data.viewPosition);
      const modelParent = this._viewToModelMapping.get(viewBlock);
      const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);
      data.modelPosition = position_default2._createAt(modelParent, modelOffset);
    }, {priority: "low"});
  }
  bindElements(modelElement, viewElement) {
    this._modelToViewMapping.set(modelElement, viewElement);
    this._viewToModelMapping.set(viewElement, modelElement);
  }
  unbindViewElement(viewElement, options = {}) {
    const modelElement = this.toModelElement(viewElement);
    if (this._elementToMarkerNames.has(viewElement)) {
      for (const markerName of this._elementToMarkerNames.get(viewElement)) {
        this._unboundMarkerNames.add(markerName);
      }
    }
    if (options.defer) {
      this._deferredBindingRemovals.set(viewElement, viewElement.root);
    } else {
      this._viewToModelMapping.delete(viewElement);
      if (this._modelToViewMapping.get(modelElement) == viewElement) {
        this._modelToViewMapping.delete(modelElement);
      }
    }
  }
  unbindModelElement(modelElement) {
    const viewElement = this.toViewElement(modelElement);
    this._modelToViewMapping.delete(modelElement);
    if (this._viewToModelMapping.get(viewElement) == modelElement) {
      this._viewToModelMapping.delete(viewElement);
    }
  }
  bindElementToMarker(element, name) {
    const elements = this._markerNameToElements.get(name) || new Set();
    elements.add(element);
    const names = this._elementToMarkerNames.get(element) || new Set();
    names.add(name);
    this._markerNameToElements.set(name, elements);
    this._elementToMarkerNames.set(element, names);
  }
  unbindElementFromMarkerName(element, name) {
    const nameToElements = this._markerNameToElements.get(name);
    if (nameToElements) {
      nameToElements.delete(element);
      if (nameToElements.size == 0) {
        this._markerNameToElements.delete(name);
      }
    }
    const elementToNames = this._elementToMarkerNames.get(element);
    if (elementToNames) {
      elementToNames.delete(name);
      if (elementToNames.size == 0) {
        this._elementToMarkerNames.delete(element);
      }
    }
  }
  flushUnboundMarkerNames() {
    const markerNames = Array.from(this._unboundMarkerNames);
    this._unboundMarkerNames.clear();
    return markerNames;
  }
  flushDeferredBindings() {
    for (const [viewElement, root2] of this._deferredBindingRemovals) {
      if (viewElement.root == root2) {
        this.unbindViewElement(viewElement);
      }
    }
    this._deferredBindingRemovals = new Map();
  }
  clearBindings() {
    this._modelToViewMapping = new WeakMap();
    this._viewToModelMapping = new WeakMap();
    this._markerNameToElements = new Map();
    this._elementToMarkerNames = new Map();
    this._unboundMarkerNames = new Set();
    this._deferredBindingRemovals = new Map();
  }
  toModelElement(viewElement) {
    return this._viewToModelMapping.get(viewElement);
  }
  toViewElement(modelElement) {
    return this._modelToViewMapping.get(modelElement);
  }
  toModelRange(viewRange) {
    return new range_default2(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
  }
  toViewRange(modelRange) {
    return new range_default(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
  }
  toModelPosition(viewPosition) {
    const data = {
      viewPosition,
      mapper: this
    };
    this.fire("viewToModelPosition", data);
    return data.modelPosition;
  }
  toViewPosition(modelPosition, options = {}) {
    const data = {
      modelPosition,
      mapper: this,
      isPhantom: options.isPhantom
    };
    this.fire("modelToViewPosition", data);
    return data.viewPosition;
  }
  markerNameToElements(name) {
    const boundElements = this._markerNameToElements.get(name);
    if (!boundElements) {
      return null;
    }
    const elements = new Set();
    for (const element of boundElements) {
      if (element.is("attributeElement")) {
        for (const clone3 of element.getElementsWithSameId()) {
          elements.add(clone3);
        }
      } else {
        elements.add(element);
      }
    }
    return elements;
  }
  registerViewToModelLength(viewElementName, lengthCallback) {
    this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);
  }
  findMappedViewAncestor(viewPosition) {
    let parent2 = viewPosition.parent;
    while (!this._viewToModelMapping.has(parent2)) {
      parent2 = parent2.parent;
    }
    return parent2;
  }
  _toModelOffset(viewParent, viewOffset, viewBlock) {
    if (viewBlock != viewParent) {
      const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);
      const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);
      return offsetToParentStart + offsetInParent;
    }
    if (viewParent.is("$text")) {
      return viewOffset;
    }
    let modelOffset = 0;
    for (let i = 0; i < viewOffset; i++) {
      modelOffset += this.getModelLength(viewParent.getChild(i));
    }
    return modelOffset;
  }
  getModelLength(viewNode) {
    if (this._viewToModelLengthCallbacks.get(viewNode.name)) {
      const callback = this._viewToModelLengthCallbacks.get(viewNode.name);
      return callback(viewNode);
    } else if (this._viewToModelMapping.has(viewNode)) {
      return 1;
    } else if (viewNode.is("$text")) {
      return viewNode.data.length;
    } else if (viewNode.is("uiElement")) {
      return 0;
    } else {
      let len = 0;
      for (const child of viewNode.getChildren()) {
        len += this.getModelLength(child);
      }
      return len;
    }
  }
  findPositionIn(viewParent, expectedOffset) {
    let viewNode;
    let lastLength = 0;
    let modelOffset = 0;
    let viewOffset = 0;
    if (viewParent.is("$text")) {
      return new position_default(viewParent, expectedOffset);
    }
    while (modelOffset < expectedOffset) {
      viewNode = viewParent.getChild(viewOffset);
      lastLength = this.getModelLength(viewNode);
      modelOffset += lastLength;
      viewOffset++;
    }
    if (modelOffset == expectedOffset) {
      return this._moveViewPositionToTextNode(new position_default(viewParent, viewOffset));
    } else {
      return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));
    }
  }
  _moveViewPositionToTextNode(viewPosition) {
    const nodeBefore = viewPosition.nodeBefore;
    const nodeAfter = viewPosition.nodeAfter;
    if (nodeBefore instanceof text_default) {
      return new position_default(nodeBefore, nodeBefore.data.length);
    } else if (nodeAfter instanceof text_default) {
      return new position_default(nodeAfter, 0);
    }
    return viewPosition;
  }
};
var mapper_default = Mapper;

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ModelConsumable = class {
  constructor() {
    this._consumable = new Map();
    this._textProxyRegistry = new Map();
  }
  add(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof textproxy_default2) {
      item = this._getSymbolForTextProxy(item);
    }
    if (!this._consumable.has(item)) {
      this._consumable.set(item, new Map());
    }
    this._consumable.get(item).set(type, true);
  }
  consume(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof textproxy_default2) {
      item = this._getSymbolForTextProxy(item);
    }
    if (this.test(item, type)) {
      this._consumable.get(item).set(type, false);
      return true;
    } else {
      return false;
    }
  }
  test(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof textproxy_default2) {
      item = this._getSymbolForTextProxy(item);
    }
    const itemConsumables = this._consumable.get(item);
    if (itemConsumables === void 0) {
      return null;
    }
    const value = itemConsumables.get(type);
    if (value === void 0) {
      return null;
    }
    return value;
  }
  revert(item, type) {
    type = _normalizeConsumableType(type);
    if (item instanceof textproxy_default2) {
      item = this._getSymbolForTextProxy(item);
    }
    const test = this.test(item, type);
    if (test === false) {
      this._consumable.get(item).set(type, true);
      return true;
    } else if (test === true) {
      return false;
    }
    return null;
  }
  verifyAllConsumed(eventGroup) {
    const items = [];
    for (const [item, consumables] of this._consumable) {
      for (const [event, canConsume] of consumables) {
        const eventPrefix = event.split(":")[0];
        if (canConsume && eventGroup == eventPrefix) {
          items.push({
            event,
            item: item.name || item.description
          });
        }
      }
    }
    if (items.length) {
      throw new ckeditorerror_default("conversion-model-consumable-not-consumed", null, {items});
    }
  }
  _getSymbolForTextProxy(textProxy) {
    let symbol = null;
    const startMap = this._textProxyRegistry.get(textProxy.startOffset);
    if (startMap) {
      const endMap = startMap.get(textProxy.endOffset);
      if (endMap) {
        symbol = endMap.get(textProxy.parent);
      }
    }
    if (!symbol) {
      symbol = this._addSymbolForTextProxy(textProxy);
    }
    return symbol;
  }
  _addSymbolForTextProxy(textProxy) {
    const start = textProxy.startOffset;
    const end = textProxy.endOffset;
    const parent2 = textProxy.parent;
    const symbol = Symbol("$textProxy:" + textProxy.data);
    let startMap;
    let endMap;
    startMap = this._textProxyRegistry.get(start);
    if (!startMap) {
      startMap = new Map();
      this._textProxyRegistry.set(start, startMap);
    }
    endMap = startMap.get(end);
    if (!endMap) {
      endMap = new Map();
      startMap.set(end, endMap);
    }
    endMap.set(parent2, symbol);
    return symbol;
  }
};
var modelconsumable_default = ModelConsumable;
function _normalizeConsumableType(type) {
  const parts = type.split(":");
  if (parts[0] == "insert") {
    return parts[0];
  }
  if (parts[0] == "addMarker" || parts[0] == "removeMarker") {
    return type;
  }
  return parts.length > 1 ? parts[0] + ":" + parts[1] : parts[0];
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DowncastDispatcher = class extends EmitterMixin() {
  constructor(conversionApi) {
    super();
    this._conversionApi = {dispatcher: this, ...conversionApi};
    this._firedEventsMap = new WeakMap();
  }
  convertChanges(differ, markers, writer) {
    const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems());
    for (const change of differ.getMarkersToRemove()) {
      this._convertMarkerRemove(change.name, change.range, conversionApi);
    }
    const changes = this._reduceChanges(differ.getChanges());
    for (const entry of changes) {
      if (entry.type === "insert") {
        this._convertInsert(range_default2._createFromPositionAndShift(entry.position, entry.length), conversionApi);
      } else if (entry.type === "reinsert") {
        this._convertReinsert(range_default2._createFromPositionAndShift(entry.position, entry.length), conversionApi);
      } else if (entry.type === "remove") {
        this._convertRemove(entry.position, entry.length, entry.name, conversionApi);
      } else {
        this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);
      }
    }
    for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {
      const markerRange = markers.get(markerName).getRange();
      this._convertMarkerRemove(markerName, markerRange, conversionApi);
      this._convertMarkerAdd(markerName, markerRange, conversionApi);
    }
    for (const change of differ.getMarkersToAdd()) {
      this._convertMarkerAdd(change.name, change.range, conversionApi);
    }
    conversionApi.mapper.flushDeferredBindings();
    conversionApi.consumable.verifyAllConsumed("insert");
  }
  convert(range, markers, writer, options = {}) {
    const conversionApi = this._createConversionApi(writer, void 0, options);
    this._convertInsert(range, conversionApi);
    for (const [name, range2] of markers) {
      this._convertMarkerAdd(name, range2, conversionApi);
    }
    conversionApi.consumable.verifyAllConsumed("insert");
  }
  convertSelection(selection, markers, writer) {
    const conversionApi = this._createConversionApi(writer);
    this.fire("cleanSelection", {selection}, conversionApi);
    const modelRoot = selection.getFirstPosition().root;
    if (!conversionApi.mapper.toViewElement(modelRoot)) {
      return;
    }
    const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));
    this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);
    this.fire("selection", {selection}, conversionApi);
    if (!selection.isCollapsed) {
      return;
    }
    for (const marker of markersAtSelection) {
      if (conversionApi.consumable.test(selection, "addMarker:" + marker.name)) {
        const markerRange = marker.getRange();
        if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {
          continue;
        }
        const data = {
          item: selection,
          markerName: marker.name,
          markerRange
        };
        this.fire(`addMarker:${marker.name}`, data, conversionApi);
      }
    }
    for (const key of selection.getAttributeKeys()) {
      if (conversionApi.consumable.test(selection, "attribute:" + key)) {
        const data = {
          item: selection,
          range: selection.getFirstRange(),
          attributeKey: key,
          attributeOldValue: null,
          attributeNewValue: selection.getAttribute(key)
        };
        this.fire(`attribute:${key}:$text`, data, conversionApi);
      }
    }
  }
  _convertInsert(range, conversionApi, options = {}) {
    if (!options.doNotAddConsumables) {
      this._addConsumablesForInsert(conversionApi.consumable, Array.from(range));
    }
    for (const data of Array.from(range.getWalker({shallow: true})).map(walkerValueToEventData)) {
      this._testAndFire("insert", data, conversionApi);
    }
  }
  _convertRemove(position, length, name, conversionApi) {
    this.fire(`remove:${name}`, {position, length}, conversionApi);
  }
  _convertAttribute(range, key, oldValue, newValue, conversionApi) {
    this._addConsumablesForRange(conversionApi.consumable, range, `attribute:${key}`);
    for (const value of range) {
      const data = {
        item: value.item,
        range: range_default2._createFromPositionAndShift(value.previousPosition, value.length),
        attributeKey: key,
        attributeOldValue: oldValue,
        attributeNewValue: newValue
      };
      this._testAndFire(`attribute:${key}`, data, conversionApi);
    }
  }
  _convertReinsert(range, conversionApi) {
    const walkerValues = Array.from(range.getWalker({shallow: true}));
    this._addConsumablesForInsert(conversionApi.consumable, walkerValues);
    for (const data of walkerValues.map(walkerValueToEventData)) {
      this._testAndFire("insert", {...data, reconversion: true}, conversionApi);
    }
  }
  _convertMarkerAdd(markerName, markerRange, conversionApi) {
    if (markerRange.root.rootName == "$graveyard") {
      return;
    }
    const eventName = `addMarker:${markerName}`;
    conversionApi.consumable.add(markerRange, eventName);
    this.fire(eventName, {markerName, markerRange}, conversionApi);
    if (!conversionApi.consumable.consume(markerRange, eventName)) {
      return;
    }
    this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);
    for (const item of markerRange.getItems()) {
      if (!conversionApi.consumable.test(item, eventName)) {
        continue;
      }
      const data = {item, range: range_default2._createOn(item), markerName, markerRange};
      this.fire(eventName, data, conversionApi);
    }
  }
  _convertMarkerRemove(markerName, markerRange, conversionApi) {
    if (markerRange.root.rootName == "$graveyard") {
      return;
    }
    this.fire(`removeMarker:${markerName}`, {markerName, markerRange}, conversionApi);
  }
  _reduceChanges(changes) {
    const data = {changes};
    this.fire("reduceChanges", data);
    return data.changes;
  }
  _addConsumablesForInsert(consumable, walkerValues) {
    for (const value of walkerValues) {
      const item = value.item;
      if (consumable.test(item, "insert") === null) {
        consumable.add(item, "insert");
        for (const key of item.getAttributeKeys()) {
          consumable.add(item, "attribute:" + key);
        }
      }
    }
    return consumable;
  }
  _addConsumablesForRange(consumable, range, type) {
    for (const item of range.getItems()) {
      consumable.add(item, type);
    }
    return consumable;
  }
  _addConsumablesForSelection(consumable, selection, markers) {
    consumable.add(selection, "selection");
    for (const marker of markers) {
      consumable.add(selection, "addMarker:" + marker.name);
    }
    for (const key of selection.getAttributeKeys()) {
      consumable.add(selection, "attribute:" + key);
    }
    return consumable;
  }
  _testAndFire(type, data, conversionApi) {
    const eventName = getEventName(type, data);
    const itemKey = data.item.is("$textProxy") ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;
    const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);
    const eventsFiredForItem = eventsFiredForConversion.get(itemKey);
    if (!eventsFiredForItem) {
      eventsFiredForConversion.set(itemKey, new Set([eventName]));
    } else if (!eventsFiredForItem.has(eventName)) {
      eventsFiredForItem.add(eventName);
    } else {
      return;
    }
    this.fire(eventName, data, conversionApi);
  }
  _testAndFireAddAttributes(item, conversionApi) {
    const data = {
      item,
      range: range_default2._createOn(item)
    };
    for (const key of data.item.getAttributeKeys()) {
      data.attributeKey = key;
      data.attributeOldValue = null;
      data.attributeNewValue = data.item.getAttribute(key);
      this._testAndFire(`attribute:${key}`, data, conversionApi);
    }
  }
  _createConversionApi(writer, refreshedItems = new Set(), options = {}) {
    const conversionApi = {
      ...this._conversionApi,
      consumable: new modelconsumable_default(),
      writer,
      options,
      convertItem: (item) => this._convertInsert(range_default2._createOn(item), conversionApi),
      convertChildren: (element) => this._convertInsert(range_default2._createIn(element), conversionApi, {doNotAddConsumables: true}),
      convertAttributes: (item) => this._testAndFireAddAttributes(item, conversionApi),
      canReuseView: (viewElement) => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))
    };
    this._firedEventsMap.set(conversionApi, new Map());
    return conversionApi;
  }
};
var downcastdispatcher_default = DowncastDispatcher;
function shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {
  const range = marker.getRange();
  const ancestors = Array.from(modelPosition.getAncestors());
  ancestors.shift();
  ancestors.reverse();
  const hasCustomHandling = ancestors.some((element) => {
    if (range.containsItem(element)) {
      const viewElement = mapper.toViewElement(element);
      return !!viewElement.getCustomProperty("addHighlight");
    }
  });
  return !hasCustomHandling;
}
function getEventName(type, data) {
  const name = data.item.is("element") ? data.item.name : "$text";
  return `${type}:${name}`;
}
function walkerValueToEventData(value) {
  const item = value.item;
  const itemRange = range_default2._createFromPositionAndShift(value.previousPosition, value.length);
  return {
    item,
    range: itemRange
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/selection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Selection2 = class extends EmitterMixin(typecheckable_default2) {
  constructor(...args) {
    super();
    this._lastRangeBackward = false;
    this._attrs = new Map();
    this._ranges = [];
    if (args.length) {
      this.setTo(...args);
    }
  }
  get anchor() {
    if (this._ranges.length > 0) {
      const range = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? range.end : range.start;
    }
    return null;
  }
  get focus() {
    if (this._ranges.length > 0) {
      const range = this._ranges[this._ranges.length - 1];
      return this._lastRangeBackward ? range.start : range.end;
    }
    return null;
  }
  get isCollapsed() {
    const length = this._ranges.length;
    if (length === 1) {
      return this._ranges[0].isCollapsed;
    } else {
      return false;
    }
  }
  get rangeCount() {
    return this._ranges.length;
  }
  get isBackward() {
    return !this.isCollapsed && this._lastRangeBackward;
  }
  isEqual(otherSelection) {
    if (this.rangeCount != otherSelection.rangeCount) {
      return false;
    } else if (this.rangeCount === 0) {
      return true;
    }
    if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
      return false;
    }
    for (const thisRange of this._ranges) {
      let found = false;
      for (const otherRange of otherSelection._ranges) {
        if (thisRange.isEqual(otherRange)) {
          found = true;
          break;
        }
      }
      if (!found) {
        return false;
      }
    }
    return true;
  }
  *getRanges() {
    for (const range of this._ranges) {
      yield new range_default2(range.start, range.end);
    }
  }
  getFirstRange() {
    let first2 = null;
    for (const range of this._ranges) {
      if (!first2 || range.start.isBefore(first2.start)) {
        first2 = range;
      }
    }
    return first2 ? new range_default2(first2.start, first2.end) : null;
  }
  getLastRange() {
    let last2 = null;
    for (const range of this._ranges) {
      if (!last2 || range.end.isAfter(last2.end)) {
        last2 = range;
      }
    }
    return last2 ? new range_default2(last2.start, last2.end) : null;
  }
  getFirstPosition() {
    const first2 = this.getFirstRange();
    return first2 ? first2.start.clone() : null;
  }
  getLastPosition() {
    const lastRange = this.getLastRange();
    return lastRange ? lastRange.end.clone() : null;
  }
  setTo(...args) {
    let [selectable, placeOrOffset, options] = args;
    if (typeof placeOrOffset == "object") {
      options = placeOrOffset;
      placeOrOffset = void 0;
    }
    if (selectable === null) {
      this._setRanges([]);
    } else if (selectable instanceof Selection2) {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
    } else if (selectable && typeof selectable.getRanges == "function") {
      this._setRanges(selectable.getRanges(), selectable.isBackward);
    } else if (selectable instanceof range_default2) {
      this._setRanges([selectable], !!options && !!options.backward);
    } else if (selectable instanceof position_default2) {
      this._setRanges([new range_default2(selectable)]);
    } else if (selectable instanceof node_default2) {
      const backward = !!options && !!options.backward;
      let range;
      if (placeOrOffset == "in") {
        range = range_default2._createIn(selectable);
      } else if (placeOrOffset == "on") {
        range = range_default2._createOn(selectable);
      } else if (placeOrOffset !== void 0) {
        range = new range_default2(position_default2._createAt(selectable, placeOrOffset));
      } else {
        throw new ckeditorerror_default("model-selection-setto-required-second-parameter", [this, selectable]);
      }
      this._setRanges([range], backward);
    } else if (isIterable(selectable)) {
      this._setRanges(selectable, options && !!options.backward);
    } else {
      throw new ckeditorerror_default("model-selection-setto-not-selectable", [this, selectable]);
    }
  }
  _setRanges(newRanges, isLastBackward = false) {
    const ranges = Array.from(newRanges);
    const anyNewRange = ranges.some((newRange) => {
      if (!(newRange instanceof range_default2)) {
        throw new ckeditorerror_default("model-selection-set-ranges-not-range", [this, newRanges]);
      }
      return this._ranges.every((oldRange) => {
        return !oldRange.isEqual(newRange);
      });
    });
    if (ranges.length === this._ranges.length && !anyNewRange) {
      return;
    }
    this._replaceAllRanges(ranges);
    this._lastRangeBackward = !!isLastBackward;
    this.fire("change:range", {directChange: true});
  }
  setFocus(itemOrPosition, offset) {
    if (this.anchor === null) {
      throw new ckeditorerror_default("model-selection-setfocus-no-ranges", [this, itemOrPosition]);
    }
    const newFocus = position_default2._createAt(itemOrPosition, offset);
    if (newFocus.compareWith(this.focus) == "same") {
      return;
    }
    const anchor = this.anchor;
    if (this._ranges.length) {
      this._popRange();
    }
    if (newFocus.compareWith(anchor) == "before") {
      this._pushRange(new range_default2(newFocus, anchor));
      this._lastRangeBackward = true;
    } else {
      this._pushRange(new range_default2(anchor, newFocus));
      this._lastRangeBackward = false;
    }
    this.fire("change:range", {directChange: true});
  }
  getAttribute(key) {
    return this._attrs.get(key);
  }
  getAttributes() {
    return this._attrs.entries();
  }
  getAttributeKeys() {
    return this._attrs.keys();
  }
  hasAttribute(key) {
    return this._attrs.has(key);
  }
  removeAttribute(key) {
    if (this.hasAttribute(key)) {
      this._attrs.delete(key);
      this.fire("change:attribute", {attributeKeys: [key], directChange: true});
    }
  }
  setAttribute(key, value) {
    if (this.getAttribute(key) !== value) {
      this._attrs.set(key, value);
      this.fire("change:attribute", {attributeKeys: [key], directChange: true});
    }
  }
  getSelectedElement() {
    if (this.rangeCount !== 1) {
      return null;
    }
    return this.getFirstRange().getContainedElement();
  }
  *getSelectedBlocks() {
    const visited = new WeakSet();
    for (const range of this.getRanges()) {
      const startBlock = getParentBlock(range.start, visited);
      if (isStartBlockSelected(startBlock, range)) {
        yield startBlock;
      }
      for (const value of range.getWalker()) {
        const block = value.item;
        if (value.type == "elementEnd" && isUnvisitedTopBlock(block, visited, range)) {
          yield block;
        }
      }
      const endBlock = getParentBlock(range.end, visited);
      if (isEndBlockSelected(endBlock, range)) {
        yield endBlock;
      }
    }
  }
  containsEntireContent(element = this.anchor.root) {
    const limitStartPosition = position_default2._createAt(element, 0);
    const limitEndPosition = position_default2._createAt(element, "end");
    return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());
  }
  _pushRange(range) {
    this._checkRange(range);
    this._ranges.push(new range_default2(range.start, range.end));
  }
  _checkRange(range) {
    for (let i = 0; i < this._ranges.length; i++) {
      if (range.isIntersecting(this._ranges[i])) {
        throw new ckeditorerror_default("model-selection-range-intersects", [this, range], {addedRange: range, intersectingRange: this._ranges[i]});
      }
    }
  }
  _replaceAllRanges(ranges) {
    this._removeAllRanges();
    for (const range of ranges) {
      this._pushRange(range);
    }
  }
  _removeAllRanges() {
    while (this._ranges.length > 0) {
      this._popRange();
    }
  }
  _popRange() {
    this._ranges.pop();
  }
};
var selection_default2 = Selection2;
Selection2.prototype.is = function(type) {
  return type === "selection" || type === "model:selection";
};
function isUnvisitedBlock(element, visited) {
  if (visited.has(element)) {
    return false;
  }
  visited.add(element);
  return element.root.document.model.schema.isBlock(element) && !!element.parent;
}
function isUnvisitedTopBlock(element, visited, range) {
  return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);
}
function getParentBlock(position, visited) {
  const element = position.parent;
  const schema = element.root.document.model.schema;
  const ancestors = position.parent.getAncestors({parentFirst: true, includeSelf: true});
  let hasParentLimit = false;
  const block = ancestors.find((element2) => {
    if (hasParentLimit) {
      return false;
    }
    hasParentLimit = schema.isLimit(element2);
    return !hasParentLimit && isUnvisitedBlock(element2, visited);
  });
  ancestors.forEach((element2) => visited.add(element2));
  return block;
}
function isTopBlockInRange(block, range) {
  const parentBlock = findAncestorBlock(block);
  if (!parentBlock) {
    return true;
  }
  const isParentInRange = range.containsRange(range_default2._createOn(parentBlock), true);
  return !isParentInRange;
}
function isStartBlockSelected(startBlock, range) {
  if (!startBlock) {
    return false;
  }
  if (range.isCollapsed || startBlock.isEmpty) {
    return true;
  }
  if (range.start.isTouching(position_default2._createAt(startBlock, startBlock.maxOffset))) {
    return false;
  }
  return isTopBlockInRange(startBlock, range);
}
function isEndBlockSelected(endBlock, range) {
  if (!endBlock) {
    return false;
  }
  if (range.isCollapsed || endBlock.isEmpty) {
    return true;
  }
  if (range.end.isTouching(position_default2._createAt(endBlock, 0))) {
    return false;
  }
  return isTopBlockInRange(endBlock, range);
}
function findAncestorBlock(node) {
  const schema = node.root.document.model.schema;
  let parent2 = node.parent;
  while (parent2) {
    if (schema.isBlock(parent2)) {
      return parent2;
    }
    parent2 = parent2.parent;
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/liverange.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var LiveRange = class extends EmitterMixin(range_default2) {
  constructor(start, end) {
    super(start, end);
    bindWithDocument.call(this);
  }
  detach() {
    this.stopListening();
  }
  toRange() {
    return new range_default2(this.start, this.end);
  }
  static fromRange(range) {
    return new LiveRange(range.start, range.end);
  }
};
var liverange_default = LiveRange;
LiveRange.prototype.is = function(type) {
  return type === "liveRange" || type === "model:liveRange" || type == "range" || type === "model:range";
};
function bindWithDocument() {
  this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
    const operation = args[0];
    if (!operation.isDocumentOperation) {
      return;
    }
    transform.call(this, operation);
  }, {priority: "low"});
}
function transform(operation) {
  const ranges = this.getTransformedByOperation(operation);
  const result = range_default2._createFromRanges(ranges);
  const boundariesChanged = !result.isEqual(this);
  const contentChanged = doesOperationChangeRangeContent(this, operation);
  let deletionPosition = null;
  if (boundariesChanged) {
    if (result.root.rootName == "$graveyard") {
      if (operation.type == "remove") {
        deletionPosition = operation.sourcePosition;
      } else {
        deletionPosition = operation.deletionPosition;
      }
    }
    const oldRange = this.toRange();
    this.start = result.start;
    this.end = result.end;
    this.fire("change:range", oldRange, {deletionPosition});
  } else if (contentChanged) {
    this.fire("change:content", this.toRange(), {deletionPosition});
  }
}
function doesOperationChangeRangeContent(range, operation) {
  switch (operation.type) {
    case "insert":
      return range.containsPosition(operation.position);
    case "move":
    case "remove":
    case "reinsert":
    case "merge":
      return range.containsPosition(operation.sourcePosition) || range.start.isEqual(operation.sourcePosition) || range.containsPosition(operation.targetPosition);
    case "split":
      return range.containsPosition(operation.splitPosition) || range.containsPosition(operation.insertionPosition);
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/documentselection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var storePrefix = "selection:";
var DocumentSelection2 = class extends EmitterMixin(typecheckable_default2) {
  constructor(doc) {
    super();
    this._selection = new LiveSelection(doc);
    this._selection.delegate("change:range").to(this);
    this._selection.delegate("change:attribute").to(this);
    this._selection.delegate("change:marker").to(this);
  }
  get isCollapsed() {
    return this._selection.isCollapsed;
  }
  get anchor() {
    return this._selection.anchor;
  }
  get focus() {
    return this._selection.focus;
  }
  get rangeCount() {
    return this._selection.rangeCount;
  }
  get hasOwnRange() {
    return this._selection.hasOwnRange;
  }
  get isBackward() {
    return this._selection.isBackward;
  }
  get isGravityOverridden() {
    return this._selection.isGravityOverridden;
  }
  get markers() {
    return this._selection.markers;
  }
  get _ranges() {
    return this._selection._ranges;
  }
  getRanges() {
    return this._selection.getRanges();
  }
  getFirstPosition() {
    return this._selection.getFirstPosition();
  }
  getLastPosition() {
    return this._selection.getLastPosition();
  }
  getFirstRange() {
    return this._selection.getFirstRange();
  }
  getLastRange() {
    return this._selection.getLastRange();
  }
  getSelectedBlocks() {
    return this._selection.getSelectedBlocks();
  }
  getSelectedElement() {
    return this._selection.getSelectedElement();
  }
  containsEntireContent(element) {
    return this._selection.containsEntireContent(element);
  }
  destroy() {
    this._selection.destroy();
  }
  getAttributeKeys() {
    return this._selection.getAttributeKeys();
  }
  getAttributes() {
    return this._selection.getAttributes();
  }
  getAttribute(key) {
    return this._selection.getAttribute(key);
  }
  hasAttribute(key) {
    return this._selection.hasAttribute(key);
  }
  refresh() {
    this._selection.updateMarkers();
    this._selection._updateAttributes(false);
  }
  observeMarkers(prefixOrName) {
    this._selection.observeMarkers(prefixOrName);
  }
  _setFocus(itemOrPosition, offset) {
    this._selection.setFocus(itemOrPosition, offset);
  }
  _setTo(...args) {
    this._selection.setTo(...args);
  }
  _setAttribute(key, value) {
    this._selection.setAttribute(key, value);
  }
  _removeAttribute(key) {
    this._selection.removeAttribute(key);
  }
  _getStoredAttributes() {
    return this._selection.getStoredAttributes();
  }
  _overrideGravity() {
    return this._selection.overrideGravity();
  }
  _restoreGravity(uid2) {
    this._selection.restoreGravity(uid2);
  }
  static _getStoreAttributeKey(key) {
    return storePrefix + key;
  }
  static _isStoreAttributeKey(key) {
    return key.startsWith(storePrefix);
  }
};
var documentselection_default2 = DocumentSelection2;
DocumentSelection2.prototype.is = function(type) {
  return type === "selection" || type == "model:selection" || type == "documentSelection" || type == "model:documentSelection";
};
var LiveSelection = class extends selection_default2 {
  constructor(doc) {
    super();
    this.markers = new collection_default({idProperty: "name"});
    this._attributePriority = new Map();
    this._selectionRestorePosition = null;
    this._hasChangedRange = false;
    this._overriddenGravityRegister = new Set();
    this._observedMarkers = new Set();
    this._model = doc.model;
    this._document = doc;
    this.listenTo(this._model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (!operation.isDocumentOperation || operation.type == "marker" || operation.type == "rename" || operation.type == "noop") {
        return;
      }
      if (this._ranges.length == 0 && this._selectionRestorePosition) {
        this._fixGraveyardSelection(this._selectionRestorePosition);
      }
      this._selectionRestorePosition = null;
      if (this._hasChangedRange) {
        this._hasChangedRange = false;
        this.fire("change:range", {directChange: false});
      }
    }, {priority: "lowest"});
    this.on("change:range", () => {
      this._validateSelectionRanges(this.getRanges());
    });
    this.listenTo(this._model.markers, "update", (evt, marker, oldRange, newRange) => {
      this._updateMarker(marker, newRange);
    });
    this.listenTo(this._document, "change", (evt, batch) => {
      clearAttributesStoredInElement(this._model, batch);
    });
  }
  get isCollapsed() {
    const length = this._ranges.length;
    return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
  }
  get anchor() {
    return super.anchor || this._document._getDefaultRange().start;
  }
  get focus() {
    return super.focus || this._document._getDefaultRange().end;
  }
  get rangeCount() {
    return this._ranges.length ? this._ranges.length : 1;
  }
  get hasOwnRange() {
    return this._ranges.length > 0;
  }
  get isGravityOverridden() {
    return !!this._overriddenGravityRegister.size;
  }
  destroy() {
    for (let i = 0; i < this._ranges.length; i++) {
      this._ranges[i].detach();
    }
    this.stopListening();
  }
  *getRanges() {
    if (this._ranges.length) {
      yield* super.getRanges();
    } else {
      yield this._document._getDefaultRange();
    }
  }
  getFirstRange() {
    return super.getFirstRange() || this._document._getDefaultRange();
  }
  getLastRange() {
    return super.getLastRange() || this._document._getDefaultRange();
  }
  setTo(...args) {
    super.setTo(...args);
    this._updateAttributes(true);
    this.updateMarkers();
  }
  setFocus(itemOrPosition, offset) {
    super.setFocus(itemOrPosition, offset);
    this._updateAttributes(true);
    this.updateMarkers();
  }
  setAttribute(key, value) {
    if (this._setAttribute(key, value)) {
      const attributeKeys = [key];
      this.fire("change:attribute", {attributeKeys, directChange: true});
    }
  }
  removeAttribute(key) {
    if (this._removeAttribute(key)) {
      const attributeKeys = [key];
      this.fire("change:attribute", {attributeKeys, directChange: true});
    }
  }
  overrideGravity() {
    const overrideUid = uid();
    this._overriddenGravityRegister.add(overrideUid);
    if (this._overriddenGravityRegister.size === 1) {
      this._updateAttributes(true);
    }
    return overrideUid;
  }
  restoreGravity(uid2) {
    if (!this._overriddenGravityRegister.has(uid2)) {
      throw new ckeditorerror_default("document-selection-gravity-wrong-restore", this, {uid: uid2});
    }
    this._overriddenGravityRegister.delete(uid2);
    if (!this.isGravityOverridden) {
      this._updateAttributes(true);
    }
  }
  observeMarkers(prefixOrName) {
    this._observedMarkers.add(prefixOrName);
    this.updateMarkers();
  }
  _replaceAllRanges(ranges) {
    this._validateSelectionRanges(ranges);
    super._replaceAllRanges(ranges);
  }
  _popRange() {
    this._ranges.pop().detach();
  }
  _pushRange(range) {
    const liveRange = this._prepareRange(range);
    if (liveRange) {
      this._ranges.push(liveRange);
    }
  }
  _validateSelectionRanges(ranges) {
    for (const range of ranges) {
      if (!this._document._validateSelectionRange(range)) {
        throw new ckeditorerror_default("document-selection-wrong-position", this, {range});
      }
    }
  }
  _prepareRange(range) {
    this._checkRange(range);
    if (range.root == this._document.graveyard) {
      return;
    }
    const liveRange = liverange_default.fromRange(range);
    liveRange.on("change:range", (evt, oldRange, data) => {
      this._hasChangedRange = true;
      if (liveRange.root == this._document.graveyard) {
        this._selectionRestorePosition = data.deletionPosition;
        const index = this._ranges.indexOf(liveRange);
        this._ranges.splice(index, 1);
        liveRange.detach();
      }
    });
    return liveRange;
  }
  updateMarkers() {
    if (!this._observedMarkers.size) {
      return;
    }
    const markers = [];
    let changed = false;
    for (const marker of this._model.markers) {
      const markerGroup = marker.name.split(":", 1)[0];
      if (!this._observedMarkers.has(markerGroup)) {
        continue;
      }
      const markerRange = marker.getRange();
      for (const selectionRange of this.getRanges()) {
        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
          markers.push(marker);
        }
      }
    }
    const oldMarkers = Array.from(this.markers);
    for (const marker of markers) {
      if (!this.markers.has(marker)) {
        this.markers.add(marker);
        changed = true;
      }
    }
    for (const marker of Array.from(this.markers)) {
      if (!markers.includes(marker)) {
        this.markers.remove(marker);
        changed = true;
      }
    }
    if (changed) {
      this.fire("change:marker", {oldMarkers, directChange: false});
    }
  }
  _updateMarker(marker, markerRange) {
    const markerGroup = marker.name.split(":", 1)[0];
    if (!this._observedMarkers.has(markerGroup)) {
      return;
    }
    let changed = false;
    const oldMarkers = Array.from(this.markers);
    const hasMarker = this.markers.has(marker);
    if (!markerRange) {
      if (hasMarker) {
        this.markers.remove(marker);
        changed = true;
      }
    } else {
      let contained = false;
      for (const selectionRange of this.getRanges()) {
        if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
          contained = true;
          break;
        }
      }
      if (contained && !hasMarker) {
        this.markers.add(marker);
        changed = true;
      } else if (!contained && hasMarker) {
        this.markers.remove(marker);
        changed = true;
      }
    }
    if (changed) {
      this.fire("change:marker", {oldMarkers, directChange: false});
    }
  }
  _updateAttributes(clearAll) {
    const newAttributes = toMap(this._getSurroundingAttributes());
    const oldAttributes = toMap(this.getAttributes());
    if (clearAll) {
      this._attributePriority = new Map();
      this._attrs = new Map();
    } else {
      for (const [key, priority] of this._attributePriority) {
        if (priority == "low") {
          this._attrs.delete(key);
          this._attributePriority.delete(key);
        }
      }
    }
    this._setAttributesTo(newAttributes);
    const changed = [];
    for (const [newKey, newValue] of this.getAttributes()) {
      if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {
        changed.push(newKey);
      }
    }
    for (const [oldKey] of oldAttributes) {
      if (!this.hasAttribute(oldKey)) {
        changed.push(oldKey);
      }
    }
    if (changed.length > 0) {
      this.fire("change:attribute", {attributeKeys: changed, directChange: false});
    }
  }
  _setAttribute(key, value, directChange = true) {
    const priority = directChange ? "normal" : "low";
    if (priority == "low" && this._attributePriority.get(key) == "normal") {
      return false;
    }
    const oldValue = super.getAttribute(key);
    if (oldValue === value) {
      return false;
    }
    this._attrs.set(key, value);
    this._attributePriority.set(key, priority);
    return true;
  }
  _removeAttribute(key, directChange = true) {
    const priority = directChange ? "normal" : "low";
    if (priority == "low" && this._attributePriority.get(key) == "normal") {
      return false;
    }
    this._attributePriority.set(key, priority);
    if (!super.hasAttribute(key)) {
      return false;
    }
    this._attrs.delete(key);
    return true;
  }
  _setAttributesTo(attrs) {
    const changed = new Set();
    for (const [oldKey, oldValue] of this.getAttributes()) {
      if (attrs.get(oldKey) === oldValue) {
        continue;
      }
      this._removeAttribute(oldKey, false);
    }
    for (const [key, value] of attrs) {
      const gotAdded = this._setAttribute(key, value, false);
      if (gotAdded) {
        changed.add(key);
      }
    }
    return changed;
  }
  *getStoredAttributes() {
    const selectionParent = this.getFirstPosition().parent;
    if (this.isCollapsed && selectionParent.isEmpty) {
      for (const key of selectionParent.getAttributeKeys()) {
        if (key.startsWith(storePrefix)) {
          const realKey = key.substr(storePrefix.length);
          yield [realKey, selectionParent.getAttribute(key)];
        }
      }
    }
  }
  _getSurroundingAttributes() {
    const position = this.getFirstPosition();
    const schema = this._model.schema;
    if (position.root.rootName == "$graveyard") {
      return null;
    }
    let attrs = null;
    if (!this.isCollapsed) {
      const range = this.getFirstRange();
      for (const value of range) {
        if (value.item.is("element") && schema.isObject(value.item)) {
          attrs = getTextAttributes(value.item, schema);
          break;
        }
        if (value.type == "text") {
          attrs = value.item.getAttributes();
          break;
        }
      }
    } else {
      const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;
      const nodeAfter = position.textNode ? position.textNode : position.nodeAfter;
      if (!this.isGravityOverridden) {
        attrs = getTextAttributes(nodeBefore, schema);
      }
      if (!attrs) {
        attrs = getTextAttributes(nodeAfter, schema);
      }
      if (!this.isGravityOverridden && !attrs) {
        let node = nodeBefore;
        while (node && !attrs) {
          node = node.previousSibling;
          attrs = getTextAttributes(node, schema);
        }
      }
      if (!attrs) {
        let node = nodeAfter;
        while (node && !attrs) {
          node = node.nextSibling;
          attrs = getTextAttributes(node, schema);
        }
      }
      if (!attrs) {
        attrs = this.getStoredAttributes();
      }
    }
    return attrs;
  }
  _fixGraveyardSelection(deletionPosition) {
    const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition);
    if (selectionRange) {
      this._pushRange(selectionRange);
    }
  }
};
function getTextAttributes(node, schema) {
  if (!node) {
    return null;
  }
  if (node instanceof textproxy_default2 || node instanceof text_default2) {
    return node.getAttributes();
  }
  if (!schema.isInline(node)) {
    return null;
  }
  if (!schema.isObject(node)) {
    return [];
  }
  const attributes = [];
  for (const [key, value] of node.getAttributes()) {
    if (schema.checkAttribute("$text", key) && schema.getAttributeProperties(key).copyFromObject !== false) {
      attributes.push([key, value]);
    }
  }
  return attributes;
}
function clearAttributesStoredInElement(model, batch) {
  const differ = model.document.differ;
  for (const entry of differ.getChanges()) {
    if (entry.type != "insert") {
      continue;
    }
    const changeParent = entry.position.parent;
    const isNoLongerEmpty = entry.length === changeParent.maxOffset;
    if (isNoLongerEmpty) {
      model.enqueueChange(batch, (writer) => {
        const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter((key) => key.startsWith(storePrefix));
        for (const key of storedAttributes) {
          writer.removeAttribute(key, changeParent);
        }
      });
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversionhelpers.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ConversionHelpers = class {
  constructor(dispatchers) {
    this._dispatchers = dispatchers;
  }
  add(conversionHelper) {
    for (const dispatcher of this._dispatchers) {
      conversionHelper(dispatcher);
    }
    return this;
  }
};
var conversionhelpers_default = ConversionHelpers;

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DowncastHelpers = class extends conversionhelpers_default {
  elementToElement(config) {
    return this.add(downcastElementToElement(config));
  }
  elementToStructure(config) {
    return this.add(downcastElementToStructure(config));
  }
  attributeToElement(config) {
    return this.add(downcastAttributeToElement(config));
  }
  attributeToAttribute(config) {
    return this.add(downcastAttributeToAttribute(config));
  }
  markerToElement(config) {
    return this.add(downcastMarkerToElement(config));
  }
  markerToHighlight(config) {
    return this.add(downcastMarkerToHighlight(config));
  }
  markerToData(config) {
    return this.add(downcastMarkerToData(config));
  }
};
var downcasthelpers_default = DowncastHelpers;
function insertText() {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    const viewText = viewWriter.createText(data.item.data);
    viewWriter.insert(viewPosition, viewText);
  };
}
function insertAttributesAndChildren() {
  return (evt, data, conversionApi) => {
    conversionApi.convertAttributes(data.item);
    if (!data.reconversion && data.item.is("element") && !data.item.isEmpty) {
      conversionApi.convertChildren(data.item);
    }
  };
}
function remove2() {
  return (evt, data, conversionApi) => {
    const viewStart = conversionApi.mapper.toViewPosition(data.position);
    const modelEnd = data.position.getShiftedBy(data.length);
    const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {isPhantom: true});
    const viewRange = conversionApi.writer.createRange(viewStart, viewEnd);
    const removed = conversionApi.writer.remove(viewRange.getTrimmed());
    for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {
      conversionApi.mapper.unbindViewElement(child, {defer: true});
    }
  };
}
function createViewElementFromHighlightDescriptor(writer, descriptor) {
  const viewElement = writer.createAttributeElement("span", descriptor.attributes);
  if (descriptor.classes) {
    viewElement._addClass(descriptor.classes);
  }
  if (typeof descriptor.priority === "number") {
    viewElement._priority = descriptor.priority;
  }
  viewElement._id = descriptor.id;
  return viewElement;
}
function convertRangeSelection() {
  return (evt, data, conversionApi) => {
    const selection = data.selection;
    if (selection.isCollapsed) {
      return;
    }
    if (!conversionApi.consumable.consume(selection, "selection")) {
      return;
    }
    const viewRanges = [];
    for (const range of selection.getRanges()) {
      viewRanges.push(conversionApi.mapper.toViewRange(range));
    }
    conversionApi.writer.setSelection(viewRanges, {backward: selection.isBackward});
  };
}
function convertCollapsedSelection() {
  return (evt, data, conversionApi) => {
    const selection = data.selection;
    if (!selection.isCollapsed) {
      return;
    }
    if (!conversionApi.consumable.consume(selection, "selection")) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const modelPosition = selection.getFirstPosition();
    const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
    const brokenPosition = viewWriter.breakAttributes(viewPosition);
    viewWriter.setSelection(brokenPosition);
  };
}
function cleanSelection() {
  return (evt, data, conversionApi) => {
    const viewWriter = conversionApi.writer;
    const viewSelection = viewWriter.document.selection;
    for (const range of viewSelection.getRanges()) {
      if (range.isCollapsed) {
        if (range.end.parent.isAttached()) {
          conversionApi.writer.mergeAttributes(range.start);
        }
      }
    }
    viewWriter.setSelection(null);
  };
}
function wrap(elementCreator) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data);
    const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);
    if (!oldViewElement && !newViewElement) {
      return;
    }
    conversionApi.consumable.consume(data.item, evt.name);
    const viewWriter = conversionApi.writer;
    const viewSelection = viewWriter.document.selection;
    if (data.item instanceof selection_default2 || data.item instanceof documentselection_default2) {
      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);
    } else {
      let viewRange = conversionApi.mapper.toViewRange(data.range);
      if (data.attributeOldValue !== null && oldViewElement) {
        viewRange = viewWriter.unwrap(viewRange, oldViewElement);
      }
      if (data.attributeNewValue !== null && newViewElement) {
        viewWriter.wrap(viewRange, newViewElement);
      }
    }
  };
}
function insertElement(elementCreator, consumer = defaultConsumer) {
  return (evt, data, conversionApi) => {
    if (!consumer(data.item, conversionApi.consumable, {preflight: true})) {
      return;
    }
    const viewElement = elementCreator(data.item, conversionApi, data);
    if (!viewElement) {
      return;
    }
    consumer(data.item, conversionApi.consumable);
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    conversionApi.mapper.bindElements(data.item, viewElement);
    conversionApi.writer.insert(viewPosition, viewElement);
    conversionApi.convertAttributes(data.item);
    reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, {reconversion: data.reconversion});
  };
}
function insertStructure(elementCreator, consumer) {
  return (evt, data, conversionApi) => {
    if (!consumer(data.item, conversionApi.consumable, {preflight: true})) {
      return;
    }
    const slotsMap = new Map();
    conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi));
    const viewElement = elementCreator(data.item, conversionApi, data);
    conversionApi.writer._clearSlotFactory();
    if (!viewElement) {
      return;
    }
    validateSlotsChildren(data.item, slotsMap, conversionApi);
    consumer(data.item, conversionApi.consumable);
    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    conversionApi.mapper.bindElements(data.item, viewElement);
    conversionApi.writer.insert(viewPosition, viewElement);
    conversionApi.convertAttributes(data.item);
    fillSlots(viewElement, slotsMap, conversionApi, {reconversion: data.reconversion});
  };
}
function insertUIElement(elementCreator) {
  return (evt, data, conversionApi) => {
    data.isOpening = true;
    const viewStartElement = elementCreator(data, conversionApi);
    data.isOpening = false;
    const viewEndElement = elementCreator(data, conversionApi);
    if (!viewStartElement || !viewEndElement) {
      return;
    }
    const markerRange = data.markerRange;
    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {
      return;
    }
    for (const value of markerRange) {
      if (!conversionApi.consumable.consume(value.item, evt.name)) {
        return;
      }
    }
    const mapper = conversionApi.mapper;
    const viewWriter = conversionApi.writer;
    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);
    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName);
    if (!markerRange.isCollapsed) {
      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);
      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);
    }
    evt.stop();
  };
}
function removeUIElement() {
  return (evt, data, conversionApi) => {
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
      conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
}
function insertMarkerData(viewCreator) {
  return (evt, data, conversionApi) => {
    const viewMarkerData = viewCreator(data.markerName, conversionApi);
    if (!viewMarkerData) {
      return;
    }
    const markerRange = data.markerRange;
    if (!conversionApi.consumable.consume(markerRange, evt.name)) {
      return;
    }
    handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);
    handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);
    evt.stop();
  };
}
function handleMarkerBoundary(range, isStart, conversionApi, data, viewMarkerData) {
  const modelPosition = isStart ? range.start : range.end;
  const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is("element") ? modelPosition.nodeAfter : null;
  const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is("element") ? modelPosition.nodeBefore : null;
  if (elementAfter || elementBefore) {
    let modelElement;
    let isBefore;
    if (isStart && elementAfter || !isStart && !elementBefore) {
      modelElement = elementAfter;
      isBefore = true;
    } else {
      modelElement = elementBefore;
      isBefore = false;
    }
    const viewElement = conversionApi.mapper.toViewElement(modelElement);
    if (viewElement) {
      insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);
      return;
    }
  }
  const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
  insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);
}
function insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {
  const attributeName = `data-${viewMarkerData.group}-${isStart ? "start" : "end"}-${isBefore ? "before" : "after"}`;
  const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(",") : [];
  markerNames.unshift(viewMarkerData.name);
  conversionApi.writer.setAttribute(attributeName, markerNames.join(","), viewElement);
  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
}
function insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {
  const viewElementName = `${viewMarkerData.group}-${isStart ? "start" : "end"}`;
  const attrs = viewMarkerData.name ? {name: viewMarkerData.name} : null;
  const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);
  conversionApi.writer.insert(position, viewElement);
  conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
}
function removeMarkerData(viewCreator) {
  return (evt, data, conversionApi) => {
    const viewData = viewCreator(data.markerName, conversionApi);
    if (!viewData) {
      return;
    }
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
      if (element.is("containerElement")) {
        removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element);
        removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element);
        removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element);
        removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element);
      } else {
        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
      }
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
    function removeMarkerFromAttribute(attributeName, element) {
      if (element.hasAttribute(attributeName)) {
        const markerNames = new Set(element.getAttribute(attributeName).split(","));
        markerNames.delete(viewData.name);
        if (markerNames.size == 0) {
          conversionApi.writer.removeAttribute(attributeName, element);
        } else {
          conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(","), element);
        }
      }
    }
  };
}
function changeAttribute(attributeCreator) {
  return (evt, data, conversionApi) => {
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);
    const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);
    if (!oldAttribute && !newAttribute) {
      return;
    }
    conversionApi.consumable.consume(data.item, evt.name);
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    const viewWriter = conversionApi.writer;
    if (!viewElement) {
      throw new ckeditorerror_default("conversion-attribute-to-attribute-on-text", conversionApi.dispatcher, data);
    }
    if (data.attributeOldValue !== null && oldAttribute) {
      if (oldAttribute.key == "class") {
        const classes = toArray(oldAttribute.value);
        for (const className of classes) {
          viewWriter.removeClass(className, viewElement);
        }
      } else if (oldAttribute.key == "style") {
        const keys2 = Object.keys(oldAttribute.value);
        for (const key of keys2) {
          viewWriter.removeStyle(key, viewElement);
        }
      } else {
        viewWriter.removeAttribute(oldAttribute.key, viewElement);
      }
    }
    if (data.attributeNewValue !== null && newAttribute) {
      if (newAttribute.key == "class") {
        const classes = toArray(newAttribute.value);
        for (const className of classes) {
          viewWriter.addClass(className, viewElement);
        }
      } else if (newAttribute.key == "style") {
        const keys2 = Object.keys(newAttribute.value);
        for (const key of keys2) {
          viewWriter.setStyle(key, newAttribute.value[key], viewElement);
        }
      } else {
        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);
      }
    }
  };
}
function highlightText(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (!data.item) {
      return;
    }
    if (!(data.item instanceof selection_default2 || data.item instanceof documentselection_default2) && !data.item.is("$textProxy")) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }
    const viewWriter = conversionApi.writer;
    const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);
    const viewSelection = viewWriter.document.selection;
    if (data.item instanceof selection_default2 || data.item instanceof documentselection_default2) {
      viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
    } else {
      const viewRange = conversionApi.mapper.toViewRange(data.range);
      const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);
      for (const element of rangeAfterWrap.getItems()) {
        if (element.is("attributeElement") && element.isSimilar(viewElement)) {
          conversionApi.mapper.bindElementToMarker(element, data.markerName);
          break;
        }
      }
    }
  };
}
function highlightElement(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (!data.item) {
      return;
    }
    if (!(data.item instanceof element_default2)) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }
    const viewElement = conversionApi.mapper.toViewElement(data.item);
    if (viewElement && viewElement.getCustomProperty("addHighlight")) {
      conversionApi.consumable.consume(data.item, evt.name);
      for (const value of range_default2._createIn(data.item)) {
        conversionApi.consumable.consume(value.item, evt.name);
      }
      const addHighlightCallback = viewElement.getCustomProperty("addHighlight");
      addHighlightCallback(viewElement, descriptor, conversionApi.writer);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
  };
}
function removeHighlight(highlightDescriptor) {
  return (evt, data, conversionApi) => {
    if (data.markerRange.isCollapsed) {
      return;
    }
    const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
    if (!descriptor) {
      return;
    }
    const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor);
    const elements = conversionApi.mapper.markerNameToElements(data.markerName);
    if (!elements) {
      return;
    }
    for (const element of elements) {
      conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
      if (element.is("attributeElement")) {
        conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);
      } else {
        const removeHighlightCallback = element.getCustomProperty("removeHighlight");
        removeHighlightCallback(element, descriptor.id, conversionApi.writer);
      }
    }
    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
}
function downcastElementToElement(config) {
  const model = normalizeModelElementConfig(config.model);
  const view = normalizeToElementConfig(config.view, "container");
  if (model.attributes.length) {
    model.children = true;
  }
  return (dispatcher) => {
    dispatcher.on(`insert:${model.name}`, insertElement(view, createConsumer(model)), {priority: config.converterPriority || "normal"});
    if (model.children || model.attributes.length) {
      dispatcher.on("reduceChanges", createChangeReducer(model), {priority: "low"});
    }
  };
}
function downcastElementToStructure(config) {
  const model = normalizeModelElementConfig(config.model);
  const view = normalizeToElementConfig(config.view, "container");
  model.children = true;
  return (dispatcher) => {
    if (dispatcher._conversionApi.schema.checkChild(model.name, "$text")) {
      throw new ckeditorerror_default("conversion-element-to-structure-disallowed-text", dispatcher, {elementName: model.name});
    }
    dispatcher.on(`insert:${model.name}`, insertStructure(view, createConsumer(model)), {priority: config.converterPriority || "normal"});
    dispatcher.on("reduceChanges", createChangeReducer(model), {priority: "low"});
  };
}
function downcastAttributeToElement(config) {
  config = cloneDeep_default(config);
  let model = config.model;
  if (typeof model == "string") {
    model = {key: model};
  }
  let eventName = `attribute:${model.key}`;
  if (model.name) {
    eventName += ":" + model.name;
  }
  if (model.values) {
    for (const modelValue of model.values) {
      config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], "attribute");
    }
  } else {
    config.view = normalizeToElementConfig(config.view, "attribute");
  }
  const elementCreator = getFromAttributeCreator(config);
  return (dispatcher) => {
    dispatcher.on(eventName, wrap(elementCreator), {priority: config.converterPriority || "normal"});
  };
}
function downcastAttributeToAttribute(config) {
  config = cloneDeep_default(config);
  let model = config.model;
  if (typeof model == "string") {
    model = {key: model};
  }
  let eventName = `attribute:${model.key}`;
  if (model.name) {
    eventName += ":" + model.name;
  }
  if (model.values) {
    for (const modelValue of model.values) {
      config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);
    }
  } else {
    config.view = normalizeToAttributeConfig(config.view);
  }
  const elementCreator = getFromAttributeCreator(config);
  return (dispatcher) => {
    dispatcher.on(eventName, changeAttribute(elementCreator), {priority: config.converterPriority || "normal"});
  };
}
function downcastMarkerToElement(config) {
  const view = normalizeToElementConfig(config.view, "ui");
  return (dispatcher) => {
    dispatcher.on(`addMarker:${config.model}`, insertUIElement(view), {priority: config.converterPriority || "normal"});
    dispatcher.on(`removeMarker:${config.model}`, removeUIElement(), {priority: config.converterPriority || "normal"});
  };
}
function downcastMarkerToData(config) {
  config = cloneDeep_default(config);
  const group = config.model;
  let view = config.view;
  if (!view) {
    view = (markerName) => ({
      group,
      name: markerName.substr(config.model.length + 1)
    });
  }
  return (dispatcher) => {
    dispatcher.on(`addMarker:${group}`, insertMarkerData(view), {priority: config.converterPriority || "normal"});
    dispatcher.on(`removeMarker:${group}`, removeMarkerData(view), {priority: config.converterPriority || "normal"});
  };
}
function downcastMarkerToHighlight(config) {
  return (dispatcher) => {
    dispatcher.on(`addMarker:${config.model}`, highlightText(config.view), {priority: config.converterPriority || "normal"});
    dispatcher.on(`addMarker:${config.model}`, highlightElement(config.view), {priority: config.converterPriority || "normal"});
    dispatcher.on(`removeMarker:${config.model}`, removeHighlight(config.view), {priority: config.converterPriority || "normal"});
  };
}
function normalizeModelElementConfig(model) {
  if (typeof model == "string") {
    model = {name: model};
  }
  if (!model.attributes) {
    model.attributes = [];
  } else if (!Array.isArray(model.attributes)) {
    model.attributes = [model.attributes];
  }
  model.children = !!model.children;
  return model;
}
function normalizeToElementConfig(view, viewElementType) {
  if (typeof view == "function") {
    return view;
  }
  return (modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType);
}
function createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {
  if (typeof viewElementDefinition == "string") {
    viewElementDefinition = {name: viewElementDefinition};
  }
  let element;
  const viewWriter = conversionApi.writer;
  const attributes = Object.assign({}, viewElementDefinition.attributes);
  if (viewElementType == "container") {
    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);
  } else if (viewElementType == "attribute") {
    const options = {
      priority: viewElementDefinition.priority || attributeelement_default.DEFAULT_PRIORITY
    };
    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);
  } else {
    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);
  }
  if (viewElementDefinition.styles) {
    const keys2 = Object.keys(viewElementDefinition.styles);
    for (const key of keys2) {
      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);
    }
  }
  if (viewElementDefinition.classes) {
    const classes = viewElementDefinition.classes;
    if (typeof classes == "string") {
      viewWriter.addClass(classes, element);
    } else {
      for (const className of classes) {
        viewWriter.addClass(className, element);
      }
    }
  }
  return element;
}
function getFromAttributeCreator(config) {
  if (config.model.values) {
    return (modelAttributeValue, conversionApi, data) => {
      const view = config.view[modelAttributeValue];
      if (view) {
        return view(modelAttributeValue, conversionApi, data);
      }
      return null;
    };
  } else {
    return config.view;
  }
}
function normalizeToAttributeConfig(view) {
  if (typeof view == "string") {
    return (modelAttributeValue) => ({key: view, value: modelAttributeValue});
  } else if (typeof view == "object") {
    if (view.value) {
      return () => view;
    } else {
      return (modelAttributeValue) => ({key: view.key, value: modelAttributeValue});
    }
  } else {
    return view;
  }
}
function prepareDescriptor(highlightDescriptor, data, conversionApi) {
  const descriptor = typeof highlightDescriptor == "function" ? highlightDescriptor(data, conversionApi) : highlightDescriptor;
  if (!descriptor) {
    return null;
  }
  if (!descriptor.priority) {
    descriptor.priority = 10;
  }
  if (!descriptor.id) {
    descriptor.id = data.markerName;
  }
  return descriptor;
}
function createChangeReducerCallback(model) {
  return (node, change) => {
    if (!node.is("element", model.name)) {
      return false;
    }
    if (change.type == "attribute") {
      if (model.attributes.includes(change.attributeKey)) {
        return true;
      }
    } else {
      /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve */
      if (model.children) {
        return true;
      }
    }
    return false;
  };
}
function createChangeReducer(model) {
  const shouldReplace = createChangeReducerCallback(model);
  return (evt, data) => {
    const reducedChanges = [];
    if (!data.reconvertedElements) {
      data.reconvertedElements = new Set();
    }
    for (const change of data.changes) {
      const node = change.type == "attribute" ? change.range.start.nodeAfter : change.position.parent;
      if (!node || !shouldReplace(node, change)) {
        reducedChanges.push(change);
        continue;
      }
      if (!data.reconvertedElements.has(node)) {
        data.reconvertedElements.add(node);
        const position = position_default2._createBefore(node);
        let changeIndex = reducedChanges.length;
        for (let i = reducedChanges.length - 1; i >= 0; i--) {
          const change2 = reducedChanges[i];
          const changePosition = change2.type == "attribute" ? change2.range.start : change2.position;
          const positionRelation = changePosition.compareWith(position);
          if (positionRelation == "before" || change2.type == "remove" && positionRelation == "same") {
            break;
          }
          changeIndex = i;
        }
        reducedChanges.splice(changeIndex, 0, {
          type: "remove",
          name: node.name,
          position,
          length: 1
        }, {
          type: "reinsert",
          name: node.name,
          position,
          length: 1
        });
      }
    }
    data.changes = reducedChanges;
  };
}
function createConsumer(model) {
  return (node, consumable, options = {}) => {
    const events = ["insert"];
    for (const attributeName of model.attributes) {
      if (node.hasAttribute(attributeName)) {
        events.push(`attribute:${attributeName}`);
      }
    }
    if (!events.every((event) => consumable.test(node, event))) {
      return false;
    }
    if (!options.preflight) {
      events.forEach((event) => consumable.consume(node, event));
    }
    return true;
  };
}
function createSlotFactory(element, slotsMap, conversionApi) {
  return (writer, modeOrFilter) => {
    const slot = writer.createContainerElement("$slot");
    let children = null;
    if (modeOrFilter === "children") {
      children = Array.from(element.getChildren());
    } else if (typeof modeOrFilter == "function") {
      children = Array.from(element.getChildren()).filter((element2) => modeOrFilter(element2));
    } else {
      throw new ckeditorerror_default("conversion-slot-mode-unknown", conversionApi.dispatcher, {modeOrFilter});
    }
    slotsMap.set(slot, children);
    return slot;
  };
}
function validateSlotsChildren(element, slotsMap, conversionApi) {
  const childrenInSlots = Array.from(slotsMap.values()).flat();
  const uniqueChildrenInSlots = new Set(childrenInSlots);
  if (uniqueChildrenInSlots.size != childrenInSlots.length) {
    throw new ckeditorerror_default("conversion-slot-filter-overlap", conversionApi.dispatcher, {element});
  }
  if (uniqueChildrenInSlots.size != element.childCount) {
    throw new ckeditorerror_default("conversion-slot-filter-incomplete", conversionApi.dispatcher, {element});
  }
}
function fillSlots(viewElement, slotsMap, conversionApi, options) {
  conversionApi.mapper.on("modelToViewPosition", toViewPositionMapping, {priority: "highest"});
  let currentSlot = null;
  let currentSlotNodes = null;
  for ([currentSlot, currentSlotNodes] of slotsMap) {
    reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);
    conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));
    conversionApi.writer.remove(currentSlot);
  }
  conversionApi.mapper.off("modelToViewPosition", toViewPositionMapping);
  function toViewPositionMapping(evt, data) {
    const element = data.modelPosition.nodeAfter;
    const index = currentSlotNodes.indexOf(element);
    if (index < 0) {
      return;
    }
    data.viewPosition = data.mapper.findPositionIn(currentSlot, index);
  }
}
function reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {
  for (const modelChildNode of modelNodes) {
    if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {
      conversionApi.convertItem(modelChildNode);
    }
  }
}
function reinsertNode(viewRoot, modelNode, conversionApi, options) {
  const {writer, mapper} = conversionApi;
  if (!options.reconversion) {
    return false;
  }
  const viewChildNode = mapper.toViewElement(modelNode);
  if (!viewChildNode || viewChildNode.root == viewRoot) {
    return false;
  }
  if (!conversionApi.canReuseView(viewChildNode)) {
    return false;
  }
  writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(position_default2._createBefore(modelNode)));
  return true;
}
function defaultConsumer(item, consumable, {preflight} = {}) {
  if (preflight) {
    return consumable.test(item, "insert");
  } else {
    return consumable.consume(item, "insert");
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/autoparagraphing.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function autoParagraphEmptyRoots(writer) {
  const {schema, document: document2} = writer.model;
  for (const root2 of document2.getRoots()) {
    if (root2.isEmpty && !schema.checkChild(root2, "$text")) {
      if (schema.checkChild(root2, "paragraph")) {
        writer.insertElement("paragraph", root2);
        return true;
      }
    }
  }
  return false;
}
function isParagraphable(position, nodeOrType, schema) {
  const context = schema.createContext(position);
  if (!schema.checkChild(context, "paragraph")) {
    return false;
  }
  if (!schema.checkChild(context.push("paragraph"), nodeOrType)) {
    return false;
  }
  return true;
}
function wrapInParagraph(position, writer) {
  const paragraph = writer.createElement("paragraph");
  writer.insert(paragraph, position);
  return writer.createPositionAt(paragraph, 0);
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var UpcastHelpers = class extends conversionhelpers_default {
  elementToElement(config) {
    return this.add(upcastElementToElement(config));
  }
  elementToAttribute(config) {
    return this.add(upcastElementToAttribute(config));
  }
  attributeToAttribute(config) {
    return this.add(upcastAttributeToAttribute(config));
  }
  elementToMarker(config) {
    return this.add(upcastElementToMarker(config));
  }
  dataToMarker(config) {
    return this.add(upcastDataToMarker(config));
  }
};
var upcasthelpers_default = UpcastHelpers;
function convertToModelFragment() {
  return (evt, data, conversionApi) => {
    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {name: true})) {
      const {modelRange, modelCursor} = conversionApi.convertChildren(data.viewItem, data.modelCursor);
      data.modelRange = modelRange;
      data.modelCursor = modelCursor;
    }
  };
}
function convertText() {
  return (evt, data, {schema, consumable, writer}) => {
    let position = data.modelCursor;
    if (!consumable.test(data.viewItem)) {
      return;
    }
    if (!schema.checkChild(position, "$text")) {
      if (!isParagraphable(position, "$text", schema)) {
        return;
      }
      if (data.viewItem.data.trim().length == 0) {
        return;
      }
      const nodeBefore = position.nodeBefore;
      position = wrapInParagraph(position, writer);
      if (nodeBefore && nodeBefore.is("element", "$marker")) {
        writer.move(writer.createRangeOn(nodeBefore), position);
        position = writer.createPositionAfter(nodeBefore);
      }
    }
    consumable.consume(data.viewItem);
    const text = writer.createText(data.viewItem.data);
    writer.insert(text, position);
    data.modelRange = writer.createRange(position, position.getShiftedBy(text.offsetSize));
    data.modelCursor = data.modelRange.end;
  };
}
function convertSelectionChange(model, mapper) {
  return (evt, data) => {
    const viewSelection = data.newSelection;
    const ranges = [];
    for (const viewRange of viewSelection.getRanges()) {
      ranges.push(mapper.toModelRange(viewRange));
    }
    const modelSelection = model.createSelection(ranges, {backward: viewSelection.isBackward});
    if (!modelSelection.isEqual(model.document.selection)) {
      model.change((writer) => {
        writer.setSelection(modelSelection);
      });
    }
  };
}
function upcastElementToElement(config) {
  config = cloneDeep_default(config);
  const converter = prepareToElementConverter(config);
  const elementName = getViewElementNameFromConfig(config.view);
  const eventName = elementName ? `element:${elementName}` : "element";
  return (dispatcher) => {
    dispatcher.on(eventName, converter, {priority: config.converterPriority || "normal"});
  };
}
function upcastElementToAttribute(config) {
  config = cloneDeep_default(config);
  normalizeModelAttributeConfig(config);
  const converter = prepareToAttributeConverter(config, false);
  const elementName = getViewElementNameFromConfig(config.view);
  const eventName = elementName ? `element:${elementName}` : "element";
  return (dispatcher) => {
    dispatcher.on(eventName, converter, {priority: config.converterPriority || "low"});
  };
}
function upcastAttributeToAttribute(config) {
  config = cloneDeep_default(config);
  let viewKey = null;
  if (typeof config.view == "string" || config.view.key) {
    viewKey = normalizeViewAttributeKeyValueConfig(config);
  }
  normalizeModelAttributeConfig(config, viewKey);
  const converter = prepareToAttributeConverter(config, true);
  return (dispatcher) => {
    dispatcher.on("element", converter, {priority: config.converterPriority || "low"});
  };
}
function upcastElementToMarker(config) {
  const model = normalizeElementToMarkerModelConfig(config.model);
  return upcastElementToElement({...config, model});
}
function upcastDataToMarker(config) {
  config = cloneDeep_default(config);
  if (!config.model) {
    config.model = (name) => {
      return name ? config.view + ":" + name : config.view;
    };
  }
  const normalizedConfig = {
    view: config.view,
    model: config.model
  };
  const converterStart = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "start"));
  const converterEnd = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "end"));
  return (dispatcher) => {
    dispatcher.on(`element:${config.view}-start`, converterStart, {priority: config.converterPriority || "normal"});
    dispatcher.on(`element:${config.view}-end`, converterEnd, {priority: config.converterPriority || "normal"});
    const basePriority = priorities_default.low;
    const maxPriority = priorities_default.highest;
    const priorityFactor = priorities_default.get(config.converterPriority) / maxPriority;
    dispatcher.on("element", upcastAttributeToMarker(normalizedConfig), {priority: basePriority + priorityFactor});
  };
}
function upcastAttributeToMarker(config) {
  return (evt, data, conversionApi) => {
    const attrName = `data-${config.view}`;
    if (!conversionApi.consumable.test(data.viewItem, {attributes: attrName + "-end-after"}) && !conversionApi.consumable.test(data.viewItem, {attributes: attrName + "-start-after"}) && !conversionApi.consumable.test(data.viewItem, {attributes: attrName + "-end-before"}) && !conversionApi.consumable.test(data.viewItem, {attributes: attrName + "-start-before"})) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    if (conversionApi.consumable.consume(data.viewItem, {attributes: attrName + "-end-after"})) {
      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-end-after").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, {attributes: attrName + "-start-after"})) {
      addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-start-after").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, {attributes: attrName + "-end-before"})) {
      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-end-before").split(","));
    }
    if (conversionApi.consumable.consume(data.viewItem, {attributes: attrName + "-start-before"})) {
      addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-start-before").split(","));
    }
    function addMarkerElements(position, markerViewNames) {
      for (const markerViewName of markerViewNames) {
        const markerName = config.model(markerViewName, conversionApi);
        const element = conversionApi.writer.createElement("$marker", {"data-name": markerName});
        conversionApi.writer.insert(element, position);
        if (data.modelCursor.isEqual(position)) {
          data.modelCursor = data.modelCursor.getShiftedBy(1);
        } else {
          data.modelCursor = data.modelCursor._getTransformedByInsertion(position, 1);
        }
        data.modelRange = data.modelRange._getTransformedByInsertion(position, 1)[0];
      }
    }
  };
}
function getViewElementNameFromConfig(viewConfig) {
  if (typeof viewConfig == "string") {
    return viewConfig;
  }
  if (typeof viewConfig == "object" && typeof viewConfig.name == "string") {
    return viewConfig.name;
  }
  return null;
}
function prepareToElementConverter(config) {
  const matcher = new matcher_default(config.view);
  return (evt, data, conversionApi) => {
    const matcherResult = matcher.match(data.viewItem);
    if (!matcherResult) {
      return;
    }
    const match = matcherResult.match;
    match.name = true;
    if (!conversionApi.consumable.test(data.viewItem, match)) {
      return;
    }
    const modelElement = getModelElement(config.model, data.viewItem, conversionApi);
    if (!modelElement) {
      return;
    }
    if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
      return;
    }
    conversionApi.consumable.consume(data.viewItem, match);
    conversionApi.convertChildren(data.viewItem, modelElement);
    conversionApi.updateConversionResult(modelElement, data);
  };
}
function getModelElement(model, input, conversionApi) {
  if (model instanceof Function) {
    return model(input, conversionApi);
  } else {
    return conversionApi.writer.createElement(model);
  }
}
function normalizeViewAttributeKeyValueConfig(config) {
  if (typeof config.view == "string") {
    config.view = {key: config.view};
  }
  const key = config.view.key;
  let normalized;
  if (key == "class" || key == "style") {
    const keyName = key == "class" ? "classes" : "styles";
    normalized = {
      [keyName]: config.view.value
    };
  } else {
    const value = typeof config.view.value == "undefined" ? /[\s\S]*/ : config.view.value;
    normalized = {
      attributes: {
        [key]: value
      }
    };
  }
  if (config.view.name) {
    normalized.name = config.view.name;
  }
  config.view = normalized;
  return key;
}
function normalizeModelAttributeConfig(config, viewAttributeKeyToCopy = null) {
  const defaultModelValue = viewAttributeKeyToCopy === null ? true : (viewElement) => viewElement.getAttribute(viewAttributeKeyToCopy);
  const key = typeof config.model != "object" ? config.model : config.model.key;
  const value = typeof config.model != "object" || typeof config.model.value == "undefined" ? defaultModelValue : config.model.value;
  config.model = {key, value};
}
function prepareToAttributeConverter(config, shallow) {
  const matcher = new matcher_default(config.view);
  return (evt, data, conversionApi) => {
    if (!data.modelRange && shallow) {
      return;
    }
    const match = matcher.match(data.viewItem);
    if (!match) {
      return;
    }
    if (onlyViewNameIsDefined(config.view, data.viewItem)) {
      match.match.name = true;
    } else {
      delete match.match.name;
    }
    if (!conversionApi.consumable.test(data.viewItem, match.match)) {
      return;
    }
    const modelKey = config.model.key;
    const modelValue = typeof config.model.value == "function" ? config.model.value(data.viewItem, conversionApi) : config.model.value;
    if (modelValue === null) {
      return;
    }
    if (!data.modelRange) {
      Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    }
    const attributeWasSet = setAttributeOn(data.modelRange, {key: modelKey, value: modelValue}, shallow, conversionApi);
    if (attributeWasSet) {
      if (conversionApi.consumable.test(data.viewItem, {name: true})) {
        match.match.name = true;
      }
      conversionApi.consumable.consume(data.viewItem, match.match);
    }
  };
}
function onlyViewNameIsDefined(viewConfig, viewItem) {
  const configToTest = typeof viewConfig == "function" ? viewConfig(viewItem) : viewConfig;
  if (typeof configToTest == "object" && !getViewElementNameFromConfig(configToTest)) {
    return false;
  }
  return !configToTest.classes && !configToTest.attributes && !configToTest.styles;
}
function setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {
  let result = false;
  for (const node of Array.from(modelRange.getItems({shallow}))) {
    if (!conversionApi.schema.checkAttribute(node, modelAttribute.key)) {
      continue;
    }
    result = true;
    if (node.hasAttribute(modelAttribute.key)) {
      continue;
    }
    conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);
  }
  return result;
}
function normalizeElementToMarkerModelConfig(model) {
  return (viewElement, conversionApi) => {
    const markerName = typeof model == "string" ? model : model(viewElement, conversionApi);
    return conversionApi.writer.createElement("$marker", {"data-name": markerName});
  };
}
function normalizeDataToMarkerConfig(config, type) {
  const elementCreatorFunction = (viewElement, conversionApi) => {
    const viewName = viewElement.getAttribute("name");
    const markerName = config.model(viewName, conversionApi);
    return conversionApi.writer.createElement("$marker", {"data-name": markerName});
  };
  return {
    view: `${config.view}-${type}`,
    model: elementCreatorFunction
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function injectSelectionPostFixer(model) {
  model.document.registerPostFixer((writer) => selectionPostFixer(writer, model));
}
function selectionPostFixer(writer, model) {
  const selection = model.document.selection;
  const schema = model.schema;
  const ranges = [];
  let wasFixed = false;
  for (const modelRange of selection.getRanges()) {
    const correctedRange = tryFixingRange(modelRange, schema);
    if (correctedRange && !correctedRange.isEqual(modelRange)) {
      ranges.push(correctedRange);
      wasFixed = true;
    } else {
      ranges.push(modelRange);
    }
  }
  if (wasFixed) {
    writer.setSelection(mergeIntersectingRanges(ranges), {backward: selection.isBackward});
  }
  return false;
}
function tryFixingRange(range, schema) {
  if (range.isCollapsed) {
    return tryFixingCollapsedRange(range, schema);
  }
  return tryFixingNonCollapsedRage(range, schema);
}
function tryFixingCollapsedRange(range, schema) {
  const originalPosition = range.start;
  const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition);
  if (!nearestSelectionRange) {
    const ancestorObject = originalPosition.getAncestors().reverse().find((item) => schema.isObject(item));
    if (ancestorObject) {
      return range_default2._createOn(ancestorObject);
    }
    return null;
  }
  if (!nearestSelectionRange.isCollapsed) {
    return nearestSelectionRange;
  }
  const fixedPosition = nearestSelectionRange.start;
  if (originalPosition.isEqual(fixedPosition)) {
    return null;
  }
  return new range_default2(fixedPosition);
}
function tryFixingNonCollapsedRage(range, schema) {
  const {start, end} = range;
  const isTextAllowedOnStart = schema.checkChild(start, "$text");
  const isTextAllowedOnEnd = schema.checkChild(end, "$text");
  const startLimitElement = schema.getLimitElement(start);
  const endLimitElement = schema.getLimitElement(end);
  if (startLimitElement === endLimitElement) {
    if (isTextAllowedOnStart && isTextAllowedOnEnd) {
      return null;
    }
    if (checkSelectionOnNonLimitElements(start, end, schema)) {
      const isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);
      const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, "forward");
      const isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);
      const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, "backward");
      const rangeStart = fixedStart ? fixedStart.start : start;
      const rangeEnd = fixedEnd ? fixedEnd.end : end;
      return new range_default2(rangeStart, rangeEnd);
    }
  }
  const isStartInLimit = startLimitElement && !startLimitElement.is("rootElement");
  const isEndInLimit = endLimitElement && !endLimitElement.is("rootElement");
  if (isStartInLimit || isEndInLimit) {
    const bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;
    const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));
    const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema));
    let fixedStart = start;
    let fixedEnd = end;
    if (expandStart) {
      fixedStart = position_default2._createBefore(findOutermostLimitAncestor(startLimitElement, schema));
    }
    if (expandEnd) {
      fixedEnd = position_default2._createAfter(findOutermostLimitAncestor(endLimitElement, schema));
    }
    return new range_default2(fixedStart, fixedEnd);
  }
  return null;
}
function findOutermostLimitAncestor(startingNode, schema) {
  let isLimitNode = startingNode;
  let parent2 = isLimitNode;
  while (schema.isLimit(parent2) && parent2.parent) {
    isLimitNode = parent2;
    parent2 = parent2.parent;
  }
  return isLimitNode;
}
function checkSelectionOnNonLimitElements(start, end, schema) {
  const startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, "$text");
  const endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, "$text");
  return startIsOnBlock || endIsOnBlock;
}
function mergeIntersectingRanges(ranges) {
  const rangesToMerge = [...ranges];
  const rangeIndexesToRemove = new Set();
  let currentRangeIndex = 1;
  while (currentRangeIndex < rangesToMerge.length) {
    const currentRange = rangesToMerge[currentRangeIndex];
    const previousRanges = rangesToMerge.slice(0, currentRangeIndex);
    for (const [previousRangeIndex, previousRange] of previousRanges.entries()) {
      if (rangeIndexesToRemove.has(previousRangeIndex)) {
        continue;
      }
      if (currentRange.isEqual(previousRange)) {
        rangeIndexesToRemove.add(previousRangeIndex);
      } else if (currentRange.isIntersecting(previousRange)) {
        rangeIndexesToRemove.add(previousRangeIndex);
        rangeIndexesToRemove.add(currentRangeIndex);
        const mergedRange = currentRange.getJoined(previousRange);
        rangesToMerge.push(mergedRange);
      }
    }
    currentRangeIndex++;
  }
  const nonIntersectingRanges = rangesToMerge.filter((_, index) => !rangeIndexesToRemove.has(index));
  return nonIntersectingRanges;
}
function isSelectable(node, schema) {
  return node && schema.isSelectable(node);
}

// node_modules/@ckeditor/ckeditor5-engine/src/controller/editingcontroller.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EditingController = class extends ObservableMixin() {
  constructor(model, stylesProcessor) {
    super();
    this.model = model;
    this.view = new view_default(stylesProcessor);
    this.mapper = new mapper_default();
    this.downcastDispatcher = new downcastdispatcher_default({
      mapper: this.mapper,
      schema: model.schema
    });
    const doc = this.model.document;
    const selection = doc.selection;
    const markers = this.model.markers;
    this.listenTo(this.model, "_beforeChanges", () => {
      this.view._disableRendering(true);
    }, {priority: "highest"});
    this.listenTo(this.model, "_afterChanges", () => {
      this.view._disableRendering(false);
    }, {priority: "lowest"});
    this.listenTo(doc, "change", () => {
      this.view.change((writer) => {
        this.downcastDispatcher.convertChanges(doc.differ, markers, writer);
        this.downcastDispatcher.convertSelection(selection, markers, writer);
      });
    }, {priority: "low"});
    this.listenTo(this.view.document, "selectionChange", convertSelectionChange(this.model, this.mapper));
    this.listenTo(this.view.document, "beforeinput", fixTargetRanges(this.mapper, this.model.schema, this.view), {priority: "high"});
    this.downcastDispatcher.on("insert:$text", insertText(), {priority: "lowest"});
    this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {priority: "lowest"});
    this.downcastDispatcher.on("remove", remove2(), {priority: "low"});
    this.downcastDispatcher.on("cleanSelection", cleanSelection());
    this.downcastDispatcher.on("selection", convertRangeSelection(), {priority: "low"});
    this.downcastDispatcher.on("selection", convertCollapsedSelection(), {priority: "low"});
    this.view.document.roots.bindTo(this.model.document.roots).using((root2) => {
      if (root2.rootName == "$graveyard") {
        return null;
      }
      const viewRoot = new rooteditableelement_default(this.view.document, root2.name);
      viewRoot.rootName = root2.rootName;
      this.mapper.bindElements(root2, viewRoot);
      return viewRoot;
    });
  }
  destroy() {
    this.view.destroy();
    this.stopListening();
  }
  reconvertMarker(markerOrName) {
    const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    const currentMarker = this.model.markers.get(markerName);
    if (!currentMarker) {
      throw new ckeditorerror_default("editingcontroller-reconvertmarker-marker-not-exist", this, {markerName});
    }
    this.model.change(() => {
      this.model.markers._refresh(currentMarker);
    });
  }
  reconvertItem(item) {
    this.model.change(() => {
      this.model.document.differ._refreshItem(item);
    });
  }
};
var editingcontroller_default = EditingController;
function fixTargetRanges(mapper, schema, view) {
  return (evt, data) => {
    if (view.document.isComposing && !env_default.isAndroid) {
      return;
    }
    for (let i = 0; i < data.targetRanges.length; i++) {
      const viewRange = data.targetRanges[i];
      const modelRange = mapper.toModelRange(viewRange);
      const correctedRange = tryFixingRange(modelRange, schema);
      if (!correctedRange || correctedRange.isEqual(modelRange)) {
        continue;
      }
      data.targetRanges[i] = mapper.toViewRange(correctedRange);
    }
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ViewConsumable = class {
  constructor() {
    this._consumables = new Map();
  }
  add(element, consumables) {
    let elementConsumables;
    if (element.is("$text") || element.is("documentFragment")) {
      this._consumables.set(element, true);
      return;
    }
    if (!this._consumables.has(element)) {
      elementConsumables = new ViewElementConsumables(element);
      this._consumables.set(element, elementConsumables);
    } else {
      elementConsumables = this._consumables.get(element);
    }
    elementConsumables.add(consumables);
  }
  test(element, consumables) {
    const elementConsumables = this._consumables.get(element);
    if (elementConsumables === void 0) {
      return null;
    }
    if (element.is("$text") || element.is("documentFragment")) {
      return elementConsumables;
    }
    return elementConsumables.test(consumables);
  }
  consume(element, consumables) {
    if (this.test(element, consumables)) {
      if (element.is("$text") || element.is("documentFragment")) {
        this._consumables.set(element, false);
      } else {
        this._consumables.get(element).consume(consumables);
      }
      return true;
    }
    return false;
  }
  revert(element, consumables) {
    const elementConsumables = this._consumables.get(element);
    if (elementConsumables !== void 0) {
      if (element.is("$text") || element.is("documentFragment")) {
        this._consumables.set(element, true);
      } else {
        elementConsumables.revert(consumables);
      }
    }
  }
  static consumablesFromElement(element) {
    const consumables = {
      element,
      name: true,
      attributes: [],
      classes: [],
      styles: []
    };
    const attributes = element.getAttributeKeys();
    for (const attribute of attributes) {
      if (attribute == "style" || attribute == "class") {
        continue;
      }
      consumables.attributes.push(attribute);
    }
    const classes = element.getClassNames();
    for (const className of classes) {
      consumables.classes.push(className);
    }
    const styles = element.getStyleNames();
    for (const style of styles) {
      consumables.styles.push(style);
    }
    return consumables;
  }
  static createFrom(from, instance) {
    if (!instance) {
      instance = new ViewConsumable();
    }
    if (from.is("$text")) {
      instance.add(from);
      return instance;
    }
    if (from.is("element")) {
      instance.add(from, ViewConsumable.consumablesFromElement(from));
    }
    if (from.is("documentFragment")) {
      instance.add(from);
    }
    for (const child of from.getChildren()) {
      instance = ViewConsumable.createFrom(child, instance);
    }
    return instance;
  }
};
var viewconsumable_default = ViewConsumable;
var CONSUMABLE_TYPES = ["attributes", "classes", "styles"];
var ViewElementConsumables = class {
  constructor(from) {
    this.element = from;
    this._canConsumeName = null;
    this._consumables = {
      attributes: new Map(),
      styles: new Map(),
      classes: new Map()
    };
  }
  add(consumables) {
    if (consumables.name) {
      this._canConsumeName = true;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        this._add(type, consumables[type]);
      }
    }
  }
  test(consumables) {
    if (consumables.name && !this._canConsumeName) {
      return this._canConsumeName;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        const value = this._test(type, consumables[type]);
        if (value !== true) {
          return value;
        }
      }
    }
    return true;
  }
  consume(consumables) {
    if (consumables.name) {
      this._canConsumeName = false;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        this._consume(type, consumables[type]);
      }
    }
  }
  revert(consumables) {
    if (consumables.name) {
      this._canConsumeName = true;
    }
    for (const type of CONSUMABLE_TYPES) {
      if (type in consumables) {
        this._revert(type, consumables[type]);
      }
    }
  }
  _add(type, item) {
    const items = isArray_default(item) ? item : [item];
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        throw new ckeditorerror_default("viewconsumable-invalid-attribute", this);
      }
      consumables.set(name, true);
      if (type === "styles") {
        for (const alsoName of this.element.document.stylesProcessor.getRelatedStyles(name)) {
          consumables.set(alsoName, true);
        }
      }
    }
  }
  _test(type, item) {
    const items = isArray_default(item) ? item : [item];
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        const consumableName = name == "class" ? "classes" : "styles";
        const value = this._test(consumableName, [...this._consumables[consumableName].keys()]);
        if (value !== true) {
          return value;
        }
      } else {
        const value = consumables.get(name);
        if (value === void 0) {
          return null;
        }
        if (!value) {
          return false;
        }
      }
    }
    return true;
  }
  _consume(type, item) {
    const items = isArray_default(item) ? item : [item];
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        const consumableName = name == "class" ? "classes" : "styles";
        this._consume(consumableName, [...this._consumables[consumableName].keys()]);
      } else {
        consumables.set(name, false);
        if (type == "styles") {
          for (const toConsume of this.element.document.stylesProcessor.getRelatedStyles(name)) {
            consumables.set(toConsume, false);
          }
        }
      }
    }
  }
  _revert(type, item) {
    const items = isArray_default(item) ? item : [item];
    const consumables = this._consumables[type];
    for (const name of items) {
      if (type === "attributes" && (name === "class" || name === "style")) {
        const consumableName = name == "class" ? "classes" : "styles";
        this._revert(consumableName, [...this._consumables[consumableName].keys()]);
      } else {
        const value = consumables.get(name);
        if (value === false) {
          consumables.set(name, true);
        }
      }
    }
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Schema = class extends ObservableMixin() {
  constructor() {
    super();
    this._sourceDefinitions = {};
    this._attributeProperties = {};
    this.decorate("checkChild");
    this.decorate("checkAttribute");
    this.on("checkAttribute", (evt, args) => {
      args[0] = new SchemaContext(args[0]);
    }, {priority: "highest"});
    this.on("checkChild", (evt, args) => {
      args[0] = new SchemaContext(args[0]);
      args[1] = this.getDefinition(args[1]);
    }, {priority: "highest"});
  }
  register(itemName, definition) {
    if (this._sourceDefinitions[itemName]) {
      throw new ckeditorerror_default("schema-cannot-register-item-twice", this, {
        itemName
      });
    }
    this._sourceDefinitions[itemName] = [
      Object.assign({}, definition)
    ];
    this._clearCache();
  }
  extend(itemName, definition) {
    if (!this._sourceDefinitions[itemName]) {
      throw new ckeditorerror_default("schema-cannot-extend-missing-item", this, {
        itemName
      });
    }
    this._sourceDefinitions[itemName].push(Object.assign({}, definition));
    this._clearCache();
  }
  getDefinitions() {
    if (!this._compiledDefinitions) {
      this._compile();
    }
    return this._compiledDefinitions;
  }
  getDefinition(item) {
    let itemName;
    if (typeof item == "string") {
      itemName = item;
    } else if ("is" in item && (item.is("$text") || item.is("$textProxy"))) {
      itemName = "$text";
    } else {
      itemName = item.name;
    }
    return this.getDefinitions()[itemName];
  }
  isRegistered(item) {
    return !!this.getDefinition(item);
  }
  isBlock(item) {
    const def = this.getDefinition(item);
    return !!(def && def.isBlock);
  }
  isLimit(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isLimit || def.isObject);
  }
  isObject(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);
  }
  isInline(item) {
    const def = this.getDefinition(item);
    return !!(def && def.isInline);
  }
  isSelectable(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isSelectable || def.isObject);
  }
  isContent(item) {
    const def = this.getDefinition(item);
    if (!def) {
      return false;
    }
    return !!(def.isContent || def.isObject);
  }
  checkChild(context, def) {
    if (!def) {
      return false;
    }
    return this._checkContextMatch(def, context);
  }
  checkAttribute(context, attributeName) {
    const def = this.getDefinition(context.last);
    if (!def) {
      return false;
    }
    return def.allowAttributes.includes(attributeName);
  }
  checkMerge(positionOrBaseElement, elementToMerge) {
    if (positionOrBaseElement instanceof position_default2) {
      const nodeBefore = positionOrBaseElement.nodeBefore;
      const nodeAfter = positionOrBaseElement.nodeAfter;
      if (!(nodeBefore instanceof element_default2)) {
        throw new ckeditorerror_default("schema-check-merge-no-element-before", this);
      }
      if (!(nodeAfter instanceof element_default2)) {
        throw new ckeditorerror_default("schema-check-merge-no-element-after", this);
      }
      return this.checkMerge(nodeBefore, nodeAfter);
    }
    for (const child of elementToMerge.getChildren()) {
      if (!this.checkChild(positionOrBaseElement, child)) {
        return false;
      }
    }
    return true;
  }
  addChildCheck(callback) {
    this.on("checkChild", (evt, [ctx, childDef]) => {
      if (!childDef) {
        return;
      }
      const retValue = callback(ctx, childDef);
      if (typeof retValue == "boolean") {
        evt.stop();
        evt.return = retValue;
      }
    }, {priority: "high"});
  }
  addAttributeCheck(callback) {
    this.on("checkAttribute", (evt, [ctx, attributeName]) => {
      const retValue = callback(ctx, attributeName);
      if (typeof retValue == "boolean") {
        evt.stop();
        evt.return = retValue;
      }
    }, {priority: "high"});
  }
  setAttributeProperties(attributeName, properties) {
    this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);
  }
  getAttributeProperties(attributeName) {
    return this._attributeProperties[attributeName] || {};
  }
  getLimitElement(selectionOrRangeOrPosition) {
    let element;
    if (selectionOrRangeOrPosition instanceof position_default2) {
      element = selectionOrRangeOrPosition.parent;
    } else {
      const ranges = selectionOrRangeOrPosition instanceof range_default2 ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges());
      element = ranges.reduce((element2, range) => {
        const rangeCommonAncestor = range.getCommonAncestor();
        if (!element2) {
          return rangeCommonAncestor;
        }
        return element2.getCommonAncestor(rangeCommonAncestor, {includeSelf: true});
      }, null);
    }
    while (!this.isLimit(element)) {
      if (element.parent) {
        element = element.parent;
      } else {
        break;
      }
    }
    return element;
  }
  checkAttributeInSelection(selection, attribute) {
    if (selection.isCollapsed) {
      const firstPosition = selection.getFirstPosition();
      const context = [
        ...firstPosition.getAncestors(),
        new text_default2("", selection.getAttributes())
      ];
      return this.checkAttribute(context, attribute);
    } else {
      const ranges = selection.getRanges();
      for (const range of ranges) {
        for (const value of range) {
          if (this.checkAttribute(value.item, attribute)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  *getValidRanges(ranges, attribute) {
    ranges = convertToMinimalFlatRanges(ranges);
    for (const range of ranges) {
      yield* this._getValidRangesForRange(range, attribute);
    }
  }
  getNearestSelectionRange(position, direction = "both") {
    if (position.root.rootName == "$graveyard") {
      return null;
    }
    if (this.checkChild(position, "$text")) {
      return new range_default2(position);
    }
    let backwardWalker, forwardWalker;
    const limitElement = position.getAncestors().reverse().find((item) => this.isLimit(item)) || position.root;
    if (direction == "both" || direction == "backward") {
      backwardWalker = new treewalker_default2({
        boundaries: range_default2._createIn(limitElement),
        startPosition: position,
        direction: "backward"
      });
    }
    if (direction == "both" || direction == "forward") {
      forwardWalker = new treewalker_default2({
        boundaries: range_default2._createIn(limitElement),
        startPosition: position
      });
    }
    for (const data of combineWalkers(backwardWalker, forwardWalker)) {
      const type = data.walker == backwardWalker ? "elementEnd" : "elementStart";
      const value = data.value;
      if (value.type == type && this.isObject(value.item)) {
        return range_default2._createOn(value.item);
      }
      if (this.checkChild(value.nextPosition, "$text")) {
        return new range_default2(value.nextPosition);
      }
    }
    return null;
  }
  findAllowedParent(position, node) {
    let parent2 = position.parent;
    while (parent2) {
      if (this.checkChild(parent2, node)) {
        return parent2;
      }
      if (this.isLimit(parent2)) {
        return null;
      }
      parent2 = parent2.parent;
    }
    return null;
  }
  setAllowedAttributes(node, attributes, writer) {
    const model = writer.model;
    for (const [attributeName, attributeValue] of Object.entries(attributes)) {
      if (model.schema.checkAttribute(node, attributeName)) {
        writer.setAttribute(attributeName, attributeValue, node);
      }
    }
  }
  removeDisallowedAttributes(nodes, writer) {
    for (const node of nodes) {
      if (node.is("$text")) {
        removeDisallowedAttributeFromNode(this, node, writer);
      } else {
        const rangeInNode = range_default2._createIn(node);
        const positionsInRange = rangeInNode.getPositions();
        for (const position of positionsInRange) {
          const item = position.nodeBefore || position.parent;
          removeDisallowedAttributeFromNode(this, item, writer);
        }
      }
    }
  }
  getAttributesWithProperty(node, propertyName, propertyValue) {
    const attributes = {};
    for (const [attributeName, attributeValue] of node.getAttributes()) {
      const attributeProperties = this.getAttributeProperties(attributeName);
      if (attributeProperties[propertyName] === void 0) {
        continue;
      }
      if (propertyValue === void 0 || propertyValue === attributeProperties[propertyName]) {
        attributes[attributeName] = attributeValue;
      }
    }
    return attributes;
  }
  createContext(context) {
    return new SchemaContext(context);
  }
  _clearCache() {
    this._compiledDefinitions = null;
  }
  _compile() {
    const compiledDefinitions = {};
    const sourceRules = this._sourceDefinitions;
    const itemNames = Object.keys(sourceRules);
    for (const itemName of itemNames) {
      compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);
    }
    for (const itemName of itemNames) {
      compileAllowChildren(compiledDefinitions, itemName);
    }
    for (const itemName of itemNames) {
      compileAllowContentOf(compiledDefinitions, itemName);
    }
    for (const itemName of itemNames) {
      compileAllowWhere(compiledDefinitions, itemName);
    }
    for (const itemName of itemNames) {
      compileAllowAttributesOf(compiledDefinitions, itemName);
      compileInheritPropertiesFrom(compiledDefinitions, itemName);
    }
    for (const itemName of itemNames) {
      cleanUpAllowIn(compiledDefinitions, itemName);
      setupAllowChildren(compiledDefinitions, itemName);
      cleanUpAllowAttributes(compiledDefinitions, itemName);
    }
    this._compiledDefinitions = compiledDefinitions;
  }
  _checkContextMatch(def, context, contextItemIndex = context.length - 1) {
    const contextItem = context.getItem(contextItemIndex);
    if (def.allowIn.includes(contextItem.name)) {
      if (contextItemIndex == 0) {
        return true;
      } else {
        const parentRule = this.getDefinition(contextItem);
        return this._checkContextMatch(parentRule, context, contextItemIndex - 1);
      }
    } else {
      return false;
    }
  }
  *_getValidRangesForRange(range, attribute) {
    let start = range.start;
    let end = range.start;
    for (const item of range.getItems({shallow: true})) {
      if (item.is("element")) {
        yield* this._getValidRangesForRange(range_default2._createIn(item), attribute);
      }
      if (!this.checkAttribute(item, attribute)) {
        if (!start.isEqual(end)) {
          yield new range_default2(start, end);
        }
        start = position_default2._createAfter(item);
      }
      end = position_default2._createAfter(item);
    }
    if (!start.isEqual(end)) {
      yield new range_default2(start, end);
    }
  }
};
var schema_default = Schema;
var SchemaContext = class {
  constructor(context) {
    if (context instanceof SchemaContext) {
      return context;
    }
    let items;
    if (typeof context == "string") {
      items = [context];
    } else if (!Array.isArray(context)) {
      items = context.getAncestors({includeSelf: true});
    } else {
      items = context;
    }
    this._items = items.map(mapContextItem);
  }
  get length() {
    return this._items.length;
  }
  get last() {
    return this._items[this._items.length - 1];
  }
  [Symbol.iterator]() {
    return this._items[Symbol.iterator]();
  }
  push(item) {
    const ctx = new SchemaContext([item]);
    ctx._items = [...this._items, ...ctx._items];
    return ctx;
  }
  getItem(index) {
    return this._items[index];
  }
  *getNames() {
    yield* this._items.map((item) => item.name);
  }
  endsWith(query) {
    return Array.from(this.getNames()).join(" ").endsWith(query);
  }
  startsWith(query) {
    return Array.from(this.getNames()).join(" ").startsWith(query);
  }
};
function compileBaseItemRule(sourceItemRules, itemName) {
  const itemRule = {
    name: itemName,
    allowIn: [],
    allowContentOf: [],
    allowWhere: [],
    allowAttributes: [],
    allowAttributesOf: [],
    allowChildren: [],
    inheritTypesFrom: []
  };
  copyTypes(sourceItemRules, itemRule);
  copyProperty(sourceItemRules, itemRule, "allowIn");
  copyProperty(sourceItemRules, itemRule, "allowContentOf");
  copyProperty(sourceItemRules, itemRule, "allowWhere");
  copyProperty(sourceItemRules, itemRule, "allowAttributes");
  copyProperty(sourceItemRules, itemRule, "allowAttributesOf");
  copyProperty(sourceItemRules, itemRule, "allowChildren");
  copyProperty(sourceItemRules, itemRule, "inheritTypesFrom");
  makeInheritAllWork(sourceItemRules, itemRule);
  return itemRule;
}
function compileAllowChildren(compiledDefinitions, itemName) {
  const item = compiledDefinitions[itemName];
  for (const allowChildrenItem of item.allowChildren) {
    const allowedChildren = compiledDefinitions[allowChildrenItem];
    if (!allowedChildren) {
      continue;
    }
    allowedChildren.allowIn.push(itemName);
  }
  item.allowChildren.length = 0;
}
function compileAllowContentOf(compiledDefinitions, itemName) {
  for (const allowContentOfItemName of compiledDefinitions[itemName].allowContentOf) {
    if (compiledDefinitions[allowContentOfItemName]) {
      const allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);
      allowedChildren.forEach((allowedItem) => {
        allowedItem.allowIn.push(itemName);
      });
    }
  }
  delete compiledDefinitions[itemName].allowContentOf;
}
function compileAllowWhere(compiledDefinitions, itemName) {
  for (const allowWhereItemName of compiledDefinitions[itemName].allowWhere) {
    const inheritFrom = compiledDefinitions[allowWhereItemName];
    if (inheritFrom) {
      const allowedIn = inheritFrom.allowIn;
      compiledDefinitions[itemName].allowIn.push(...allowedIn);
    }
  }
  delete compiledDefinitions[itemName].allowWhere;
}
function compileAllowAttributesOf(compiledDefinitions, itemName) {
  for (const allowAttributeOfItem of compiledDefinitions[itemName].allowAttributesOf) {
    const inheritFrom = compiledDefinitions[allowAttributeOfItem];
    if (inheritFrom) {
      const inheritAttributes = inheritFrom.allowAttributes;
      compiledDefinitions[itemName].allowAttributes.push(...inheritAttributes);
    }
  }
  delete compiledDefinitions[itemName].allowAttributesOf;
}
function compileInheritPropertiesFrom(compiledDefinitions, itemName) {
  const item = compiledDefinitions[itemName];
  for (const inheritPropertiesOfItem of item.inheritTypesFrom) {
    const inheritFrom = compiledDefinitions[inheritPropertiesOfItem];
    if (inheritFrom) {
      const typeNames = Object.keys(inheritFrom).filter((name) => name.startsWith("is"));
      for (const name of typeNames) {
        if (!(name in item)) {
          item[name] = inheritFrom[name];
        }
      }
    }
  }
  delete item.inheritTypesFrom;
}
function cleanUpAllowIn(compiledDefinitions, itemName) {
  const itemRule = compiledDefinitions[itemName];
  const existingItems = itemRule.allowIn.filter((itemToCheck) => compiledDefinitions[itemToCheck]);
  itemRule.allowIn = Array.from(new Set(existingItems));
}
function setupAllowChildren(compiledDefinitions, itemName) {
  const itemRule = compiledDefinitions[itemName];
  for (const allowedParentItemName of itemRule.allowIn) {
    const allowedParentItem = compiledDefinitions[allowedParentItemName];
    allowedParentItem.allowChildren.push(itemName);
  }
}
function cleanUpAllowAttributes(compiledDefinitions, itemName) {
  const itemRule = compiledDefinitions[itemName];
  itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));
}
function copyTypes(sourceItemRules, itemRule) {
  for (const sourceItemRule of sourceItemRules) {
    const typeNames = Object.keys(sourceItemRule).filter((name) => name.startsWith("is"));
    for (const name of typeNames) {
      itemRule[name] = !!sourceItemRule[name];
    }
  }
}
function copyProperty(sourceItemRules, itemRule, propertyName) {
  for (const sourceItemRule of sourceItemRules) {
    const value = sourceItemRule[propertyName];
    if (typeof value == "string") {
      itemRule[propertyName].push(value);
    } else if (Array.isArray(value)) {
      itemRule[propertyName].push(...value);
    }
  }
}
function makeInheritAllWork(sourceItemRules, itemRule) {
  for (const sourceItemRule of sourceItemRules) {
    const inheritFrom = sourceItemRule.inheritAllFrom;
    if (inheritFrom) {
      itemRule.allowContentOf.push(inheritFrom);
      itemRule.allowWhere.push(inheritFrom);
      itemRule.allowAttributesOf.push(inheritFrom);
      itemRule.inheritTypesFrom.push(inheritFrom);
    }
  }
}
function getAllowedChildren(compiledDefinitions, itemName) {
  const itemRule = compiledDefinitions[itemName];
  return getValues(compiledDefinitions).filter((def) => def.allowIn.includes(itemRule.name));
}
function getValues(obj) {
  return Object.keys(obj).map((key) => obj[key]);
}
function mapContextItem(ctxItem) {
  if (typeof ctxItem == "string" || ctxItem.is("documentFragment")) {
    return {
      name: typeof ctxItem == "string" ? ctxItem : "$documentFragment",
      *getAttributeKeys() {
      },
      getAttribute() {
      }
    };
  } else {
    return {
      name: ctxItem.is("element") ? ctxItem.name : "$text",
      *getAttributeKeys() {
        yield* ctxItem.getAttributeKeys();
      },
      getAttribute(key) {
        return ctxItem.getAttribute(key);
      }
    };
  }
}
function* combineWalkers(backward, forward) {
  let done = false;
  while (!done) {
    done = true;
    if (backward) {
      const step = backward.next();
      if (!step.done) {
        done = false;
        yield {
          walker: backward,
          value: step.value
        };
      }
    }
    if (forward) {
      const step = forward.next();
      if (!step.done) {
        done = false;
        yield {
          walker: forward,
          value: step.value
        };
      }
    }
  }
}
function* convertToMinimalFlatRanges(ranges) {
  for (const range of ranges) {
    yield* range.getMinimalFlatRanges();
  }
}
function removeDisallowedAttributeFromNode(schema, node, writer) {
  for (const attribute of node.getAttributeKeys()) {
    if (!schema.checkAttribute(node, attribute)) {
      writer.removeAttribute(attribute, node);
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var UpcastDispatcher = class extends EmitterMixin() {
  constructor(conversionApi) {
    super();
    this._splitParts = new Map();
    this._cursorParents = new Map();
    this._modelCursor = null;
    this._emptyElementsToKeep = new Set();
    this.conversionApi = {
      ...conversionApi,
      consumable: null,
      writer: null,
      store: null,
      convertItem: (viewItem, modelCursor) => this._convertItem(viewItem, modelCursor),
      convertChildren: (viewElement, positionOrElement) => this._convertChildren(viewElement, positionOrElement),
      safeInsert: (modelNode, position) => this._safeInsert(modelNode, position),
      updateConversionResult: (modelElement, data) => this._updateConversionResult(modelElement, data),
      splitToAllowedParent: (modelNode, modelCursor) => this._splitToAllowedParent(modelNode, modelCursor),
      getSplitParts: (modelElement) => this._getSplitParts(modelElement),
      keepEmptyElement: (modelElement) => this._keepEmptyElement(modelElement)
    };
  }
  convert(viewElement, writer, context = ["$root"]) {
    this.fire("viewCleanup", viewElement);
    this._modelCursor = createContextTree(context, writer);
    this.conversionApi.writer = writer;
    this.conversionApi.consumable = viewconsumable_default.createFrom(viewElement);
    this.conversionApi.store = {};
    const {modelRange} = this._convertItem(viewElement, this._modelCursor);
    const documentFragment = writer.createDocumentFragment();
    if (modelRange) {
      this._removeEmptyElements();
      for (const item of Array.from(this._modelCursor.parent.getChildren())) {
        writer.append(item, documentFragment);
      }
      documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);
    }
    this._modelCursor = null;
    this._splitParts.clear();
    this._cursorParents.clear();
    this._emptyElementsToKeep.clear();
    this.conversionApi.writer = null;
    this.conversionApi.store = null;
    return documentFragment;
  }
  _convertItem(viewItem, modelCursor) {
    const data = {viewItem, modelCursor, modelRange: null};
    if (viewItem.is("element")) {
      this.fire(`element:${viewItem.name}`, data, this.conversionApi);
    } else if (viewItem.is("$text")) {
      this.fire("text", data, this.conversionApi);
    } else {
      this.fire("documentFragment", data, this.conversionApi);
    }
    if (data.modelRange && !(data.modelRange instanceof range_default2)) {
      throw new ckeditorerror_default("view-conversion-dispatcher-incorrect-result", this);
    }
    return {modelRange: data.modelRange, modelCursor: data.modelCursor};
  }
  _convertChildren(viewItem, elementOrModelCursor) {
    let nextModelCursor = elementOrModelCursor.is("position") ? elementOrModelCursor : position_default2._createAt(elementOrModelCursor, 0);
    const modelRange = new range_default2(nextModelCursor);
    for (const viewChild of Array.from(viewItem.getChildren())) {
      const result = this._convertItem(viewChild, nextModelCursor);
      if (result.modelRange instanceof range_default2) {
        modelRange.end = result.modelRange.end;
        nextModelCursor = result.modelCursor;
      }
    }
    return {modelRange, modelCursor: nextModelCursor};
  }
  _safeInsert(modelNode, position) {
    const splitResult = this._splitToAllowedParent(modelNode, position);
    if (!splitResult) {
      return false;
    }
    this.conversionApi.writer.insert(modelNode, splitResult.position);
    return true;
  }
  _updateConversionResult(modelElement, data) {
    const parts = this._getSplitParts(modelElement);
    const writer = this.conversionApi.writer;
    if (!data.modelRange) {
      data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));
    }
    const savedCursorParent = this._cursorParents.get(modelElement);
    if (savedCursorParent) {
      data.modelCursor = writer.createPositionAt(savedCursorParent, 0);
    } else {
      data.modelCursor = data.modelRange.end;
    }
  }
  _splitToAllowedParent(node, modelCursor) {
    const {schema, writer} = this.conversionApi;
    let allowedParent = schema.findAllowedParent(modelCursor, node);
    if (allowedParent) {
      if (allowedParent === modelCursor.parent) {
        return {position: modelCursor};
      }
      if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {
        allowedParent = null;
      }
    }
    if (!allowedParent) {
      if (!isParagraphable(modelCursor, node, schema)) {
        return null;
      }
      return {
        position: wrapInParagraph(modelCursor, writer)
      };
    }
    const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent);
    const stack = [];
    for (const treeWalkerValue of splitResult.range.getWalker()) {
      if (treeWalkerValue.type == "elementEnd") {
        stack.push(treeWalkerValue.item);
      } else {
        const originalPart = stack.pop();
        const splitPart = treeWalkerValue.item;
        this._registerSplitPair(originalPart, splitPart);
      }
    }
    const cursorParent = splitResult.range.end.parent;
    this._cursorParents.set(node, cursorParent);
    return {
      position: splitResult.position,
      cursorParent
    };
  }
  _registerSplitPair(originalPart, splitPart) {
    if (!this._splitParts.has(originalPart)) {
      this._splitParts.set(originalPart, [originalPart]);
    }
    const list = this._splitParts.get(originalPart);
    this._splitParts.set(splitPart, list);
    list.push(splitPart);
  }
  _getSplitParts(element) {
    let parts;
    if (!this._splitParts.has(element)) {
      parts = [element];
    } else {
      parts = this._splitParts.get(element);
    }
    return parts;
  }
  _keepEmptyElement(element) {
    this._emptyElementsToKeep.add(element);
  }
  _removeEmptyElements() {
    let anyRemoved = false;
    for (const element of this._splitParts.keys()) {
      if (element.isEmpty && !this._emptyElementsToKeep.has(element)) {
        this.conversionApi.writer.remove(element);
        this._splitParts.delete(element);
        anyRemoved = true;
      }
    }
    if (anyRemoved) {
      this._removeEmptyElements();
    }
  }
};
var upcastdispatcher_default = UpcastDispatcher;
function extractMarkersFromModelFragment(modelItem, writer) {
  const markerElements = new Set();
  const markers = new Map();
  const range = range_default2._createIn(modelItem).getItems();
  for (const item of range) {
    if (item.is("element", "$marker")) {
      markerElements.add(item);
    }
  }
  for (const markerElement of markerElements) {
    const markerName = markerElement.getAttribute("data-name");
    const currentPosition = writer.createPositionBefore(markerElement);
    if (!markers.has(markerName)) {
      markers.set(markerName, new range_default2(currentPosition.clone()));
    } else {
      markers.get(markerName).end = currentPosition.clone();
    }
    writer.remove(markerElement);
  }
  return markers;
}
function createContextTree(contextDefinition, writer) {
  let position;
  for (const item of new SchemaContext(contextDefinition)) {
    const attributes = {};
    for (const key of item.getAttributeKeys()) {
      attributes[key] = item.getAttribute(key);
    }
    const current = writer.createElement(item.name, attributes);
    if (position) {
      writer.insert(current, position);
    }
    position = position_default2._createAt(current, 0);
  }
  return position;
}

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BasicHtmlWriter = class {
  getHtml(fragment) {
    const doc = document.implementation.createHTMLDocument("");
    const container = doc.createElement("div");
    container.appendChild(fragment);
    return container.innerHTML;
  }
};
var basichtmlwriter_default = BasicHtmlWriter;

// node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var HtmlDataProcessor = class {
  constructor(document2) {
    this.skipComments = true;
    this.domParser = new DOMParser();
    this.domConverter = new domconverter_default(document2, {renderingMode: "data"});
    this.htmlWriter = new basichtmlwriter_default();
  }
  toData(viewFragment) {
    const domFragment = this.domConverter.viewToDom(viewFragment);
    return this.htmlWriter.getHtml(domFragment);
  }
  toView(data) {
    const domFragment = this._toDom(data);
    return this.domConverter.domToView(domFragment, {skipComments: this.skipComments});
  }
  registerRawContentMatcher(pattern) {
    this.domConverter.registerRawContentMatcher(pattern);
  }
  useFillerType(type) {
    this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
  }
  _toDom(data) {
    if (!data.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
      data = `<body>${data}</body>`;
    }
    const document2 = this.domParser.parseFromString(data, "text/html");
    const fragment = document2.createDocumentFragment();
    const bodyChildNodes = document2.body.childNodes;
    while (bodyChildNodes.length > 0) {
      fragment.appendChild(bodyChildNodes[0]);
    }
    return fragment;
  }
};
var htmldataprocessor_default = HtmlDataProcessor;

// node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DataController = class extends EmitterMixin() {
  constructor(model, stylesProcessor) {
    super();
    this.model = model;
    this.mapper = new mapper_default();
    this.downcastDispatcher = new downcastdispatcher_default({
      mapper: this.mapper,
      schema: model.schema
    });
    this.downcastDispatcher.on("insert:$text", insertText(), {priority: "lowest"});
    this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {priority: "lowest"});
    this.upcastDispatcher = new upcastdispatcher_default({
      schema: model.schema
    });
    this.viewDocument = new document_default(stylesProcessor);
    this.stylesProcessor = stylesProcessor;
    this.htmlProcessor = new htmldataprocessor_default(this.viewDocument);
    this.processor = this.htmlProcessor;
    this._viewWriter = new downcastwriter_default(this.viewDocument);
    this.upcastDispatcher.on("text", convertText(), {priority: "lowest"});
    this.upcastDispatcher.on("element", convertToModelFragment(), {priority: "lowest"});
    this.upcastDispatcher.on("documentFragment", convertToModelFragment(), {priority: "lowest"});
    ObservableMixin().prototype.decorate.call(this, "init");
    ObservableMixin().prototype.decorate.call(this, "set");
    ObservableMixin().prototype.decorate.call(this, "get");
    ObservableMixin().prototype.decorate.call(this, "toView");
    ObservableMixin().prototype.decorate.call(this, "toModel");
    this.on("init", () => {
      this.fire("ready");
    }, {priority: "lowest"});
    this.on("ready", () => {
      this.model.enqueueChange({isUndoable: false}, autoParagraphEmptyRoots);
    }, {priority: "lowest"});
  }
  get(options = {}) {
    const {rootName = "main", trim = "empty"} = options;
    if (!this._checkIfRootsExists([rootName])) {
      throw new ckeditorerror_default("datacontroller-get-non-existent-root", this);
    }
    const root2 = this.model.document.getRoot(rootName);
    if (!root2.isAttached()) {
      logWarning("datacontroller-get-detached-root", this);
    }
    if (trim === "empty" && !this.model.hasContent(root2, {ignoreWhitespaces: true})) {
      return "";
    }
    return this.stringify(root2, options);
  }
  stringify(modelElementOrFragment, options = {}) {
    const viewDocumentFragment = this.toView(modelElementOrFragment, options);
    return this.processor.toData(viewDocumentFragment);
  }
  toView(modelElementOrFragment, options = {}) {
    const viewDocument = this.viewDocument;
    const viewWriter = this._viewWriter;
    this.mapper.clearBindings();
    const modelRange = range_default2._createIn(modelElementOrFragment);
    const viewDocumentFragment = new documentfragment_default(viewDocument);
    this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment);
    const markers = modelElementOrFragment.is("documentFragment") ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);
    this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);
    return viewDocumentFragment;
  }
  init(data) {
    if (this.model.document.version) {
      throw new ckeditorerror_default("datacontroller-init-document-not-empty", this);
    }
    let initialData = {};
    if (typeof data === "string") {
      initialData.main = data;
    } else {
      initialData = data;
    }
    if (!this._checkIfRootsExists(Object.keys(initialData))) {
      throw new ckeditorerror_default("datacontroller-init-non-existent-root", this);
    }
    this.model.enqueueChange({isUndoable: false}, (writer) => {
      for (const rootName of Object.keys(initialData)) {
        const modelRoot = this.model.document.getRoot(rootName);
        writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);
      }
    });
    return Promise.resolve();
  }
  set(data, options = {}) {
    let newData = {};
    if (typeof data === "string") {
      newData.main = data;
    } else {
      newData = data;
    }
    if (!this._checkIfRootsExists(Object.keys(newData))) {
      throw new ckeditorerror_default("datacontroller-set-non-existent-root", this);
    }
    this.model.enqueueChange(options.batchType || {}, (writer) => {
      writer.setSelection(null);
      writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
      for (const rootName of Object.keys(newData)) {
        const modelRoot = this.model.document.getRoot(rootName);
        writer.remove(writer.createRangeIn(modelRoot));
        writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);
      }
    });
  }
  parse(data, context = "$root") {
    const viewDocumentFragment = this.processor.toView(data);
    return this.toModel(viewDocumentFragment, context);
  }
  toModel(viewElementOrFragment, context = "$root") {
    return this.model.change((writer) => {
      return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);
    });
  }
  addStyleProcessorRules(callback) {
    callback(this.stylesProcessor);
  }
  registerRawContentMatcher(pattern) {
    if (this.processor && this.processor !== this.htmlProcessor) {
      this.processor.registerRawContentMatcher(pattern);
    }
    this.htmlProcessor.registerRawContentMatcher(pattern);
  }
  destroy() {
    this.stopListening();
  }
  _checkIfRootsExists(rootNames) {
    for (const rootName of rootNames) {
      if (!this.model.document.getRoot(rootName)) {
        return false;
      }
    }
    return true;
  }
};
var datacontroller_default = DataController;
function _getMarkersRelativeToElement(element) {
  const result = [];
  const doc = element.root.document;
  if (!doc) {
    return new Map();
  }
  const elementRange = range_default2._createIn(element);
  for (const marker of doc.model.markers) {
    const markerRange = marker.getRange();
    const isMarkerCollapsed = markerRange.isCollapsed;
    const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);
    if (isMarkerCollapsed && isMarkerAtElementBoundary) {
      result.push([marker.name, markerRange]);
    } else {
      const updatedMarkerRange = elementRange.getIntersection(markerRange);
      if (updatedMarkerRange) {
        result.push([marker.name, updatedMarkerRange]);
      }
    }
  }
  result.sort(([n1, r1], [n2, r2]) => {
    if (r1.end.compareWith(r2.start) !== "after") {
      return 1;
    } else if (r1.start.compareWith(r2.end) !== "before") {
      return -1;
    } else {
      switch (r1.start.compareWith(r2.start)) {
        case "before":
          return 1;
        case "after":
          return -1;
        default:
          switch (r1.end.compareWith(r2.end)) {
            case "before":
              return 1;
            case "after":
              return -1;
            default:
              return n2.localeCompare(n1);
          }
      }
    }
  });
  return new Map(result);
}

// node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Conversion = class {
  constructor(downcastDispatchers, upcastDispatchers) {
    this._helpers = new Map();
    this._downcast = toArray(downcastDispatchers);
    this._createConversionHelpers({name: "downcast", dispatchers: this._downcast, isDowncast: true});
    this._upcast = toArray(upcastDispatchers);
    this._createConversionHelpers({name: "upcast", dispatchers: this._upcast, isDowncast: false});
  }
  addAlias(alias, dispatcher) {
    const isDowncast = this._downcast.includes(dispatcher);
    const isUpcast = this._upcast.includes(dispatcher);
    if (!isUpcast && !isDowncast) {
      throw new ckeditorerror_default("conversion-add-alias-dispatcher-not-registered", this);
    }
    this._createConversionHelpers({name: alias, dispatchers: [dispatcher], isDowncast});
  }
  for(groupName) {
    if (!this._helpers.has(groupName)) {
      throw new ckeditorerror_default("conversion-for-unknown-group", this);
    }
    return this._helpers.get(groupName);
  }
  elementToElement(definition) {
    this.for("downcast").elementToElement(definition);
    for (const {model, view} of _getAllUpcastDefinitions(definition)) {
      this.for("upcast").elementToElement({
        model,
        view,
        converterPriority: definition.converterPriority
      });
    }
  }
  attributeToElement(definition) {
    this.for("downcast").attributeToElement(definition);
    for (const {model, view} of _getAllUpcastDefinitions(definition)) {
      this.for("upcast").elementToAttribute({
        view,
        model,
        converterPriority: definition.converterPriority
      });
    }
  }
  attributeToAttribute(definition) {
    this.for("downcast").attributeToAttribute(definition);
    for (const {model, view} of _getAllUpcastDefinitions(definition)) {
      this.for("upcast").attributeToAttribute({
        view,
        model
      });
    }
  }
  _createConversionHelpers({name, dispatchers, isDowncast}) {
    if (this._helpers.has(name)) {
      throw new ckeditorerror_default("conversion-group-exists", this);
    }
    const helpers = isDowncast ? new downcasthelpers_default(dispatchers) : new upcasthelpers_default(dispatchers);
    this._helpers.set(name, helpers);
  }
};
var conversion_default = Conversion;
function* _getAllUpcastDefinitions(definition) {
  if (definition.model.values) {
    for (const value of definition.model.values) {
      const model = {key: definition.model.key, value};
      const view = definition.view[value];
      const upcastAlso = definition.upcastAlso ? definition.upcastAlso[value] : void 0;
      yield* _getUpcastDefinition(model, view, upcastAlso);
    }
  } else {
    yield* _getUpcastDefinition(definition.model, definition.view, definition.upcastAlso);
  }
}
function* _getUpcastDefinition(model, view, upcastAlso) {
  yield {model, view};
  if (upcastAlso) {
    for (const upcastAlsoItem of toArray(upcastAlso)) {
      yield {model, view: upcastAlsoItem};
    }
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/operation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Operation = class {
  constructor(baseVersion) {
    this.baseVersion = baseVersion;
    this.isDocumentOperation = this.baseVersion !== null;
    this.batch = null;
  }
  _validate() {
  }
  toJSON() {
    const json = Object.assign({}, this);
    json.__className = this.constructor.className;
    delete json.batch;
    delete json.isDocumentOperation;
    return json;
  }
  static get className() {
    return "Operation";
  }
  static fromJSON(json, document2) {
    return new this(json.baseVersion);
  }
};
var operation_default = Operation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function _insert(position, nodes) {
  const normalizedNodes = _normalizeNodes(nodes);
  const offset = normalizedNodes.reduce((sum, node) => sum + node.offsetSize, 0);
  const parent2 = position.parent;
  _splitNodeAtPosition(position);
  const index = position.index;
  parent2._insertChild(index, normalizedNodes);
  _mergeNodesAtIndex(parent2, index + normalizedNodes.length);
  _mergeNodesAtIndex(parent2, index);
  return new range_default2(position, position.getShiftedBy(offset));
}
function _remove(range) {
  if (!range.isFlat) {
    throw new ckeditorerror_default("operation-utils-remove-range-not-flat", this);
  }
  const parent2 = range.start.parent;
  _splitNodeAtPosition(range.start);
  _splitNodeAtPosition(range.end);
  const removed = parent2._removeChildren(range.start.index, range.end.index - range.start.index);
  _mergeNodesAtIndex(parent2, range.start.index);
  return removed;
}
function _move(sourceRange, targetPosition) {
  if (!sourceRange.isFlat) {
    throw new ckeditorerror_default("operation-utils-move-range-not-flat", this);
  }
  const nodes = _remove(sourceRange);
  targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);
  return _insert(targetPosition, nodes);
}
function _setAttribute(range, key, value) {
  _splitNodeAtPosition(range.start);
  _splitNodeAtPosition(range.end);
  for (const item of range.getItems({shallow: true})) {
    const node = item.is("$textProxy") ? item.textNode : item;
    if (value !== null) {
      node._setAttribute(key, value);
    } else {
      node._removeAttribute(key);
    }
    _mergeNodesAtIndex(node.parent, node.index);
  }
  _mergeNodesAtIndex(range.end.parent, range.end.index);
}
function _normalizeNodes(nodes) {
  const normalized = [];
  function convert2(nodes2) {
    if (typeof nodes2 == "string") {
      normalized.push(new text_default2(nodes2));
    } else if (nodes2 instanceof textproxy_default2) {
      normalized.push(new text_default2(nodes2.data, nodes2.getAttributes()));
    } else if (nodes2 instanceof node_default2) {
      normalized.push(nodes2);
    } else if (isIterable(nodes2)) {
      for (const node of nodes2) {
        convert2(node);
      }
    }
  }
  convert2(nodes);
  for (let i = 1; i < normalized.length; i++) {
    const node = normalized[i];
    const prev = normalized[i - 1];
    if (node instanceof text_default2 && prev instanceof text_default2 && _haveSameAttributes(node, prev)) {
      normalized.splice(i - 1, 2, new text_default2(prev.data + node.data, prev.getAttributes()));
      i--;
    }
  }
  return normalized;
}
function _mergeNodesAtIndex(element, index) {
  const nodeBefore = element.getChild(index - 1);
  const nodeAfter = element.getChild(index);
  if (nodeBefore && nodeAfter && nodeBefore.is("$text") && nodeAfter.is("$text") && _haveSameAttributes(nodeBefore, nodeAfter)) {
    const mergedNode = new text_default2(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());
    element._removeChildren(index - 1, 2);
    element._insertChild(index - 1, mergedNode);
  }
}
function _splitNodeAtPosition(position) {
  const textNode = position.textNode;
  const element = position.parent;
  if (textNode) {
    const offsetDiff = position.offset - textNode.startOffset;
    const index = textNode.index;
    element._removeChildren(index, 1);
    const firstPart = new text_default2(textNode.data.substr(0, offsetDiff), textNode.getAttributes());
    const secondPart = new text_default2(textNode.data.substr(offsetDiff), textNode.getAttributes());
    element._insertChild(index, [firstPart, secondPart]);
  }
}
function _haveSameAttributes(nodeA, nodeB) {
  const iteratorA = nodeA.getAttributes();
  const iteratorB = nodeB.getAttributes();
  for (const attr of iteratorA) {
    if (attr[1] !== nodeB.getAttribute(attr[0])) {
      return false;
    }
    iteratorB.next();
  }
  return iteratorB.next().done;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/moveoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MoveOperation = class extends operation_default {
  constructor(sourcePosition, howMany, targetPosition, baseVersion) {
    super(baseVersion);
    this.sourcePosition = sourcePosition.clone();
    this.sourcePosition.stickiness = "toNext";
    this.howMany = howMany;
    this.targetPosition = targetPosition.clone();
    this.targetPosition.stickiness = "toNone";
  }
  get type() {
    if (this.targetPosition.root.rootName == "$graveyard") {
      return "remove";
    } else if (this.sourcePosition.root.rootName == "$graveyard") {
      return "reinsert";
    }
    return "move";
  }
  get affectedSelectable() {
    return [
      range_default2._createFromPositionAndShift(this.sourcePosition, this.howMany),
      range_default2._createFromPositionAndShift(this.targetPosition, 0)
    ];
  }
  clone() {
    return new MoveOperation(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
  }
  getMovedRangeStart() {
    return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
  }
  getReversed() {
    const newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
    return new MoveOperation(this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1);
  }
  _validate() {
    const sourceElement = this.sourcePosition.parent;
    const targetElement = this.targetPosition.parent;
    const sourceOffset = this.sourcePosition.offset;
    const targetOffset = this.targetPosition.offset;
    if (sourceOffset + this.howMany > sourceElement.maxOffset) {
      throw new ckeditorerror_default("move-operation-nodes-do-not-exist", this);
    } else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
      throw new ckeditorerror_default("move-operation-range-into-itself", this);
    } else if (this.sourcePosition.root == this.targetPosition.root) {
      if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
        const i = this.sourcePosition.path.length - 1;
        if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {
          throw new ckeditorerror_default("move-operation-node-into-itself", this);
        }
      }
    }
  }
  _execute() {
    _move(range_default2._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
  }
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = this.sourcePosition.toJSON();
    json.targetPosition = this.targetPosition.toJSON();
    return json;
  }
  static get className() {
    return "MoveOperation";
  }
  static fromJSON(json, document2) {
    const sourcePosition = position_default2.fromJSON(json.sourcePosition, document2);
    const targetPosition = position_default2.fromJSON(json.targetPosition, document2);
    return new this(sourcePosition, json.howMany, targetPosition, json.baseVersion);
  }
};
var moveoperation_default = MoveOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/insertoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InsertOperation = class extends operation_default {
  constructor(position, nodes, baseVersion) {
    super(baseVersion);
    this.position = position.clone();
    this.position.stickiness = "toNone";
    this.nodes = new nodelist_default(_normalizeNodes(nodes));
    this.shouldReceiveAttributes = false;
  }
  get type() {
    return "insert";
  }
  get howMany() {
    return this.nodes.maxOffset;
  }
  get affectedSelectable() {
    return this.position.clone();
  }
  clone() {
    const nodes = new nodelist_default([...this.nodes].map((node) => node._clone(true)));
    const insert = new InsertOperation(this.position, nodes, this.baseVersion);
    insert.shouldReceiveAttributes = this.shouldReceiveAttributes;
    return insert;
  }
  getReversed() {
    const graveyard = this.position.root.document.graveyard;
    const gyPosition = new position_default2(graveyard, [0]);
    return new moveoperation_default(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);
  }
  _validate() {
    const targetElement = this.position.parent;
    if (!targetElement || targetElement.maxOffset < this.position.offset) {
      throw new ckeditorerror_default("insert-operation-position-invalid", this);
    }
  }
  _execute() {
    const originalNodes = this.nodes;
    this.nodes = new nodelist_default([...originalNodes].map((node) => node._clone(true)));
    _insert(this.position, originalNodes);
  }
  toJSON() {
    const json = super.toJSON();
    json.position = this.position.toJSON();
    json.nodes = this.nodes.toJSON();
    return json;
  }
  static get className() {
    return "InsertOperation";
  }
  static fromJSON(json, document2) {
    const children = [];
    for (const child of json.nodes) {
      if (child.name) {
        children.push(element_default2.fromJSON(child));
      } else {
        children.push(text_default2.fromJSON(child));
      }
    }
    const insert = new InsertOperation(position_default2.fromJSON(json.position, document2), children, json.baseVersion);
    insert.shouldReceiveAttributes = json.shouldReceiveAttributes;
    return insert;
  }
};
var insertoperation_default = InsertOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/splitoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SplitOperation = class extends operation_default {
  constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {
    super(baseVersion);
    this.splitPosition = splitPosition.clone();
    this.splitPosition.stickiness = "toNext";
    this.howMany = howMany;
    this.insertionPosition = insertionPosition;
    this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;
    if (this.graveyardPosition) {
      this.graveyardPosition.stickiness = "toNext";
    }
  }
  get type() {
    return "split";
  }
  get moveTargetPosition() {
    const path = this.insertionPosition.path.slice();
    path.push(0);
    return new position_default2(this.insertionPosition.root, path);
  }
  get movedRange() {
    const end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new range_default2(this.splitPosition, end);
  }
  get affectedSelectable() {
    const ranges = [
      range_default2._createFromPositionAndShift(this.splitPosition, 0),
      range_default2._createFromPositionAndShift(this.insertionPosition, 0)
    ];
    if (this.graveyardPosition) {
      ranges.push(range_default2._createFromPositionAndShift(this.graveyardPosition, 0));
    }
    return ranges;
  }
  clone() {
    return new SplitOperation(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
  }
  getReversed() {
    const graveyard = this.splitPosition.root.document.graveyard;
    const graveyardPosition = new position_default2(graveyard, [0]);
    return new mergeoperation_default(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);
  }
  _validate() {
    const element = this.splitPosition.parent;
    const offset = this.splitPosition.offset;
    if (!element || element.maxOffset < offset) {
      throw new ckeditorerror_default("split-operation-position-invalid", this);
    } else if (!element.parent) {
      throw new ckeditorerror_default("split-operation-split-in-root", this);
    } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {
      throw new ckeditorerror_default("split-operation-how-many-invalid", this);
    } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
      throw new ckeditorerror_default("split-operation-graveyard-position-invalid", this);
    }
  }
  _execute() {
    const splitElement = this.splitPosition.parent;
    if (this.graveyardPosition) {
      _move(range_default2._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
    } else {
      const newElement = splitElement._clone();
      _insert(this.insertionPosition, newElement);
    }
    const sourceRange = new range_default2(position_default2._createAt(splitElement, this.splitPosition.offset), position_default2._createAt(splitElement, splitElement.maxOffset));
    _move(sourceRange, this.moveTargetPosition);
  }
  toJSON() {
    const json = super.toJSON();
    json.splitPosition = this.splitPosition.toJSON();
    json.insertionPosition = this.insertionPosition.toJSON();
    if (this.graveyardPosition) {
      json.graveyardPosition = this.graveyardPosition.toJSON();
    }
    return json;
  }
  static get className() {
    return "SplitOperation";
  }
  static getInsertionPosition(splitPosition) {
    const path = splitPosition.path.slice(0, -1);
    path[path.length - 1]++;
    return new position_default2(splitPosition.root, path, "toPrevious");
  }
  static fromJSON(json, document2) {
    const splitPosition = position_default2.fromJSON(json.splitPosition, document2);
    const insertionPosition = position_default2.fromJSON(json.insertionPosition, document2);
    const graveyardPosition = json.graveyardPosition ? position_default2.fromJSON(json.graveyardPosition, document2) : null;
    return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);
  }
};
var splitoperation_default = SplitOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/mergeoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MergeOperation = class extends operation_default {
  constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {
    super(baseVersion);
    this.sourcePosition = sourcePosition.clone();
    this.sourcePosition.stickiness = "toPrevious";
    this.howMany = howMany;
    this.targetPosition = targetPosition.clone();
    this.targetPosition.stickiness = "toNext";
    this.graveyardPosition = graveyardPosition.clone();
  }
  get type() {
    return "merge";
  }
  get deletionPosition() {
    return new position_default2(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
  }
  get movedRange() {
    const end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
    return new range_default2(this.sourcePosition, end);
  }
  get affectedSelectable() {
    const mergedElement = this.sourcePosition.parent;
    return [
      range_default2._createOn(mergedElement),
      range_default2._createFromPositionAndShift(this.targetPosition, 0),
      range_default2._createFromPositionAndShift(this.graveyardPosition, 0)
    ];
  }
  clone() {
    return new MergeOperation(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
  }
  getReversed() {
    const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);
    const path = this.sourcePosition.path.slice(0, -1);
    const insertionPosition = new position_default2(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);
    return new splitoperation_default(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);
  }
  _validate() {
    const sourceElement = this.sourcePosition.parent;
    const targetElement = this.targetPosition.parent;
    if (!sourceElement.parent) {
      throw new ckeditorerror_default("merge-operation-source-position-invalid", this);
    } else if (!targetElement.parent) {
      throw new ckeditorerror_default("merge-operation-target-position-invalid", this);
    } else if (this.howMany != sourceElement.maxOffset) {
      throw new ckeditorerror_default("merge-operation-how-many-invalid", this);
    }
  }
  _execute() {
    const mergedElement = this.sourcePosition.parent;
    const sourceRange = range_default2._createIn(mergedElement);
    _move(sourceRange, this.targetPosition);
    _move(range_default2._createOn(mergedElement), this.graveyardPosition);
  }
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = json.sourcePosition.toJSON();
    json.targetPosition = json.targetPosition.toJSON();
    json.graveyardPosition = json.graveyardPosition.toJSON();
    return json;
  }
  static get className() {
    return "MergeOperation";
  }
  static fromJSON(json, document2) {
    const sourcePosition = position_default2.fromJSON(json.sourcePosition, document2);
    const targetPosition = position_default2.fromJSON(json.targetPosition, document2);
    const graveyardPosition = position_default2.fromJSON(json.graveyardPosition, document2);
    return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);
  }
};
var mergeoperation_default = MergeOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/markeroperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MarkerOperation = class extends operation_default {
  constructor(name, oldRange, newRange, markers, affectsData, baseVersion) {
    super(baseVersion);
    this.name = name;
    this.oldRange = oldRange ? oldRange.clone() : null;
    this.newRange = newRange ? newRange.clone() : null;
    this.affectsData = affectsData;
    this._markers = markers;
  }
  get type() {
    return "marker";
  }
  get affectedSelectable() {
    const ranges = [];
    if (this.oldRange) {
      ranges.push(this.oldRange.clone());
    }
    if (this.newRange) {
      if (this.oldRange) {
        ranges.push(...this.newRange.getDifference(this.oldRange));
      } else {
        ranges.push(this.newRange.clone());
      }
    }
    return ranges;
  }
  clone() {
    return new MarkerOperation(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
  }
  getReversed() {
    return new MarkerOperation(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
  }
  _execute() {
    if (this.newRange) {
      this._markers._set(this.name, this.newRange, true, this.affectsData);
    } else {
      this._markers._remove(this.name);
    }
  }
  toJSON() {
    const json = super.toJSON();
    if (this.oldRange) {
      json.oldRange = this.oldRange.toJSON();
    }
    if (this.newRange) {
      json.newRange = this.newRange.toJSON();
    }
    delete json._markers;
    return json;
  }
  static get className() {
    return "MarkerOperation";
  }
  static fromJSON(json, document2) {
    return new MarkerOperation(json.name, json.oldRange ? range_default2.fromJSON(json.oldRange, document2) : null, json.newRange ? range_default2.fromJSON(json.newRange, document2) : null, document2.model.markers, json.affectsData, json.baseVersion);
  }
};
var markeroperation_default = MarkerOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/attributeoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var AttributeOperation = class extends operation_default {
  constructor(range, key, oldValue, newValue, baseVersion) {
    super(baseVersion);
    this.range = range.clone();
    this.key = key;
    this.oldValue = oldValue === void 0 ? null : oldValue;
    this.newValue = newValue === void 0 ? null : newValue;
  }
  get type() {
    if (this.oldValue === null) {
      return "addAttribute";
    } else if (this.newValue === null) {
      return "removeAttribute";
    } else {
      return "changeAttribute";
    }
  }
  get affectedSelectable() {
    return this.range.clone();
  }
  clone() {
    return new AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  getReversed() {
    return new AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  toJSON() {
    const json = super.toJSON();
    json.range = this.range.toJSON();
    return json;
  }
  _validate() {
    if (!this.range.isFlat) {
      throw new ckeditorerror_default("attribute-operation-range-not-flat", this);
    }
    for (const item of this.range.getItems({shallow: true})) {
      if (this.oldValue !== null && !isEqual_default(item.getAttribute(this.key), this.oldValue)) {
        throw new ckeditorerror_default("attribute-operation-wrong-old-value", this, {item, key: this.key, value: this.oldValue});
      }
      if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
        throw new ckeditorerror_default("attribute-operation-attribute-exists", this, {node: item, key: this.key});
      }
    }
  }
  _execute() {
    if (!isEqual_default(this.oldValue, this.newValue)) {
      _setAttribute(this.range, this.key, this.newValue);
    }
  }
  static get className() {
    return "AttributeOperation";
  }
  static fromJSON(json, document2) {
    return new AttributeOperation(range_default2.fromJSON(json.range, document2), json.key, json.oldValue, json.newValue, json.baseVersion);
  }
};
var attributeoperation_default = AttributeOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/nooperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var NoOperation = class extends operation_default {
  get type() {
    return "noop";
  }
  get affectedSelectable() {
    return null;
  }
  clone() {
    return new NoOperation(this.baseVersion);
  }
  getReversed() {
    return new NoOperation(this.baseVersion + 1);
  }
  _execute() {
  }
  static get className() {
    return "NoOperation";
  }
};
var nooperation_default = NoOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/renameoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var RenameOperation = class extends operation_default {
  constructor(position, oldName, newName, baseVersion) {
    super(baseVersion);
    this.position = position;
    this.position.stickiness = "toNext";
    this.oldName = oldName;
    this.newName = newName;
  }
  get type() {
    return "rename";
  }
  get affectedSelectable() {
    return this.position.nodeAfter;
  }
  clone() {
    return new RenameOperation(this.position.clone(), this.oldName, this.newName, this.baseVersion);
  }
  getReversed() {
    return new RenameOperation(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
  }
  _validate() {
    const element = this.position.nodeAfter;
    if (!(element instanceof element_default2)) {
      throw new ckeditorerror_default("rename-operation-wrong-position", this);
    } else if (element.name !== this.oldName) {
      throw new ckeditorerror_default("rename-operation-wrong-name", this);
    }
  }
  _execute() {
    const element = this.position.nodeAfter;
    element.name = this.newName;
  }
  toJSON() {
    const json = super.toJSON();
    json.position = this.position.toJSON();
    return json;
  }
  static get className() {
    return "RenameOperation";
  }
  static fromJSON(json, document2) {
    return new RenameOperation(position_default2.fromJSON(json.position, document2), json.oldName, json.newName, json.baseVersion);
  }
};
var renameoperation_default = RenameOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/rootattributeoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var RootAttributeOperation = class extends operation_default {
  constructor(root2, key, oldValue, newValue, baseVersion) {
    super(baseVersion);
    this.root = root2;
    this.key = key;
    this.oldValue = oldValue === void 0 ? null : oldValue;
    this.newValue = newValue === void 0 ? null : newValue;
  }
  get type() {
    if (this.oldValue === null) {
      return "addRootAttribute";
    } else if (this.newValue === null) {
      return "removeRootAttribute";
    } else {
      return "changeRootAttribute";
    }
  }
  get affectedSelectable() {
    return this.root;
  }
  clone() {
    return new RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
  }
  getReversed() {
    return new RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
  }
  _validate() {
    if (this.root != this.root.root || this.root.is("documentFragment")) {
      throw new ckeditorerror_default("rootattribute-operation-not-a-root", this, {root: this.root, key: this.key});
    }
    if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
      throw new ckeditorerror_default("rootattribute-operation-wrong-old-value", this, {root: this.root, key: this.key});
    }
    if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
      throw new ckeditorerror_default("rootattribute-operation-attribute-exists", this, {root: this.root, key: this.key});
    }
  }
  _execute() {
    if (this.newValue !== null) {
      this.root._setAttribute(this.key, this.newValue);
    } else {
      this.root._removeAttribute(this.key);
    }
  }
  toJSON() {
    const json = super.toJSON();
    json.root = this.root.toJSON();
    return json;
  }
  static get className() {
    return "RootAttributeOperation";
  }
  static fromJSON(json, document2) {
    if (!document2.getRoot(json.root)) {
      throw new ckeditorerror_default("rootattribute-operation-fromjson-no-root", this, {rootName: json.root});
    }
    return new RootAttributeOperation(document2.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
  }
};
var rootattributeoperation_default = RootAttributeOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/rootoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var RootOperation = class extends operation_default {
  constructor(rootName, elementName, isAdd, document2, baseVersion) {
    super(baseVersion);
    this.rootName = rootName;
    this.elementName = elementName;
    this.isAdd = isAdd;
    this._document = document2;
    if (!this._document.getRoot(this.rootName)) {
      const root2 = this._document.createRoot(this.elementName, this.rootName);
      root2._isAttached = false;
    }
  }
  get type() {
    return this.isAdd ? "addRoot" : "detachRoot";
  }
  get affectedSelectable() {
    return this._document.getRoot(this.rootName);
  }
  clone() {
    return new RootOperation(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
  }
  getReversed() {
    return new RootOperation(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
  }
  _execute() {
    this._document.getRoot(this.rootName)._isAttached = this.isAdd;
  }
  toJSON() {
    const json = super.toJSON();
    delete json._document;
    return json;
  }
  static get className() {
    return "RootOperation";
  }
  static fromJSON(json, document2) {
    return new RootOperation(json.rootName, json.elementName, json.isAdd, document2, json.baseVersion);
  }
};
var rootoperation_default = RootOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/operationfactory.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var operations = {};
operations[attributeoperation_default.className] = attributeoperation_default;
operations[insertoperation_default.className] = insertoperation_default;
operations[markeroperation_default.className] = markeroperation_default;
operations[moveoperation_default.className] = moveoperation_default;
operations[nooperation_default.className] = nooperation_default;
operations[operation_default.className] = operation_default;
operations[renameoperation_default.className] = renameoperation_default;
operations[rootattributeoperation_default.className] = rootattributeoperation_default;
operations[rootoperation_default.className] = rootoperation_default;
operations[splitoperation_default.className] = splitoperation_default;
operations[mergeoperation_default.className] = mergeoperation_default;
var OperationFactory = class {
  static fromJSON(json, document2) {
    return operations[json.__className].fromJSON(json, document2);
  }
};
var operationfactory_default = OperationFactory;

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var transformations = new Map();
function setTransformation(OperationA, OperationB, transformationFunction) {
  let aGroup = transformations.get(OperationA);
  if (!aGroup) {
    aGroup = new Map();
    transformations.set(OperationA, aGroup);
  }
  aGroup.set(OperationB, transformationFunction);
}
function getTransformation(OperationA, OperationB) {
  const aGroup = transformations.get(OperationA);
  if (aGroup && aGroup.has(OperationB)) {
    return aGroup.get(OperationB);
  }
  return noUpdateTransformation;
}
function noUpdateTransformation(a) {
  return [a];
}
function transform2(a, b, context = {}) {
  const transformationFunction = getTransformation(a.constructor, b.constructor);
  try {
    a = a.clone();
    return transformationFunction(a, b, context);
  } catch (e) {
    throw e;
  }
}
function transformSets(operationsA, operationsB, options) {
  operationsA = operationsA.slice();
  operationsB = operationsB.slice();
  const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);
  contextFactory.setOriginalOperations(operationsA);
  contextFactory.setOriginalOperations(operationsB);
  const originalOperations = contextFactory.originalOperations;
  if (operationsA.length == 0 || operationsB.length == 0) {
    return {operationsA, operationsB, originalOperations};
  }
  const nextTransformIndex = new WeakMap();
  for (const op of operationsA) {
    nextTransformIndex.set(op, 0);
  }
  const data = {
    nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,
    nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,
    originalOperationsACount: operationsA.length,
    originalOperationsBCount: operationsB.length
  };
  let i = 0;
  while (i < operationsA.length) {
    const opA = operationsA[i];
    const indexB = nextTransformIndex.get(opA);
    if (indexB == operationsB.length) {
      i++;
      continue;
    }
    const opB = operationsB[indexB];
    const newOpsA = transform2(opA, opB, contextFactory.getContext(opA, opB, true));
    const newOpsB = transform2(opB, opA, contextFactory.getContext(opB, opA, false));
    contextFactory.updateRelation(opA, opB);
    contextFactory.setOriginalOperations(newOpsA, opA);
    contextFactory.setOriginalOperations(newOpsB, opB);
    for (const newOpA of newOpsA) {
      nextTransformIndex.set(newOpA, indexB + newOpsB.length);
    }
    operationsA.splice(i, 1, ...newOpsA);
    operationsB.splice(indexB, 1, ...newOpsB);
  }
  if (options.padWithNoOps) {
    const brokenOperationsACount = operationsA.length - data.originalOperationsACount;
    const brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;
    padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);
    padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);
  }
  updateBaseVersions(operationsA, data.nextBaseVersionB);
  updateBaseVersions(operationsB, data.nextBaseVersionA);
  return {operationsA, operationsB, originalOperations};
}
var ContextFactory = class {
  constructor(document2, useRelations, forceWeakRemove = false) {
    this.originalOperations = new Map();
    this._history = document2.history;
    this._useRelations = useRelations;
    this._forceWeakRemove = !!forceWeakRemove;
    this._relations = new Map();
  }
  setOriginalOperations(operations2, takeFrom = null) {
    const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;
    for (const operation of operations2) {
      this.originalOperations.set(operation, originalOperation || operation);
    }
  }
  updateRelation(opA, opB) {
    if (opA instanceof moveoperation_default) {
      if (opB instanceof mergeoperation_default) {
        if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {
          this._setRelation(opA, opB, "insertAtSource");
        } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {
          this._setRelation(opA, opB, "insertBetween");
        } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {
          this._setRelation(opA, opB, "moveTargetAfter");
        }
      } else if (opB instanceof moveoperation_default) {
        if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "insertBefore");
        } else {
          this._setRelation(opA, opB, "insertAfter");
        }
      }
    } else if (opA instanceof splitoperation_default) {
      if (opB instanceof mergeoperation_default) {
        if (opA.splitPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "splitBefore");
        }
      } else if (opB instanceof moveoperation_default) {
        if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {
          this._setRelation(opA, opB, "splitBefore");
        } else {
          const range = range_default2._createFromPositionAndShift(opB.sourcePosition, opB.howMany);
          if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range.containsPosition(opA.splitPosition)) {
            const howMany = range.end.offset - opA.splitPosition.offset;
            const offset = opA.splitPosition.offset - range.start.offset;
            this._setRelation(opA, opB, {howMany, offset});
          }
        }
      }
    } else if (opA instanceof mergeoperation_default) {
      if (opB instanceof mergeoperation_default) {
        if (!opA.targetPosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeTargetNotMoved");
        }
        if (opA.sourcePosition.isEqual(opB.targetPosition)) {
          this._setRelation(opA, opB, "mergeSourceNotMoved");
        }
        if (opA.sourcePosition.isEqual(opB.sourcePosition)) {
          this._setRelation(opA, opB, "mergeSameElement");
        }
      } else if (opB instanceof splitoperation_default) {
        if (opA.sourcePosition.isEqual(opB.splitPosition)) {
          this._setRelation(opA, opB, "splitAtSource");
        }
      }
    } else if (opA instanceof markeroperation_default) {
      const markerRange = opA.newRange;
      if (!markerRange) {
        return;
      }
      if (opB instanceof moveoperation_default) {
        const movedRange = range_default2._createFromPositionAndShift(opB.sourcePosition, opB.howMany);
        const affectedLeft = movedRange.containsPosition(markerRange.start) || movedRange.start.isEqual(markerRange.start);
        const affectedRight = movedRange.containsPosition(markerRange.end) || movedRange.end.isEqual(markerRange.end);
        if ((affectedLeft || affectedRight) && !movedRange.containsRange(markerRange)) {
          this._setRelation(opA, opB, {
            side: affectedLeft ? "left" : "right",
            path: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()
          });
        }
      } else if (opB instanceof mergeoperation_default) {
        const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);
        const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);
        const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);
        const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);
        if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {
          this._setRelation(opA, opB, {
            wasInLeftElement,
            wasStartBeforeMergedElement,
            wasEndBeforeMergedElement,
            wasInRightElement
          });
        }
      }
    }
  }
  getContext(opA, opB, aIsStrong) {
    return {
      aIsStrong,
      aWasUndone: this._wasUndone(opA),
      bWasUndone: this._wasUndone(opB),
      abRelation: this._useRelations ? this._getRelation(opA, opB) : null,
      baRelation: this._useRelations ? this._getRelation(opB, opA) : null,
      forceWeakRemove: this._forceWeakRemove
    };
  }
  _wasUndone(op) {
    const originalOp = this.originalOperations.get(op);
    return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);
  }
  _getRelation(opA, opB) {
    const origB = this.originalOperations.get(opB);
    const undoneB = this._history.getUndoneOperation(origB);
    if (!undoneB) {
      return null;
    }
    const origA = this.originalOperations.get(opA);
    const relationsA = this._relations.get(origA);
    if (relationsA) {
      return relationsA.get(undoneB) || null;
    }
    return null;
  }
  _setRelation(opA, opB, relation) {
    const origA = this.originalOperations.get(opA);
    const origB = this.originalOperations.get(opB);
    let relationsA = this._relations.get(origA);
    if (!relationsA) {
      relationsA = new Map();
      this._relations.set(origA, relationsA);
    }
    relationsA.set(origB, relation);
  }
};
function updateBaseVersions(operations2, baseVersion) {
  for (const operation of operations2) {
    operation.baseVersion = baseVersion++;
  }
}
function padWithNoOps(operations2, howMany) {
  for (let i = 0; i < howMany; i++) {
    operations2.push(new nooperation_default(0));
  }
}
setTransformation(attributeoperation_default, attributeoperation_default, (a, b, context) => {
  if (a.key === b.key && a.range.start.hasSameParentAs(b.range.start)) {
    const operations2 = a.range.getDifference(b.range).map((range) => {
      return new attributeoperation_default(range, a.key, a.oldValue, a.newValue, 0);
    });
    const common = a.range.getIntersection(b.range);
    if (common) {
      if (context.aIsStrong) {
        operations2.push(new attributeoperation_default(common, b.key, b.newValue, a.newValue, 0));
      }
    }
    if (operations2.length == 0) {
      return [new nooperation_default(0)];
    }
    return operations2;
  } else {
    return [a];
  }
});
setTransformation(attributeoperation_default, insertoperation_default, (a, b) => {
  if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {
    const range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);
    const result = range.map((r) => {
      return new attributeoperation_default(r, a.key, a.oldValue, a.newValue, a.baseVersion);
    });
    if (b.shouldReceiveAttributes) {
      const op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);
      if (op) {
        result.unshift(op);
      }
    }
    return result;
  }
  a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];
  return [a];
});
function _getComplementaryAttributeOperations(insertOperation, key, newValue) {
  const nodes = insertOperation.nodes;
  const insertValue = nodes.getNode(0).getAttribute(key);
  if (insertValue == newValue) {
    return null;
  }
  const range = new range_default2(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));
  return new attributeoperation_default(range, key, insertValue, newValue, 0);
}
setTransformation(attributeoperation_default, mergeoperation_default, (a, b) => {
  const ranges = [];
  if (a.range.start.hasSameParentAs(b.deletionPosition)) {
    if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {
      ranges.push(range_default2._createFromPositionAndShift(b.graveyardPosition, 1));
    }
  }
  const range = a.range._getTransformedByMergeOperation(b);
  if (!range.isCollapsed) {
    ranges.push(range);
  }
  return ranges.map((range2) => {
    return new attributeoperation_default(range2, a.key, a.oldValue, a.newValue, a.baseVersion);
  });
});
setTransformation(attributeoperation_default, moveoperation_default, (a, b) => {
  const ranges = _breakRangeByMoveOperation(a.range, b);
  return ranges.map((range) => new attributeoperation_default(range, a.key, a.oldValue, a.newValue, a.baseVersion));
});
function _breakRangeByMoveOperation(range, moveOp) {
  const moveRange = range_default2._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany);
  let common = null;
  let difference = [];
  if (moveRange.containsRange(range, true)) {
    common = range;
  } else if (range.start.hasSameParentAs(moveRange.start)) {
    difference = range.getDifference(moveRange);
    common = range.getIntersection(moveRange);
  } else {
    difference = [range];
  }
  const result = [];
  for (let diff2 of difference) {
    diff2 = diff2._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany);
    const targetPosition = moveOp.getMovedRangeStart();
    const spread = diff2.start.hasSameParentAs(targetPosition);
    const diffs = diff2._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);
    result.push(...diffs);
  }
  if (common) {
    result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);
  }
  return result;
}
setTransformation(attributeoperation_default, splitoperation_default, (a, b) => {
  if (a.range.end.isEqual(b.insertionPosition)) {
    if (!b.graveyardPosition) {
      a.range.end.offset++;
    }
    return [a];
  }
  if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {
    const secondPart = a.clone();
    secondPart.range = new range_default2(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));
    a.range.end = b.splitPosition.clone();
    a.range.end.stickiness = "toPrevious";
    return [a, secondPart];
  }
  a.range = a.range._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(insertoperation_default, attributeoperation_default, (a, b) => {
  const result = [a];
  if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {
    const op = _getComplementaryAttributeOperations(a, b.key, b.newValue);
    if (op) {
      result.push(op);
    }
  }
  return result;
});
setTransformation(insertoperation_default, insertoperation_default, (a, b, context) => {
  if (a.position.isEqual(b.position) && context.aIsStrong) {
    return [a];
  }
  a.position = a.position._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(insertoperation_default, moveoperation_default, (a, b) => {
  a.position = a.position._getTransformedByMoveOperation(b);
  return [a];
});
setTransformation(insertoperation_default, splitoperation_default, (a, b) => {
  a.position = a.position._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(insertoperation_default, mergeoperation_default, (a, b) => {
  a.position = a.position._getTransformedByMergeOperation(b);
  return [a];
});
setTransformation(markeroperation_default, insertoperation_default, (a, b) => {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];
  }
  if (a.newRange) {
    a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];
  }
  return [a];
});
setTransformation(markeroperation_default, markeroperation_default, (a, b, context) => {
  if (a.name == b.name) {
    if (context.aIsStrong) {
      a.oldRange = b.newRange ? b.newRange.clone() : null;
    } else {
      return [new nooperation_default(0)];
    }
  }
  return [a];
});
setTransformation(markeroperation_default, mergeoperation_default, (a, b) => {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedByMergeOperation(b);
  }
  if (a.newRange) {
    a.newRange = a.newRange._getTransformedByMergeOperation(b);
  }
  return [a];
});
setTransformation(markeroperation_default, moveoperation_default, (a, b, context) => {
  if (a.oldRange) {
    a.oldRange = range_default2._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));
  }
  if (a.newRange) {
    if (context.abRelation) {
      const aNewRange = range_default2._createFromRanges(a.newRange._getTransformedByMoveOperation(b));
      if (context.abRelation.side == "left" && b.targetPosition.isEqual(a.newRange.start)) {
        a.newRange.end = aNewRange.end;
        a.newRange.start.path = context.abRelation.path;
        return [a];
      } else if (context.abRelation.side == "right" && b.targetPosition.isEqual(a.newRange.end)) {
        a.newRange.start = aNewRange.start;
        a.newRange.end.path = context.abRelation.path;
        return [a];
      }
    }
    a.newRange = range_default2._createFromRanges(a.newRange._getTransformedByMoveOperation(b));
  }
  return [a];
});
setTransformation(markeroperation_default, splitoperation_default, (a, b, context) => {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedBySplitOperation(b);
  }
  if (a.newRange) {
    if (context.abRelation) {
      const aNewRange = a.newRange._getTransformedBySplitOperation(b);
      if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {
        a.newRange.start = position_default2._createAt(b.insertionPosition);
      } else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {
        a.newRange.start = position_default2._createAt(b.moveTargetPosition);
      }
      if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {
        a.newRange.end = position_default2._createAt(b.moveTargetPosition);
      } else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {
        a.newRange.end = position_default2._createAt(b.insertionPosition);
      } else {
        a.newRange.end = aNewRange.end;
      }
      return [a];
    }
    a.newRange = a.newRange._getTransformedBySplitOperation(b);
  }
  return [a];
});
setTransformation(mergeoperation_default, insertoperation_default, (a, b) => {
  if (a.sourcePosition.hasSameParentAs(b.position)) {
    a.howMany += b.howMany;
  }
  a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(mergeoperation_default, mergeoperation_default, (a, b, context) => {
  if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {
    if (!context.bWasUndone) {
      return [new nooperation_default(0)];
    } else {
      const path = b.graveyardPosition.path.slice();
      path.push(0);
      a.sourcePosition = new position_default2(b.graveyardPosition.root, path);
      a.howMany = 0;
      return [a];
    }
  }
  if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != "splitAtSource") {
    const aToGraveyard = a.targetPosition.root.rootName == "$graveyard";
    const bToGraveyard = b.targetPosition.root.rootName == "$graveyard";
    const aIsWeak = aToGraveyard && !bToGraveyard;
    const bIsWeak = bToGraveyard && !aToGraveyard;
    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
    if (forceMove) {
      const sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);
      const targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
      return [new moveoperation_default(sourcePosition, a.howMany, targetPosition, 0)];
    } else {
      return [new nooperation_default(0)];
    }
  }
  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }
  a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
  if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
  }
  return [a];
});
setTransformation(mergeoperation_default, moveoperation_default, (a, b, context) => {
  const removedRange = range_default2._createFromPositionAndShift(b.sourcePosition, b.howMany);
  if (b.type == "remove" && !context.bWasUndone && !context.forceWeakRemove) {
    if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {
      return [new nooperation_default(0)];
    }
  }
  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }
  if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {
    a.howMany -= b.howMany;
  }
  a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b);
  if (!a.graveyardPosition.isEqual(b.targetPosition)) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
  }
  return [a];
});
setTransformation(mergeoperation_default, splitoperation_default, (a, b, context) => {
  if (b.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1);
    if (a.deletionPosition.isEqual(b.graveyardPosition)) {
      a.howMany = b.howMany;
    }
  }
  if (a.targetPosition.isEqual(b.splitPosition)) {
    const mergeInside = b.howMany != 0;
    const mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);
    if (mergeInside || mergeSplittingElement || context.abRelation == "mergeTargetNotMoved") {
      a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
      return [a];
    }
  }
  if (a.sourcePosition.isEqual(b.splitPosition)) {
    if (context.abRelation == "mergeSourceNotMoved") {
      a.howMany = 0;
      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      return [a];
    }
    if (context.abRelation == "mergeSameElement" || a.sourcePosition.offset > 0) {
      a.sourcePosition = b.moveTargetPosition.clone();
      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      return [a];
    }
  }
  if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {
    a.howMany = b.splitPosition.offset;
  }
  a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
  a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(moveoperation_default, insertoperation_default, (a, b) => {
  const moveRange = range_default2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  const transformed = moveRange._getTransformedByInsertOperation(b, false)[0];
  a.sourcePosition = transformed.start;
  a.howMany = transformed.end.offset - transformed.start.offset;
  if (!a.targetPosition.isEqual(b.position)) {
    a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
  }
  return [a];
});
setTransformation(moveoperation_default, moveoperation_default, (a, b, context) => {
  const rangeA = range_default2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  const rangeB = range_default2._createFromPositionAndShift(b.sourcePosition, b.howMany);
  let aIsStrong = context.aIsStrong;
  let insertBefore = !context.aIsStrong;
  if (context.abRelation == "insertBefore" || context.baRelation == "insertAfter") {
    insertBefore = true;
  } else if (context.abRelation == "insertAfter" || context.baRelation == "insertBefore") {
    insertBefore = false;
  }
  let newTargetPosition;
  if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {
    newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
  } else {
    newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
  }
  if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {
    return [b.getReversed()];
  }
  const bTargetsToA = rangeA.containsPosition(b.targetPosition);
  if (bTargetsToA && rangeA.containsRange(rangeB, true)) {
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  }
  const aTargetsToB = rangeB.containsPosition(a.targetPosition);
  if (aTargetsToB && rangeB.containsRange(rangeA, true)) {
    rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  }
  const aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());
  if (aCompB == "prefix" || aCompB == "extension") {
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  }
  if (a.type == "remove" && b.type != "remove" && !context.aWasUndone && !context.forceWeakRemove) {
    aIsStrong = true;
  } else if (a.type != "remove" && b.type == "remove" && !context.bWasUndone && !context.forceWeakRemove) {
    aIsStrong = false;
  }
  const ranges = [];
  const difference = rangeA.getDifference(rangeB);
  for (const range of difference) {
    range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);
    range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany);
    const shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == "same";
    const newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);
    ranges.push(...newRanges);
  }
  const common = rangeA.getIntersection(rangeB);
  if (common !== null && aIsStrong) {
    common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
    if (ranges.length === 0) {
      ranges.push(common);
    } else if (ranges.length == 1) {
      if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {
        ranges.unshift(common);
      } else {
        ranges.push(common);
      }
    } else {
      ranges.splice(1, 0, common);
    }
  }
  if (ranges.length === 0) {
    return [new nooperation_default(a.baseVersion)];
  }
  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(moveoperation_default, splitoperation_default, (a, b, context) => {
  let newTargetPosition = a.targetPosition.clone();
  if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == "moveTargetAfter") {
    newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);
  }
  const moveRange = range_default2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  if (moveRange.end.isEqual(b.insertionPosition)) {
    if (!b.graveyardPosition) {
      a.howMany++;
    }
    a.targetPosition = newTargetPosition;
    return [a];
  }
  if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {
    let rightRange = new range_default2(b.splitPosition, moveRange.end);
    rightRange = rightRange._getTransformedBySplitOperation(b);
    const ranges2 = [
      new range_default2(moveRange.start, b.splitPosition),
      rightRange
    ];
    return _makeMoveOperationsFromRanges(ranges2, newTargetPosition);
  }
  if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == "insertAtSource") {
    newTargetPosition = b.moveTargetPosition;
  }
  if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == "insertBetween") {
    newTargetPosition = a.targetPosition;
  }
  const transformed = moveRange._getTransformedBySplitOperation(b);
  const ranges = [transformed];
  if (b.graveyardPosition) {
    const movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);
    if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {
      ranges.push(range_default2._createFromPositionAndShift(b.insertionPosition, 1));
    }
  }
  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(moveoperation_default, mergeoperation_default, (a, b, context) => {
  const movedRange = range_default2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {
    if (a.type == "remove" && !context.forceWeakRemove) {
      if (!context.aWasUndone) {
        const results = [];
        let gyMoveSource = b.graveyardPosition.clone();
        let splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);
        if (a.howMany > 1) {
          results.push(new moveoperation_default(a.sourcePosition, a.howMany - 1, a.targetPosition, 0));
          gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);
          splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);
        }
        const gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, a.targetPosition);
        const gyMove = new moveoperation_default(gyMoveSource, 1, gyMoveTarget, 0);
        const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();
        splitNodesMoveTargetPath.push(0);
        const splitNodesMoveTarget = new position_default2(gyMove.targetPosition.root, splitNodesMoveTargetPath);
        splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);
        const splitNodesMove = new moveoperation_default(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);
        results.push(gyMove);
        results.push(splitNodesMove);
        return results;
      }
    } else {
      if (a.howMany == 1) {
        if (!context.bWasUndone) {
          return [new nooperation_default(0)];
        } else {
          a.sourcePosition = b.graveyardPosition.clone();
          a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
          return [a];
        }
      }
    }
  }
  const moveRange = range_default2._createFromPositionAndShift(a.sourcePosition, a.howMany);
  const transformed = moveRange._getTransformedByMergeOperation(b);
  a.sourcePosition = transformed.start;
  a.howMany = transformed.end.offset - transformed.start.offset;
  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
  return [a];
});
setTransformation(renameoperation_default, insertoperation_default, (a, b) => {
  a.position = a.position._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(renameoperation_default, mergeoperation_default, (a, b) => {
  if (a.position.isEqual(b.deletionPosition)) {
    a.position = b.graveyardPosition.clone();
    a.position.stickiness = "toNext";
    return [a];
  }
  a.position = a.position._getTransformedByMergeOperation(b);
  return [a];
});
setTransformation(renameoperation_default, moveoperation_default, (a, b) => {
  a.position = a.position._getTransformedByMoveOperation(b);
  return [a];
});
setTransformation(renameoperation_default, renameoperation_default, (a, b, context) => {
  if (a.position.isEqual(b.position)) {
    if (context.aIsStrong) {
      a.oldName = b.newName;
    } else {
      return [new nooperation_default(0)];
    }
  }
  return [a];
});
setTransformation(renameoperation_default, splitoperation_default, (a, b) => {
  const renamePath = a.position.path;
  const splitPath = b.splitPosition.getParentPath();
  if (compareArrays(renamePath, splitPath) == "same" && !b.graveyardPosition) {
    const extraRename = new renameoperation_default(a.position.getShiftedBy(1), a.oldName, a.newName, 0);
    return [a, extraRename];
  }
  a.position = a.position._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(rootattributeoperation_default, rootattributeoperation_default, (a, b, context) => {
  if (a.root === b.root && a.key === b.key) {
    if (!context.aIsStrong || a.newValue === b.newValue) {
      return [new nooperation_default(0)];
    } else {
      a.oldValue = b.newValue;
    }
  }
  return [a];
});
setTransformation(rootoperation_default, rootoperation_default, (a, b) => {
  if (a.rootName === b.rootName && a.isAdd === b.isAdd) {
    return [new nooperation_default(0)];
  }
  return [a];
});
setTransformation(splitoperation_default, insertoperation_default, (a, b) => {
  if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {
    a.howMany += b.howMany;
  }
  a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);
  a.insertionPosition = a.insertionPosition._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(splitoperation_default, mergeoperation_default, (a, b, context) => {
  if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {
    const splitPath = b.graveyardPosition.path.slice();
    splitPath.push(0);
    const splitPosition = new position_default2(b.graveyardPosition.root, splitPath);
    const insertionPosition = splitoperation_default.getInsertionPosition(new position_default2(b.graveyardPosition.root, splitPath));
    const additionalSplit = new splitoperation_default(splitPosition, 0, insertionPosition, null, 0);
    a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
    a.insertionPosition = splitoperation_default.getInsertionPosition(a.splitPosition);
    a.graveyardPosition = additionalSplit.insertionPosition.clone();
    a.graveyardPosition.stickiness = "toNext";
    return [additionalSplit, a];
  }
  if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {
    a.howMany--;
  }
  if (a.splitPosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }
  a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
  a.insertionPosition = splitoperation_default.getInsertionPosition(a.splitPosition);
  if (a.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
  }
  return [a];
});
setTransformation(splitoperation_default, moveoperation_default, (a, b, context) => {
  const rangeToMove = range_default2._createFromPositionAndShift(b.sourcePosition, b.howMany);
  if (a.graveyardPosition) {
    const gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);
    if (!context.bWasUndone && gyElementMoved) {
      const sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);
      const newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
      const newTargetPath = newParentPosition.path.slice();
      newTargetPath.push(0);
      const newTargetPosition = new position_default2(newParentPosition.root, newTargetPath);
      const moveOp = new moveoperation_default(sourcePosition, a.howMany, newTargetPosition, 0);
      return [moveOp];
    }
    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
  }
  const splitAtTarget = a.splitPosition.isEqual(b.targetPosition);
  if (splitAtTarget && (context.baRelation == "insertAtSource" || context.abRelation == "splitBefore")) {
    a.howMany += b.howMany;
    a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
    a.insertionPosition = splitoperation_default.getInsertionPosition(a.splitPosition);
    return [a];
  }
  if (splitAtTarget && context.abRelation && context.abRelation.howMany) {
    const {howMany, offset} = context.abRelation;
    a.howMany += howMany;
    a.splitPosition = a.splitPosition.getShiftedBy(offset);
    return [a];
  }
  if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {
    const howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);
    a.howMany -= howManyRemoved;
    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
      a.howMany += b.howMany;
    }
    a.splitPosition = b.sourcePosition.clone();
    a.insertionPosition = splitoperation_default.getInsertionPosition(a.splitPosition);
    return [a];
  }
  if (!b.sourcePosition.isEqual(b.targetPosition)) {
    if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {
      a.howMany -= b.howMany;
    }
    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
      a.howMany += b.howMany;
    }
  }
  a.splitPosition.stickiness = "toNone";
  a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);
  a.splitPosition.stickiness = "toNext";
  if (a.graveyardPosition) {
    a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);
  } else {
    a.insertionPosition = splitoperation_default.getInsertionPosition(a.splitPosition);
  }
  return [a];
});
setTransformation(splitoperation_default, splitoperation_default, (a, b, context) => {
  if (a.splitPosition.isEqual(b.splitPosition)) {
    if (!a.graveyardPosition && !b.graveyardPosition) {
      return [new nooperation_default(0)];
    }
    if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
      return [new nooperation_default(0)];
    }
    if (context.abRelation == "splitBefore") {
      a.howMany = 0;
      a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
      return [a];
    }
  }
  if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
    const aInGraveyard = a.splitPosition.root.rootName == "$graveyard";
    const bInGraveyard = b.splitPosition.root.rootName == "$graveyard";
    const aIsWeak = aInGraveyard && !bInGraveyard;
    const bIsWeak = bInGraveyard && !aInGraveyard;
    const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
    if (forceMove) {
      const result = [];
      if (b.howMany) {
        result.push(new moveoperation_default(b.moveTargetPosition, b.howMany, b.splitPosition, 0));
      }
      if (a.howMany) {
        result.push(new moveoperation_default(a.splitPosition, a.howMany, a.moveTargetPosition, 0));
      }
      return result;
    } else {
      return [new nooperation_default(0)];
    }
  }
  if (a.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
  }
  if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == "splitBefore") {
    a.howMany++;
    return [a];
  }
  if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == "splitBefore") {
    const newPositionPath = b.insertionPosition.path.slice();
    newPositionPath.push(0);
    const newPosition = new position_default2(b.insertionPosition.root, newPositionPath);
    const moveOp = new moveoperation_default(a.insertionPosition, 1, newPosition, 0);
    return [a, moveOp];
  }
  if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {
    a.howMany -= b.howMany;
  }
  a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);
  a.insertionPosition = splitoperation_default.getInsertionPosition(a.splitPosition);
  return [a];
});
function _moveTargetIntoMovedRange(a, b) {
  return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;
}
function _makeMoveOperationsFromRanges(ranges, targetPosition) {
  const operations2 = [];
  for (let i = 0; i < ranges.length; i++) {
    const range = ranges[i];
    const op = new moveoperation_default(range.start, range.end.offset - range.start.offset, targetPosition, 0);
    operations2.push(op);
    for (let j = i + 1; j < ranges.length; j++) {
      ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];
    }
    targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);
  }
  return operations2;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/liveposition.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var LivePosition = class extends EmitterMixin(position_default2) {
  constructor(root2, path, stickiness = "toNone") {
    super(root2, path, stickiness);
    if (!this.root.is("rootElement")) {
      throw new ckeditorerror_default("model-liveposition-root-not-rootelement", root2);
    }
    bindWithDocument2.call(this);
  }
  detach() {
    this.stopListening();
  }
  toPosition() {
    return new position_default2(this.root, this.path.slice(), this.stickiness);
  }
  static fromPosition(position, stickiness) {
    return new this(position.root, position.path.slice(), stickiness ? stickiness : position.stickiness);
  }
};
var liveposition_default = LivePosition;
LivePosition.prototype.is = function(type) {
  return type === "livePosition" || type === "model:livePosition" || type == "position" || type === "model:position";
};
function bindWithDocument2() {
  this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
    const operation = args[0];
    if (!operation.isDocumentOperation) {
      return;
    }
    transform3.call(this, operation);
  }, {priority: "low"});
}
function transform3(operation) {
  const result = this.getTransformedByOperation(operation);
  if (!this.isEqual(result)) {
    const oldPosition = this.toPosition();
    this.path = result.path;
    this.root = result.root;
    this.fire("change", oldPosition);
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/batch.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Batch = class {
  constructor(type = {}) {
    if (typeof type === "string") {
      type = type === "transparent" ? {isUndoable: false} : {};
      logWarning("batch-constructor-deprecated-string-type");
    }
    const {isUndoable = true, isLocal = true, isUndo = false, isTyping = false} = type;
    this.operations = [];
    this.isUndoable = isUndoable;
    this.isLocal = isLocal;
    this.isUndo = isUndo;
    this.isTyping = isTyping;
  }
  get type() {
    logWarning("batch-type-deprecated");
    return "default";
  }
  get baseVersion() {
    for (const op of this.operations) {
      if (op.baseVersion !== null) {
        return op.baseVersion;
      }
    }
    return null;
  }
  addOperation(operation) {
    operation.batch = this;
    this.operations.push(operation);
    return operation;
  }
};
var batch_default = Batch;

// node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Differ = class {
  constructor(markerCollection) {
    this._changesInElement = new Map();
    this._elementSnapshots = new Map();
    this._changedMarkers = new Map();
    this._changedRoots = new Map();
    this._changeCount = 0;
    this._cachedChanges = null;
    this._cachedChangesWithGraveyard = null;
    this._refreshedItems = new Set();
    this._markerCollection = markerCollection;
  }
  get isEmpty() {
    return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
  }
  bufferOperation(operationToBuffer) {
    const operation = operationToBuffer;
    switch (operation.type) {
      case "insert": {
        if (this._isInInsertedElement(operation.position.parent)) {
          return;
        }
        this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);
        break;
      }
      case "addAttribute":
      case "removeAttribute":
      case "changeAttribute": {
        for (const item of operation.range.getItems({shallow: true})) {
          if (this._isInInsertedElement(item.parent)) {
            continue;
          }
          this._markAttribute(item);
        }
        break;
      }
      case "remove":
      case "move":
      case "reinsert": {
        if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {
          return;
        }
        const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);
        const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);
        if (!sourceParentInserted) {
          this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);
        }
        if (!targetParentInserted) {
          this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);
        }
        break;
      }
      case "rename": {
        if (this._isInInsertedElement(operation.position.parent)) {
          return;
        }
        this._markRemove(operation.position.parent, operation.position.offset, 1);
        this._markInsert(operation.position.parent, operation.position.offset, 1);
        const range = range_default2._createFromPositionAndShift(operation.position, 1);
        for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {
          const markerData = marker.getData();
          this.bufferMarkerChange(marker.name, markerData, markerData);
        }
        break;
      }
      case "split": {
        const splitElement = operation.splitPosition.parent;
        if (!this._isInInsertedElement(splitElement)) {
          this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);
        }
        if (!this._isInInsertedElement(operation.insertionPosition.parent)) {
          this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);
        }
        if (operation.graveyardPosition) {
          this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);
        }
        break;
      }
      case "merge": {
        const mergedElement = operation.sourcePosition.parent;
        if (!this._isInInsertedElement(mergedElement.parent)) {
          this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);
        }
        const graveyardParent = operation.graveyardPosition.parent;
        this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1);
        const mergedIntoElement = operation.targetPosition.parent;
        if (!this._isInInsertedElement(mergedIntoElement)) {
          this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);
        }
        break;
      }
      case "detachRoot":
      case "addRoot": {
        const root2 = operation.affectedSelectable;
        if (!root2._isLoaded) {
          return;
        }
        if (root2.isAttached() == operation.isAdd) {
          return;
        }
        this._bufferRootStateChange(operation.rootName, operation.isAdd);
        break;
      }
      case "addRootAttribute":
      case "removeRootAttribute":
      case "changeRootAttribute": {
        if (!operation.root._isLoaded) {
          return;
        }
        const rootName = operation.root.rootName;
        this._bufferRootAttributeChange(rootName, operation.key, operation.oldValue, operation.newValue);
        break;
      }
    }
    this._cachedChanges = null;
  }
  bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {
    if (oldMarkerData.range && oldMarkerData.range.root.is("rootElement") && !oldMarkerData.range.root._isLoaded) {
      oldMarkerData.range = null;
    }
    if (newMarkerData.range && newMarkerData.range.root.is("rootElement") && !newMarkerData.range.root._isLoaded) {
      newMarkerData.range = null;
    }
    let buffered = this._changedMarkers.get(markerName);
    if (!buffered) {
      buffered = {newMarkerData, oldMarkerData};
      this._changedMarkers.set(markerName, buffered);
    } else {
      buffered.newMarkerData = newMarkerData;
    }
    if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {
      this._changedMarkers.delete(markerName);
    }
  }
  getMarkersToRemove() {
    const result = [];
    for (const [name, change] of this._changedMarkers) {
      if (change.oldMarkerData.range != null) {
        result.push({name, range: change.oldMarkerData.range});
      }
    }
    return result;
  }
  getMarkersToAdd() {
    const result = [];
    for (const [name, change] of this._changedMarkers) {
      if (change.newMarkerData.range != null) {
        result.push({name, range: change.newMarkerData.range});
      }
    }
    return result;
  }
  getChangedMarkers() {
    return Array.from(this._changedMarkers).map(([name, change]) => ({
      name,
      data: {
        oldRange: change.oldMarkerData.range,
        newRange: change.newMarkerData.range
      }
    }));
  }
  hasDataChanges() {
    if (this._changesInElement.size > 0) {
      return true;
    }
    if (this._changedRoots.size > 0) {
      return true;
    }
    for (const {newMarkerData, oldMarkerData} of this._changedMarkers.values()) {
      if (newMarkerData.affectsData !== oldMarkerData.affectsData) {
        return true;
      }
      if (newMarkerData.affectsData) {
        const markerAdded = newMarkerData.range && !oldMarkerData.range;
        const markerRemoved = !newMarkerData.range && oldMarkerData.range;
        const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);
        if (markerAdded || markerRemoved || markerChanged) {
          return true;
        }
      }
    }
    return false;
  }
  getChanges(options = {}) {
    if (this._cachedChanges) {
      if (options.includeChangesInGraveyard) {
        return this._cachedChangesWithGraveyard.slice();
      } else {
        return this._cachedChanges.slice();
      }
    }
    let diffSet = [];
    for (const element of this._changesInElement.keys()) {
      const changes = this._changesInElement.get(element).sort((a, b) => {
        if (a.offset === b.offset) {
          if (a.type != b.type) {
            return a.type == "remove" ? -1 : 1;
          }
          return 0;
        }
        return a.offset < b.offset ? -1 : 1;
      });
      const snapshotChildren = this._elementSnapshots.get(element);
      const elementChildren = _getChildrenSnapshot(element.getChildren());
      const actions = _generateActionsFromChanges(snapshotChildren.length, changes);
      let i = 0;
      let j = 0;
      for (const action of actions) {
        if (action === "i") {
          diffSet.push(this._getInsertDiff(element, i, elementChildren[i]));
          i++;
        } else if (action === "r") {
          diffSet.push(this._getRemoveDiff(element, i, snapshotChildren[j]));
          j++;
        } else if (action === "a") {
          const elementAttributes = elementChildren[i].attributes;
          const snapshotAttributes = snapshotChildren[j].attributes;
          let range;
          if (elementChildren[i].name == "$text") {
            range = new range_default2(position_default2._createAt(element, i), position_default2._createAt(element, i + 1));
          } else {
            const index = element.offsetToIndex(i);
            range = new range_default2(position_default2._createAt(element, i), position_default2._createAt(element.getChild(index), 0));
          }
          diffSet.push(...this._getAttributesDiff(range, snapshotAttributes, elementAttributes));
          i++;
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    diffSet.sort((a, b) => {
      if (a.position.root != b.position.root) {
        return a.position.root.rootName < b.position.root.rootName ? -1 : 1;
      }
      if (a.position.isEqual(b.position)) {
        return a.changeCount - b.changeCount;
      }
      return a.position.isBefore(b.position) ? -1 : 1;
    });
    for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {
      const prevDiff = diffSet[prevIndex];
      const thisDiff = diffSet[i];
      const isConsecutiveTextRemove = prevDiff.type == "remove" && thisDiff.type == "remove" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.isEqual(thisDiff.position);
      const isConsecutiveTextAdd = prevDiff.type == "insert" && thisDiff.type == "insert" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset;
      const isConsecutiveAttributeChange = prevDiff.type == "attribute" && thisDiff.type == "attribute" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;
      if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {
        prevDiff.length++;
        if (isConsecutiveAttributeChange) {
          prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);
        }
        diffSet[i] = null;
      } else {
        prevIndex = i;
      }
    }
    diffSet = diffSet.filter((v) => v);
    for (const item of diffSet) {
      delete item.changeCount;
      if (item.type == "attribute") {
        delete item.position;
        delete item.length;
      }
    }
    this._changeCount = 0;
    this._cachedChangesWithGraveyard = diffSet;
    this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);
    if (options.includeChangesInGraveyard) {
      return this._cachedChangesWithGraveyard.slice();
    } else {
      return this._cachedChanges.slice();
    }
  }
  getChangedRoots() {
    return Array.from(this._changedRoots.values()).map((diffItem) => {
      const entry = {...diffItem};
      if (entry.state !== void 0) {
        delete entry.attributes;
      }
      return entry;
    });
  }
  getRefreshedItems() {
    return new Set(this._refreshedItems);
  }
  reset() {
    this._changesInElement.clear();
    this._elementSnapshots.clear();
    this._changedMarkers.clear();
    this._changedRoots.clear();
    this._refreshedItems = new Set();
    this._cachedChanges = null;
  }
  _bufferRootStateChange(rootName, isAttached) {
    if (!this._changedRoots.has(rootName)) {
      this._changedRoots.set(rootName, {name: rootName, state: isAttached ? "attached" : "detached"});
      return;
    }
    const diffItem = this._changedRoots.get(rootName);
    if (diffItem.state !== void 0) {
      delete diffItem.state;
      if (diffItem.attributes === void 0) {
        this._changedRoots.delete(rootName);
      }
    } else {
      diffItem.state = isAttached ? "attached" : "detached";
    }
  }
  _bufferRootAttributeChange(rootName, key, oldValue, newValue) {
    const diffItem = this._changedRoots.get(rootName) || {name: rootName};
    const attrs = diffItem.attributes || {};
    if (attrs[key]) {
      const attrEntry = attrs[key];
      if (newValue === attrEntry.oldValue) {
        delete attrs[key];
      } else {
        attrEntry.newValue = newValue;
      }
    } else {
      attrs[key] = {oldValue, newValue};
    }
    if (Object.entries(attrs).length === 0) {
      delete diffItem.attributes;
      if (diffItem.state === void 0) {
        this._changedRoots.delete(rootName);
      }
    } else {
      diffItem.attributes = attrs;
      this._changedRoots.set(rootName, diffItem);
    }
  }
  _refreshItem(item) {
    if (this._isInInsertedElement(item.parent)) {
      return;
    }
    this._markRemove(item.parent, item.startOffset, item.offsetSize);
    this._markInsert(item.parent, item.startOffset, item.offsetSize);
    this._refreshedItems.add(item);
    const range = range_default2._createOn(item);
    for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {
      const markerData = marker.getData();
      this.bufferMarkerChange(marker.name, markerData, markerData);
    }
    this._cachedChanges = null;
  }
  _bufferRootLoad(root2) {
    if (!root2.isAttached()) {
      return;
    }
    this._bufferRootStateChange(root2.rootName, true);
    this._markInsert(root2, 0, root2.maxOffset);
    for (const key of root2.getAttributeKeys()) {
      this._bufferRootAttributeChange(root2.rootName, key, null, root2.getAttribute(key));
    }
    for (const marker of this._markerCollection) {
      if (marker.getRange().root == root2) {
        const markerData = marker.getData();
        this.bufferMarkerChange(marker.name, {...markerData, range: null}, markerData);
      }
    }
  }
  _markInsert(parent2, offset, howMany) {
    if (parent2.root.is("rootElement") && !parent2.root._isLoaded) {
      return;
    }
    const changeItem = {type: "insert", offset, howMany, count: this._changeCount++};
    this._markChange(parent2, changeItem);
  }
  _markRemove(parent2, offset, howMany) {
    if (parent2.root.is("rootElement") && !parent2.root._isLoaded) {
      return;
    }
    const changeItem = {type: "remove", offset, howMany, count: this._changeCount++};
    this._markChange(parent2, changeItem);
    this._removeAllNestedChanges(parent2, offset, howMany);
  }
  _markAttribute(item) {
    if (item.root.is("rootElement") && !item.root._isLoaded) {
      return;
    }
    const changeItem = {type: "attribute", offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++};
    this._markChange(item.parent, changeItem);
  }
  _markChange(parent2, changeItem) {
    this._makeSnapshot(parent2);
    const changes = this._getChangesForElement(parent2);
    this._handleChange(changeItem, changes);
    changes.push(changeItem);
    for (let i = 0; i < changes.length; i++) {
      if (changes[i].howMany < 1) {
        changes.splice(i, 1);
        i--;
      }
    }
  }
  _getChangesForElement(element) {
    let changes;
    if (this._changesInElement.has(element)) {
      changes = this._changesInElement.get(element);
    } else {
      changes = [];
      this._changesInElement.set(element, changes);
    }
    return changes;
  }
  _makeSnapshot(element) {
    if (!this._elementSnapshots.has(element)) {
      this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));
    }
  }
  _handleChange(inc, changes) {
    inc.nodesToHandle = inc.howMany;
    for (const old of changes) {
      const incEnd = inc.offset + inc.howMany;
      const oldEnd = old.offset + old.howMany;
      if (inc.type == "insert") {
        if (old.type == "insert") {
          if (inc.offset <= old.offset) {
            old.offset += inc.howMany;
          } else if (inc.offset < oldEnd) {
            old.howMany += inc.nodesToHandle;
            inc.nodesToHandle = 0;
          }
        }
        if (old.type == "remove") {
          if (inc.offset < old.offset) {
            old.offset += inc.howMany;
          }
        }
        if (old.type == "attribute") {
          if (inc.offset <= old.offset) {
            old.offset += inc.howMany;
          } else if (inc.offset < oldEnd) {
            const howMany = old.howMany;
            old.howMany = inc.offset - old.offset;
            changes.unshift({
              type: "attribute",
              offset: incEnd,
              howMany: howMany - old.howMany,
              count: this._changeCount++
            });
          }
        }
      }
      if (inc.type == "remove") {
        if (old.type == "insert") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (incEnd <= oldEnd) {
            if (inc.offset < old.offset) {
              const intersectionLength = incEnd - old.offset;
              old.offset = inc.offset;
              old.howMany -= intersectionLength;
              inc.nodesToHandle -= intersectionLength;
            } else {
              old.howMany -= inc.nodesToHandle;
              inc.nodesToHandle = 0;
            }
          } else {
            if (inc.offset <= old.offset) {
              inc.nodesToHandle -= old.howMany;
              old.howMany = 0;
            } else if (inc.offset < oldEnd) {
              const intersectionLength = oldEnd - inc.offset;
              old.howMany -= intersectionLength;
              inc.nodesToHandle -= intersectionLength;
            }
          }
        }
        if (old.type == "remove") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (inc.offset < old.offset) {
            inc.nodesToHandle += old.howMany;
            old.howMany = 0;
          }
        }
        if (old.type == "attribute") {
          if (incEnd <= old.offset) {
            old.offset -= inc.howMany;
          } else if (inc.offset < old.offset) {
            const intersectionLength = incEnd - old.offset;
            old.offset = inc.offset;
            old.howMany -= intersectionLength;
          } else if (inc.offset < oldEnd) {
            if (incEnd <= oldEnd) {
              const howMany = old.howMany;
              old.howMany = inc.offset - old.offset;
              const howManyAfter = howMany - old.howMany - inc.nodesToHandle;
              changes.unshift({
                type: "attribute",
                offset: inc.offset,
                howMany: howManyAfter,
                count: this._changeCount++
              });
            } else {
              old.howMany -= oldEnd - inc.offset;
            }
          }
        }
      }
      if (inc.type == "attribute") {
        if (old.type == "insert") {
          if (inc.offset < old.offset && incEnd > old.offset) {
            if (incEnd > oldEnd) {
              const attributePart = {
                type: "attribute",
                offset: oldEnd,
                howMany: incEnd - oldEnd,
                count: this._changeCount++
              };
              this._handleChange(attributePart, changes);
              changes.push(attributePart);
            }
            inc.nodesToHandle = old.offset - inc.offset;
            inc.howMany = inc.nodesToHandle;
          } else if (inc.offset >= old.offset && inc.offset < oldEnd) {
            if (incEnd > oldEnd) {
              inc.nodesToHandle = incEnd - oldEnd;
              inc.offset = oldEnd;
            } else {
              inc.nodesToHandle = 0;
            }
          }
        }
        if (old.type == "remove") {
          if (inc.offset < old.offset && incEnd > old.offset) {
            const attributePart = {
              type: "attribute",
              offset: old.offset,
              howMany: incEnd - old.offset,
              count: this._changeCount++
            };
            this._handleChange(attributePart, changes);
            changes.push(attributePart);
            inc.nodesToHandle = old.offset - inc.offset;
            inc.howMany = inc.nodesToHandle;
          }
        }
        if (old.type == "attribute") {
          if (inc.offset >= old.offset && incEnd <= oldEnd) {
            inc.nodesToHandle = 0;
            inc.howMany = 0;
            inc.offset = 0;
          } else if (inc.offset <= old.offset && incEnd >= oldEnd) {
            old.howMany = 0;
          }
        }
      }
    }
    inc.howMany = inc.nodesToHandle;
    delete inc.nodesToHandle;
  }
  _getInsertDiff(parent2, offset, elementSnapshot) {
    return {
      type: "insert",
      position: position_default2._createAt(parent2, offset),
      name: elementSnapshot.name,
      attributes: new Map(elementSnapshot.attributes),
      length: 1,
      changeCount: this._changeCount++
    };
  }
  _getRemoveDiff(parent2, offset, elementSnapshot) {
    return {
      type: "remove",
      position: position_default2._createAt(parent2, offset),
      name: elementSnapshot.name,
      attributes: new Map(elementSnapshot.attributes),
      length: 1,
      changeCount: this._changeCount++
    };
  }
  _getAttributesDiff(range, oldAttributes, newAttributes) {
    const diffs = [];
    newAttributes = new Map(newAttributes);
    for (const [key, oldValue] of oldAttributes) {
      const newValue = newAttributes.has(key) ? newAttributes.get(key) : null;
      if (newValue !== oldValue) {
        diffs.push({
          type: "attribute",
          position: range.start,
          range: range.clone(),
          length: 1,
          attributeKey: key,
          attributeOldValue: oldValue,
          attributeNewValue: newValue,
          changeCount: this._changeCount++
        });
      }
      newAttributes.delete(key);
    }
    for (const [key, newValue] of newAttributes) {
      diffs.push({
        type: "attribute",
        position: range.start,
        range: range.clone(),
        length: 1,
        attributeKey: key,
        attributeOldValue: null,
        attributeNewValue: newValue,
        changeCount: this._changeCount++
      });
    }
    return diffs;
  }
  _isInInsertedElement(element) {
    const parent2 = element.parent;
    if (!parent2) {
      return false;
    }
    const changes = this._changesInElement.get(parent2);
    const offset = element.startOffset;
    if (changes) {
      for (const change of changes) {
        if (change.type == "insert" && offset >= change.offset && offset < change.offset + change.howMany) {
          return true;
        }
      }
    }
    return this._isInInsertedElement(parent2);
  }
  _removeAllNestedChanges(parent2, offset, howMany) {
    const range = new range_default2(position_default2._createAt(parent2, offset), position_default2._createAt(parent2, offset + howMany));
    for (const item of range.getItems({shallow: true})) {
      if (item.is("element")) {
        this._elementSnapshots.delete(item);
        this._changesInElement.delete(item);
        this._removeAllNestedChanges(item, 0, item.maxOffset);
      }
    }
  }
};
var differ_default = Differ;
function _getChildrenSnapshot(children) {
  const snapshot = [];
  for (const child of children) {
    if (child.is("$text")) {
      for (let i = 0; i < child.data.length; i++) {
        snapshot.push({
          name: "$text",
          attributes: new Map(child.getAttributes())
        });
      }
    } else {
      snapshot.push({
        name: child.name,
        attributes: new Map(child.getAttributes())
      });
    }
  }
  return snapshot;
}
function _generateActionsFromChanges(oldChildrenLength, changes) {
  const actions = [];
  let offset = 0;
  let oldChildrenHandled = 0;
  for (const change of changes) {
    if (change.offset > offset) {
      for (let i = 0; i < change.offset - offset; i++) {
        actions.push("e");
      }
      oldChildrenHandled += change.offset - offset;
    }
    if (change.type == "insert") {
      for (let i = 0; i < change.howMany; i++) {
        actions.push("i");
      }
      offset = change.offset + change.howMany;
    } else if (change.type == "remove") {
      for (let i = 0; i < change.howMany; i++) {
        actions.push("r");
      }
      offset = change.offset;
      oldChildrenHandled += change.howMany;
    } else {
      actions.push(..."a".repeat(change.howMany).split(""));
      offset = change.offset + change.howMany;
      oldChildrenHandled += change.howMany;
    }
  }
  if (oldChildrenHandled < oldChildrenLength) {
    for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {
      actions.push("e");
    }
  }
  return actions;
}
function _changesInGraveyardFilter(entry) {
  const posInGy = "position" in entry && entry.position.root.rootName == "$graveyard";
  const rangeInGy = "range" in entry && entry.range.root.rootName == "$graveyard";
  return !posInGy && !rangeInGy;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/history.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var History = class {
  constructor() {
    this._operations = [];
    this._undoPairs = new Map();
    this._undoneOperations = new Set();
    this._baseVersionToOperationIndex = new Map();
    this._version = 0;
    this._gaps = new Map();
  }
  get version() {
    return this._version;
  }
  set version(version2) {
    if (this._operations.length && version2 > this._version + 1) {
      this._gaps.set(this._version, version2);
    }
    this._version = version2;
  }
  get lastOperation() {
    return this._operations[this._operations.length - 1];
  }
  addOperation(operation) {
    if (operation.baseVersion !== this.version) {
      throw new ckeditorerror_default("model-document-history-addoperation-incorrect-version", this, {
        operation,
        historyVersion: this.version
      });
    }
    this._operations.push(operation);
    this._version++;
    this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);
  }
  getOperations(fromBaseVersion, toBaseVersion = this.version) {
    if (!this._operations.length) {
      return [];
    }
    const firstOperation = this._operations[0];
    if (fromBaseVersion === void 0) {
      fromBaseVersion = firstOperation.baseVersion;
    }
    let inclusiveTo = toBaseVersion - 1;
    for (const [gapFrom, gapTo] of this._gaps) {
      if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {
        fromBaseVersion = gapTo;
      }
      if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {
        inclusiveTo = gapFrom - 1;
      }
    }
    if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {
      return [];
    }
    let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion);
    if (fromIndex === void 0) {
      fromIndex = 0;
    }
    let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo);
    if (toIndex === void 0) {
      toIndex = this._operations.length - 1;
    }
    return this._operations.slice(fromIndex, toIndex + 1);
  }
  getOperation(baseVersion) {
    const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);
    if (operationIndex === void 0) {
      return;
    }
    return this._operations[operationIndex];
  }
  setOperationAsUndone(undoneOperation, undoingOperation) {
    this._undoPairs.set(undoingOperation, undoneOperation);
    this._undoneOperations.add(undoneOperation);
  }
  isUndoingOperation(operation) {
    return this._undoPairs.has(operation);
  }
  isUndoneOperation(operation) {
    return this._undoneOperations.has(operation);
  }
  getUndoneOperation(undoingOperation) {
    return this._undoPairs.get(undoingOperation);
  }
  reset() {
    this._version = 0;
    this._undoPairs = new Map();
    this._operations = [];
    this._undoneOperations = new Set();
    this._gaps = new Map();
    this._baseVersionToOperationIndex = new Map();
  }
};
var history_default = History;

// node_modules/@ckeditor/ckeditor5-engine/src/model/rootelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var RootElement = class extends element_default2 {
  constructor(document2, name, rootName = "main") {
    super(name);
    this._isAttached = true;
    this._isLoaded = true;
    this._document = document2;
    this.rootName = rootName;
  }
  get document() {
    return this._document;
  }
  isAttached() {
    return this._isAttached;
  }
  toJSON() {
    return this.rootName;
  }
};
var rootelement_default = RootElement;
RootElement.prototype.is = function(type, name) {
  if (!name) {
    return type === "rootElement" || type === "model:rootElement" || type === "element" || type === "model:element" || type === "node" || type === "model:node";
  }
  return name === this.name && (type === "rootElement" || type === "model:rootElement" || type === "element" || type === "model:element");
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/document.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var graveyardName = "$graveyard";
var Document2 = class extends EmitterMixin() {
  constructor(model) {
    super();
    this.model = model;
    this.history = new history_default();
    this.selection = new documentselection_default2(this);
    this.roots = new collection_default({idProperty: "rootName"});
    this.differ = new differ_default(model.markers);
    this.isReadOnly = false;
    this._postFixers = new Set();
    this._hasSelectionChangedFromTheLastChangeBlock = false;
    this.createRoot("$root", graveyardName);
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.isDocumentOperation) {
        this.differ.bufferOperation(operation);
      }
    }, {priority: "high"});
    this.listenTo(model, "applyOperation", (evt, args) => {
      const operation = args[0];
      if (operation.isDocumentOperation) {
        this.history.addOperation(operation);
      }
    }, {priority: "low"});
    this.listenTo(this.selection, "change", () => {
      this._hasSelectionChangedFromTheLastChangeBlock = true;
    });
    this.listenTo(model.markers, "update", (evt, marker, oldRange, newRange, oldMarkerData) => {
      const newMarkerData = {...marker.getData(), range: newRange};
      this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);
      if (oldRange === null) {
        marker.on("change", (evt2, oldRange2) => {
          const markerData = marker.getData();
          this.differ.bufferMarkerChange(marker.name, {...markerData, range: oldRange2}, markerData);
        });
      }
    });
    this.registerPostFixer((writer) => {
      let result = false;
      for (const root2 of this.roots) {
        if (!root2.isAttached() && !root2.isEmpty) {
          writer.remove(writer.createRangeIn(root2));
          result = true;
        }
      }
      for (const marker of this.model.markers) {
        if (!marker.getRange().root.isAttached()) {
          writer.removeMarker(marker);
          result = true;
        }
      }
      return result;
    });
  }
  get version() {
    return this.history.version;
  }
  set version(version2) {
    this.history.version = version2;
  }
  get graveyard() {
    return this.getRoot(graveyardName);
  }
  createRoot(elementName = "$root", rootName = "main") {
    if (this.roots.get(rootName)) {
      throw new ckeditorerror_default("model-document-createroot-name-exists", this, {name: rootName});
    }
    const root2 = new rootelement_default(this, elementName, rootName);
    this.roots.add(root2);
    return root2;
  }
  destroy() {
    this.selection.destroy();
    this.stopListening();
  }
  getRoot(name = "main") {
    return this.roots.get(name);
  }
  getRootNames(includeDetached = false) {
    return this.getRoots(includeDetached).map((root2) => root2.rootName);
  }
  getRoots(includeDetached = false) {
    return Array.from(this.roots).filter((root2) => root2 != this.graveyard && (includeDetached || root2.isAttached()) && root2._isLoaded);
  }
  registerPostFixer(postFixer) {
    this._postFixers.add(postFixer);
  }
  toJSON() {
    const json = clone_default(this);
    json.selection = "[engine.model.DocumentSelection]";
    json.model = "[engine.model.Model]";
    return json;
  }
  _handleChangeBlock(writer) {
    if (this._hasDocumentChangedFromTheLastChangeBlock()) {
      this._callPostFixers(writer);
      this.selection.refresh();
      if (this.differ.hasDataChanges()) {
        this.fire("change:data", writer.batch);
      } else {
        this.fire("change", writer.batch);
      }
      this.selection.refresh();
      this.differ.reset();
    }
    this._hasSelectionChangedFromTheLastChangeBlock = false;
  }
  _hasDocumentChangedFromTheLastChangeBlock() {
    return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
  }
  _getDefaultRoot() {
    const roots = this.getRoots();
    return roots.length ? roots[0] : this.graveyard;
  }
  _getDefaultRange() {
    const defaultRoot = this._getDefaultRoot();
    const model = this.model;
    const schema = model.schema;
    const position = model.createPositionFromPath(defaultRoot, [0]);
    const nearestRange = schema.getNearestSelectionRange(position);
    return nearestRange || model.createRange(position);
  }
  _validateSelectionRange(range) {
    return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);
  }
  _callPostFixers(writer) {
    let wasFixed = false;
    do {
      for (const callback of this._postFixers) {
        this.selection.refresh();
        wasFixed = callback(writer);
        if (wasFixed) {
          break;
        }
      }
    } while (wasFixed);
  }
};
var document_default2 = Document2;
function validateTextNodePosition(rangeBoundary) {
  const textNode = rangeBoundary.textNode;
  if (textNode) {
    const data = textNode.data;
    const offset = rangeBoundary.offset - textNode.startOffset;
    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);
  }
  return true;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/markercollection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MarkerCollection = class extends EmitterMixin() {
  constructor() {
    super(...arguments);
    this._markers = new Map();
  }
  [Symbol.iterator]() {
    return this._markers.values();
  }
  has(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    return this._markers.has(markerName);
  }
  get(markerName) {
    return this._markers.get(markerName) || null;
  }
  _set(markerOrName, range, managedUsingOperations = false, affectsData = false) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    if (markerName.includes(",")) {
      throw new ckeditorerror_default("markercollection-incorrect-marker-name", this);
    }
    const oldMarker = this._markers.get(markerName);
    if (oldMarker) {
      const oldMarkerData = oldMarker.getData();
      const oldRange = oldMarker.getRange();
      let hasChanged = false;
      if (!oldRange.isEqual(range)) {
        oldMarker._attachLiveRange(liverange_default.fromRange(range));
        hasChanged = true;
      }
      if (managedUsingOperations != oldMarker.managedUsingOperations) {
        oldMarker._managedUsingOperations = managedUsingOperations;
        hasChanged = true;
      }
      if (typeof affectsData === "boolean" && affectsData != oldMarker.affectsData) {
        oldMarker._affectsData = affectsData;
        hasChanged = true;
      }
      if (hasChanged) {
        this.fire(`update:${markerName}`, oldMarker, oldRange, range, oldMarkerData);
      }
      return oldMarker;
    }
    const liveRange = liverange_default.fromRange(range);
    const marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);
    this._markers.set(markerName, marker);
    this.fire(`update:${markerName}`, marker, null, range, {...marker.getData(), range: null});
    return marker;
  }
  _remove(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    const oldMarker = this._markers.get(markerName);
    if (oldMarker) {
      this._markers.delete(markerName);
      this.fire(`update:${markerName}`, oldMarker, oldMarker.getRange(), null, oldMarker.getData());
      this._destroyMarker(oldMarker);
      return true;
    }
    return false;
  }
  _refresh(markerOrName) {
    const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
    const marker = this._markers.get(markerName);
    if (!marker) {
      throw new ckeditorerror_default("markercollection-refresh-marker-not-exists", this);
    }
    const range = marker.getRange();
    this.fire(`update:${markerName}`, marker, range, range, marker.getData());
  }
  *getMarkersAtPosition(position) {
    for (const marker of this) {
      if (marker.getRange().containsPosition(position)) {
        yield marker;
      }
    }
  }
  *getMarkersIntersectingRange(range) {
    for (const marker of this) {
      if (marker.getRange().getIntersection(range) !== null) {
        yield marker;
      }
    }
  }
  destroy() {
    for (const marker of this._markers.values()) {
      this._destroyMarker(marker);
    }
    this._markers = null;
    this.stopListening();
  }
  *getMarkersGroup(prefix) {
    for (const marker of this._markers.values()) {
      if (marker.name.startsWith(prefix + ":")) {
        yield marker;
      }
    }
  }
  _destroyMarker(marker) {
    marker.stopListening();
    marker._detachLiveRange();
  }
};
var markercollection_default = MarkerCollection;
var Marker = class extends EmitterMixin(typecheckable_default2) {
  constructor(name, liveRange, managedUsingOperations, affectsData) {
    super();
    this.name = name;
    this._liveRange = this._attachLiveRange(liveRange);
    this._managedUsingOperations = managedUsingOperations;
    this._affectsData = affectsData;
  }
  get managedUsingOperations() {
    if (!this._liveRange) {
      throw new ckeditorerror_default("marker-destroyed", this);
    }
    return this._managedUsingOperations;
  }
  get affectsData() {
    if (!this._liveRange) {
      throw new ckeditorerror_default("marker-destroyed", this);
    }
    return this._affectsData;
  }
  getData() {
    return {
      range: this.getRange(),
      affectsData: this.affectsData,
      managedUsingOperations: this.managedUsingOperations
    };
  }
  getStart() {
    if (!this._liveRange) {
      throw new ckeditorerror_default("marker-destroyed", this);
    }
    return this._liveRange.start.clone();
  }
  getEnd() {
    if (!this._liveRange) {
      throw new ckeditorerror_default("marker-destroyed", this);
    }
    return this._liveRange.end.clone();
  }
  getRange() {
    if (!this._liveRange) {
      throw new ckeditorerror_default("marker-destroyed", this);
    }
    return this._liveRange.toRange();
  }
  _attachLiveRange(liveRange) {
    if (this._liveRange) {
      this._detachLiveRange();
    }
    liveRange.delegate("change:range").to(this);
    liveRange.delegate("change:content").to(this);
    this._liveRange = liveRange;
    return liveRange;
  }
  _detachLiveRange() {
    this._liveRange.stopDelegating("change:range", this);
    this._liveRange.stopDelegating("change:content", this);
    this._liveRange.detach();
    this._liveRange = null;
  }
};
Marker.prototype.is = function(type) {
  return type === "marker" || type === "model:marker";
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/operation/detachoperation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DetachOperation = class extends operation_default {
  constructor(sourcePosition, howMany) {
    super(null);
    this.sourcePosition = sourcePosition.clone();
    this.howMany = howMany;
  }
  get type() {
    return "detach";
  }
  get affectedSelectable() {
    return null;
  }
  toJSON() {
    const json = super.toJSON();
    json.sourcePosition = this.sourcePosition.toJSON();
    return json;
  }
  _validate() {
    if (this.sourcePosition.root.document) {
      throw new ckeditorerror_default("detach-operation-on-document-node", this);
    }
  }
  _execute() {
    _remove(range_default2._createFromPositionAndShift(this.sourcePosition, this.howMany));
  }
  static get className() {
    return "DetachOperation";
  }
};
var detachoperation_default = DetachOperation;

// node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DocumentFragment2 = class extends typecheckable_default2 {
  constructor(children) {
    super();
    this.markers = new Map();
    this._children = new nodelist_default();
    if (children) {
      this._insertChild(0, children);
    }
  }
  [Symbol.iterator]() {
    return this.getChildren();
  }
  get childCount() {
    return this._children.length;
  }
  get maxOffset() {
    return this._children.maxOffset;
  }
  get isEmpty() {
    return this.childCount === 0;
  }
  get nextSibling() {
    return null;
  }
  get previousSibling() {
    return null;
  }
  get root() {
    return this;
  }
  get parent() {
    return null;
  }
  get document() {
    return null;
  }
  isAttached() {
    return false;
  }
  getAncestors() {
    return [];
  }
  getChild(index) {
    return this._children.getNode(index);
  }
  getChildren() {
    return this._children[Symbol.iterator]();
  }
  getChildIndex(node) {
    return this._children.getNodeIndex(node);
  }
  getChildStartOffset(node) {
    return this._children.getNodeStartOffset(node);
  }
  getPath() {
    return [];
  }
  getNodeByPath(relativePath) {
    let node = this;
    for (const index of relativePath) {
      node = node.getChild(node.offsetToIndex(index));
    }
    return node;
  }
  offsetToIndex(offset) {
    return this._children.offsetToIndex(offset);
  }
  toJSON() {
    const json = [];
    for (const node of this._children) {
      json.push(node.toJSON());
    }
    return json;
  }
  static fromJSON(json) {
    const children = [];
    for (const child of json) {
      if (child.name) {
        children.push(element_default2.fromJSON(child));
      } else {
        children.push(text_default2.fromJSON(child));
      }
    }
    return new DocumentFragment2(children);
  }
  _appendChild(items) {
    this._insertChild(this.childCount, items);
  }
  _insertChild(index, items) {
    const nodes = normalize4(items);
    for (const node of nodes) {
      if (node.parent !== null) {
        node._remove();
      }
      node.parent = this;
    }
    this._children._insertNodes(index, nodes);
  }
  _removeChildren(index, howMany = 1) {
    const nodes = this._children._removeNodes(index, howMany);
    for (const node of nodes) {
      node.parent = null;
    }
    return nodes;
  }
};
var documentfragment_default2 = DocumentFragment2;
DocumentFragment2.prototype.is = function(type) {
  return type === "documentFragment" || type === "model:documentFragment";
};
function normalize4(nodes) {
  if (typeof nodes == "string") {
    return [new text_default2(nodes)];
  }
  if (!isIterable(nodes)) {
    nodes = [nodes];
  }
  return Array.from(nodes).map((node) => {
    if (typeof node == "string") {
      return new text_default2(node);
    }
    if (node instanceof textproxy_default2) {
      return new text_default2(node.data, node.getAttributes());
    }
    return node;
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Writer = class {
  constructor(model, batch) {
    this.model = model;
    this.batch = batch;
  }
  createText(data, attributes) {
    return new text_default2(data, attributes);
  }
  createElement(name, attributes) {
    return new element_default2(name, attributes);
  }
  createDocumentFragment() {
    return new documentfragment_default2();
  }
  cloneElement(element, deep = true) {
    return element._clone(deep);
  }
  insert(item, itemOrPosition, offset = 0) {
    this._assertWriterUsedCorrectly();
    if (item instanceof text_default2 && item.data == "") {
      return;
    }
    const position = position_default2._createAt(itemOrPosition, offset);
    if (item.parent) {
      if (isSameTree(item.root, position.root)) {
        this.move(range_default2._createOn(item), position);
        return;
      } else {
        if (item.root.document) {
          throw new ckeditorerror_default("model-writer-insert-forbidden-move", this);
        } else {
          this.remove(item);
        }
      }
    }
    const version2 = position.root.document ? position.root.document.version : null;
    const insert = new insertoperation_default(position, item, version2);
    if (item instanceof text_default2) {
      insert.shouldReceiveAttributes = true;
    }
    this.batch.addOperation(insert);
    this.model.applyOperation(insert);
    if (item instanceof documentfragment_default2) {
      for (const [markerName, markerRange] of item.markers) {
        const rangeRootPosition = position_default2._createAt(markerRange.root, 0);
        const range = new range_default2(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));
        const options = {range, usingOperation: true, affectsData: true};
        if (this.model.markers.has(markerName)) {
          this.updateMarker(markerName, options);
        } else {
          this.addMarker(markerName, options);
        }
      }
    }
  }
  insertText(text, attributes, itemOrPosition, offset) {
    if (attributes instanceof documentfragment_default2 || attributes instanceof element_default2 || attributes instanceof position_default2) {
      this.insert(this.createText(text), attributes, itemOrPosition);
    } else {
      this.insert(this.createText(text, attributes), itemOrPosition, offset);
    }
  }
  insertElement(name, attributes, itemOrPositionOrOffset, offset) {
    if (attributes instanceof documentfragment_default2 || attributes instanceof element_default2 || attributes instanceof position_default2) {
      this.insert(this.createElement(name), attributes, itemOrPositionOrOffset);
    } else {
      this.insert(this.createElement(name, attributes), itemOrPositionOrOffset, offset);
    }
  }
  append(item, parent2) {
    this.insert(item, parent2, "end");
  }
  appendText(text, attributes, parent2) {
    if (attributes instanceof documentfragment_default2 || attributes instanceof element_default2) {
      this.insert(this.createText(text), attributes, "end");
    } else {
      this.insert(this.createText(text, attributes), parent2, "end");
    }
  }
  appendElement(name, attributes, parent2) {
    if (attributes instanceof documentfragment_default2 || attributes instanceof element_default2) {
      this.insert(this.createElement(name), attributes, "end");
    } else {
      this.insert(this.createElement(name, attributes), parent2, "end");
    }
  }
  setAttribute(key, value, itemOrRange) {
    this._assertWriterUsedCorrectly();
    if (itemOrRange instanceof range_default2) {
      const ranges = itemOrRange.getMinimalFlatRanges();
      for (const range of ranges) {
        setAttributeOnRange(this, key, value, range);
      }
    } else {
      setAttributeOnItem(this, key, value, itemOrRange);
    }
  }
  setAttributes(attributes, itemOrRange) {
    for (const [key, val] of toMap(attributes)) {
      this.setAttribute(key, val, itemOrRange);
    }
  }
  removeAttribute(key, itemOrRange) {
    this._assertWriterUsedCorrectly();
    if (itemOrRange instanceof range_default2) {
      const ranges = itemOrRange.getMinimalFlatRanges();
      for (const range of ranges) {
        setAttributeOnRange(this, key, null, range);
      }
    } else {
      setAttributeOnItem(this, key, null, itemOrRange);
    }
  }
  clearAttributes(itemOrRange) {
    this._assertWriterUsedCorrectly();
    const removeAttributesFromItem = (item) => {
      for (const attribute of item.getAttributeKeys()) {
        this.removeAttribute(attribute, item);
      }
    };
    if (!(itemOrRange instanceof range_default2)) {
      removeAttributesFromItem(itemOrRange);
    } else {
      for (const item of itemOrRange.getItems()) {
        removeAttributesFromItem(item);
      }
    }
  }
  move(range, itemOrPosition, offset) {
    this._assertWriterUsedCorrectly();
    if (!(range instanceof range_default2)) {
      throw new ckeditorerror_default("writer-move-invalid-range", this);
    }
    if (!range.isFlat) {
      throw new ckeditorerror_default("writer-move-range-not-flat", this);
    }
    const position = position_default2._createAt(itemOrPosition, offset);
    if (position.isEqual(range.start)) {
      return;
    }
    this._addOperationForAffectedMarkers("move", range);
    if (!isSameTree(range.root, position.root)) {
      throw new ckeditorerror_default("writer-move-different-document", this);
    }
    const version2 = range.root.document ? range.root.document.version : null;
    const operation = new moveoperation_default(range.start, range.end.offset - range.start.offset, position, version2);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
  }
  remove(itemOrRange) {
    this._assertWriterUsedCorrectly();
    const rangeToRemove = itemOrRange instanceof range_default2 ? itemOrRange : range_default2._createOn(itemOrRange);
    const ranges = rangeToRemove.getMinimalFlatRanges().reverse();
    for (const flat of ranges) {
      this._addOperationForAffectedMarkers("move", flat);
      applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);
    }
  }
  merge(position) {
    this._assertWriterUsedCorrectly();
    const nodeBefore = position.nodeBefore;
    const nodeAfter = position.nodeAfter;
    this._addOperationForAffectedMarkers("merge", position);
    if (!(nodeBefore instanceof element_default2)) {
      throw new ckeditorerror_default("writer-merge-no-element-before", this);
    }
    if (!(nodeAfter instanceof element_default2)) {
      throw new ckeditorerror_default("writer-merge-no-element-after", this);
    }
    if (!position.root.document) {
      this._mergeDetached(position);
    } else {
      this._merge(position);
    }
  }
  createPositionFromPath(root2, path, stickiness) {
    return this.model.createPositionFromPath(root2, path, stickiness);
  }
  createPositionAt(itemOrPosition, offset) {
    return this.model.createPositionAt(itemOrPosition, offset);
  }
  createPositionAfter(item) {
    return this.model.createPositionAfter(item);
  }
  createPositionBefore(item) {
    return this.model.createPositionBefore(item);
  }
  createRange(start, end) {
    return this.model.createRange(start, end);
  }
  createRangeIn(element) {
    return this.model.createRangeIn(element);
  }
  createRangeOn(element) {
    return this.model.createRangeOn(element);
  }
  createSelection(...args) {
    return this.model.createSelection(...args);
  }
  _mergeDetached(position) {
    const nodeBefore = position.nodeBefore;
    const nodeAfter = position.nodeAfter;
    this.move(range_default2._createIn(nodeAfter), position_default2._createAt(nodeBefore, "end"));
    this.remove(nodeAfter);
  }
  _merge(position) {
    const targetPosition = position_default2._createAt(position.nodeBefore, "end");
    const sourcePosition = position_default2._createAt(position.nodeAfter, 0);
    const graveyard = position.root.document.graveyard;
    const graveyardPosition = new position_default2(graveyard, [0]);
    const version2 = position.root.document.version;
    const merge2 = new mergeoperation_default(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version2);
    this.batch.addOperation(merge2);
    this.model.applyOperation(merge2);
  }
  rename(element, newName) {
    this._assertWriterUsedCorrectly();
    if (!(element instanceof element_default2)) {
      throw new ckeditorerror_default("writer-rename-not-element-instance", this);
    }
    const version2 = element.root.document ? element.root.document.version : null;
    const renameOperation = new renameoperation_default(position_default2._createBefore(element), element.name, newName, version2);
    this.batch.addOperation(renameOperation);
    this.model.applyOperation(renameOperation);
  }
  split(position, limitElement) {
    this._assertWriterUsedCorrectly();
    let splitElement = position.parent;
    if (!splitElement.parent) {
      throw new ckeditorerror_default("writer-split-element-no-parent", this);
    }
    if (!limitElement) {
      limitElement = splitElement.parent;
    }
    if (!position.parent.getAncestors({includeSelf: true}).includes(limitElement)) {
      throw new ckeditorerror_default("writer-split-invalid-limit-element", this);
    }
    let firstSplitElement;
    let firstCopyElement;
    do {
      const version2 = splitElement.root.document ? splitElement.root.document.version : null;
      const howMany = splitElement.maxOffset - position.offset;
      const insertionPosition = splitoperation_default.getInsertionPosition(position);
      const split = new splitoperation_default(position, howMany, insertionPosition, null, version2);
      this.batch.addOperation(split);
      this.model.applyOperation(split);
      if (!firstSplitElement && !firstCopyElement) {
        firstSplitElement = splitElement;
        firstCopyElement = position.parent.nextSibling;
      }
      position = this.createPositionAfter(position.parent);
      splitElement = position.parent;
    } while (splitElement !== limitElement);
    return {
      position,
      range: new range_default2(position_default2._createAt(firstSplitElement, "end"), position_default2._createAt(firstCopyElement, 0))
    };
  }
  wrap(range, elementOrString) {
    this._assertWriterUsedCorrectly();
    if (!range.isFlat) {
      throw new ckeditorerror_default("writer-wrap-range-not-flat", this);
    }
    const element = elementOrString instanceof element_default2 ? elementOrString : new element_default2(elementOrString);
    if (element.childCount > 0) {
      throw new ckeditorerror_default("writer-wrap-element-not-empty", this);
    }
    if (element.parent !== null) {
      throw new ckeditorerror_default("writer-wrap-element-attached", this);
    }
    this.insert(element, range.start);
    const shiftedRange = new range_default2(range.start.getShiftedBy(1), range.end.getShiftedBy(1));
    this.move(shiftedRange, position_default2._createAt(element, 0));
  }
  unwrap(element) {
    this._assertWriterUsedCorrectly();
    if (element.parent === null) {
      throw new ckeditorerror_default("writer-unwrap-element-no-parent", this);
    }
    this.move(range_default2._createIn(element), this.createPositionAfter(element));
    this.remove(element);
  }
  addMarker(name, options) {
    this._assertWriterUsedCorrectly();
    if (!options || typeof options.usingOperation != "boolean") {
      throw new ckeditorerror_default("writer-addmarker-no-usingoperation", this);
    }
    const usingOperation = options.usingOperation;
    const range = options.range;
    const affectsData = options.affectsData === void 0 ? false : options.affectsData;
    if (this.model.markers.has(name)) {
      throw new ckeditorerror_default("writer-addmarker-marker-exists", this);
    }
    if (!range) {
      throw new ckeditorerror_default("writer-addmarker-no-range", this);
    }
    if (!usingOperation) {
      return this.model.markers._set(name, range, usingOperation, affectsData);
    }
    applyMarkerOperation(this, name, null, range, affectsData);
    return this.model.markers.get(name);
  }
  updateMarker(markerOrName, options) {
    this._assertWriterUsedCorrectly();
    const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    const currentMarker = this.model.markers.get(markerName);
    if (!currentMarker) {
      throw new ckeditorerror_default("writer-updatemarker-marker-not-exists", this);
    }
    if (!options) {
      logWarning("writer-updatemarker-reconvert-using-editingcontroller", {markerName});
      this.model.markers._refresh(currentMarker);
      return;
    }
    const hasUsingOperationDefined = typeof options.usingOperation == "boolean";
    const affectsDataDefined = typeof options.affectsData == "boolean";
    const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;
    if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {
      throw new ckeditorerror_default("writer-updatemarker-wrong-options", this);
    }
    const currentRange = currentMarker.getRange();
    const updatedRange = options.range ? options.range : currentRange;
    if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {
      if (options.usingOperation) {
        applyMarkerOperation(this, markerName, null, updatedRange, affectsData);
      } else {
        applyMarkerOperation(this, markerName, currentRange, null, affectsData);
        this.model.markers._set(markerName, updatedRange, void 0, affectsData);
      }
      return;
    }
    if (currentMarker.managedUsingOperations) {
      applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);
    } else {
      this.model.markers._set(markerName, updatedRange, void 0, affectsData);
    }
  }
  removeMarker(markerOrName) {
    this._assertWriterUsedCorrectly();
    const name = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
    if (!this.model.markers.has(name)) {
      throw new ckeditorerror_default("writer-removemarker-no-marker", this);
    }
    const marker = this.model.markers.get(name);
    if (!marker.managedUsingOperations) {
      this.model.markers._remove(name);
      return;
    }
    const oldRange = marker.getRange();
    applyMarkerOperation(this, name, oldRange, null, marker.affectsData);
  }
  addRoot(rootName, elementName = "$root") {
    this._assertWriterUsedCorrectly();
    const root2 = this.model.document.getRoot(rootName);
    if (root2 && root2.isAttached()) {
      throw new ckeditorerror_default("writer-addroot-root-exists", this);
    }
    const document2 = this.model.document;
    const operation = new rootoperation_default(rootName, elementName, true, document2, document2.version);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
    return this.model.document.getRoot(rootName);
  }
  detachRoot(rootOrName) {
    this._assertWriterUsedCorrectly();
    const root2 = typeof rootOrName == "string" ? this.model.document.getRoot(rootOrName) : rootOrName;
    if (!root2 || !root2.isAttached()) {
      throw new ckeditorerror_default("writer-detachroot-no-root", this);
    }
    for (const marker of this.model.markers) {
      if (marker.getRange().root === root2) {
        this.removeMarker(marker);
      }
    }
    for (const key of root2.getAttributeKeys()) {
      this.removeAttribute(key, root2);
    }
    this.remove(this.createRangeIn(root2));
    const document2 = this.model.document;
    const operation = new rootoperation_default(root2.rootName, root2.name, false, document2, document2.version);
    this.batch.addOperation(operation);
    this.model.applyOperation(operation);
  }
  setSelection(...args) {
    this._assertWriterUsedCorrectly();
    this.model.document.selection._setTo(...args);
  }
  setSelectionFocus(itemOrPosition, offset) {
    this._assertWriterUsedCorrectly();
    this.model.document.selection._setFocus(itemOrPosition, offset);
  }
  setSelectionAttribute(keyOrObjectOrIterable, value) {
    this._assertWriterUsedCorrectly();
    if (typeof keyOrObjectOrIterable === "string") {
      this._setSelectionAttribute(keyOrObjectOrIterable, value);
    } else {
      for (const [key, value2] of toMap(keyOrObjectOrIterable)) {
        this._setSelectionAttribute(key, value2);
      }
    }
  }
  removeSelectionAttribute(keyOrIterableOfKeys) {
    this._assertWriterUsedCorrectly();
    if (typeof keyOrIterableOfKeys === "string") {
      this._removeSelectionAttribute(keyOrIterableOfKeys);
    } else {
      for (const key of keyOrIterableOfKeys) {
        this._removeSelectionAttribute(key);
      }
    }
  }
  overrideSelectionGravity() {
    return this.model.document.selection._overrideGravity();
  }
  restoreSelectionGravity(uid2) {
    this.model.document.selection._restoreGravity(uid2);
  }
  _setSelectionAttribute(key, value) {
    const selection = this.model.document.selection;
    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
      const storeKey = documentselection_default2._getStoreAttributeKey(key);
      this.setAttribute(storeKey, value, selection.anchor.parent);
    }
    selection._setAttribute(key, value);
  }
  _removeSelectionAttribute(key) {
    const selection = this.model.document.selection;
    if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
      const storeKey = documentselection_default2._getStoreAttributeKey(key);
      this.removeAttribute(storeKey, selection.anchor.parent);
    }
    selection._removeAttribute(key);
  }
  _assertWriterUsedCorrectly() {
    if (this.model._currentWriter !== this) {
      throw new ckeditorerror_default("writer-incorrect-use", this);
    }
  }
  _addOperationForAffectedMarkers(type, positionOrRange) {
    for (const marker of this.model.markers) {
      if (!marker.managedUsingOperations) {
        continue;
      }
      const markerRange = marker.getRange();
      let isAffected = false;
      if (type === "move") {
        const range = positionOrRange;
        isAffected = range.containsPosition(markerRange.start) || range.start.isEqual(markerRange.start) || range.containsPosition(markerRange.end) || range.end.isEqual(markerRange.end);
      } else {
        const position = positionOrRange;
        const elementBefore = position.nodeBefore;
        const elementAfter = position.nodeAfter;
        const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;
        const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;
        const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;
        const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;
        isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;
      }
      if (isAffected) {
        this.updateMarker(marker.name, {range: markerRange});
      }
    }
  }
};
var writer_default = Writer;
function setAttributeOnRange(writer, key, value, range) {
  const model = writer.model;
  const doc = model.document;
  let lastSplitPosition = range.start;
  let position;
  let valueBefore;
  let valueAfter;
  for (const val of range.getWalker({shallow: true})) {
    valueAfter = val.item.getAttribute(key);
    if (position && valueBefore != valueAfter) {
      if (valueBefore != value) {
        addOperation();
      }
      lastSplitPosition = position;
    }
    position = val.nextPosition;
    valueBefore = valueAfter;
  }
  if (position instanceof position_default2 && position != lastSplitPosition && valueBefore != value) {
    addOperation();
  }
  function addOperation() {
    const range2 = new range_default2(lastSplitPosition, position);
    const version2 = range2.root.document ? doc.version : null;
    const operation = new attributeoperation_default(range2, key, valueBefore, value, version2);
    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
}
function setAttributeOnItem(writer, key, value, item) {
  const model = writer.model;
  const doc = model.document;
  const previousValue = item.getAttribute(key);
  let range, operation;
  if (previousValue != value) {
    const isRootChanged = item.root === item;
    if (isRootChanged) {
      const version2 = item.document ? doc.version : null;
      operation = new rootattributeoperation_default(item, key, previousValue, value, version2);
    } else {
      range = new range_default2(position_default2._createBefore(item), writer.createPositionAfter(item));
      const version2 = range.root.document ? doc.version : null;
      operation = new attributeoperation_default(range, key, previousValue, value, version2);
    }
    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
}
function applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {
  const model = writer.model;
  const doc = model.document;
  const operation = new markeroperation_default(name, oldRange, newRange, model.markers, !!affectsData, doc.version);
  writer.batch.addOperation(operation);
  model.applyOperation(operation);
}
function applyRemoveOperation(position, howMany, batch, model) {
  let operation;
  if (position.root.document) {
    const doc = model.document;
    const graveyardPosition = new position_default2(doc.graveyard, [0]);
    operation = new moveoperation_default(position, howMany, graveyardPosition, doc.version);
  } else {
    operation = new detachoperation_default(position, howMany);
  }
  batch.addOperation(operation);
  model.applyOperation(operation);
}
function isSameTree(rootA, rootB) {
  if (rootA === rootB) {
    return true;
  }
  if (rootA instanceof rootelement_default && rootB instanceof rootelement_default) {
    return true;
  }
  return false;
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function deleteContent(model, selection, options = {}) {
  if (selection.isCollapsed) {
    return;
  }
  const selRange = selection.getFirstRange();
  if (selRange.root.rootName == "$graveyard") {
    return;
  }
  const schema = model.schema;
  model.change((writer) => {
    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {
      replaceEntireContentWithParagraph(writer, selection);
      return;
    }
    const attributesForAutoparagraph = {};
    if (!options.doNotAutoparagraph) {
      const selectedElement = selection.getSelectedElement();
      if (selectedElement) {
        Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, "copyOnReplace", true));
      }
    }
    const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange);
    if (!startPosition.isTouching(endPosition)) {
      writer.remove(writer.createRange(startPosition, endPosition));
    }
    if (!options.leaveUnmerged) {
      mergeBranches(writer, startPosition, endPosition);
      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);
    }
    collapseSelectionAt(writer, selection, startPosition);
    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {
      insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);
    }
    startPosition.detach();
    endPosition.detach();
  });
}
function getLivePositionsForSelectedBlocks(range) {
  const model = range.root.document.model;
  const startPosition = range.start;
  let endPosition = range.end;
  if (model.hasContent(range, {ignoreMarkers: true})) {
    const endBlock = getParentBlock2(endPosition);
    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {
      const selection = model.createSelection(range);
      model.modifySelection(selection, {direction: "backward"});
      const newEndPosition = selection.getLastPosition();
      const skippedRange = model.createRange(newEndPosition, endPosition);
      if (!model.hasContent(skippedRange, {ignoreMarkers: true})) {
        endPosition = newEndPosition;
      }
    }
  }
  return [
    liveposition_default.fromPosition(startPosition, "toPrevious"),
    liveposition_default.fromPosition(endPosition, "toNext")
  ];
}
function getParentBlock2(position) {
  const element = position.parent;
  const schema = element.root.document.model.schema;
  const ancestors = element.getAncestors({parentFirst: true, includeSelf: true});
  for (const element2 of ancestors) {
    if (schema.isLimit(element2)) {
      return null;
    }
    if (schema.isBlock(element2)) {
      return element2;
    }
  }
}
function mergeBranches(writer, startPosition, endPosition) {
  const model = writer.model;
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);
  if (!startAncestor || !endAncestor) {
    return;
  }
  if (!model.hasContent(startAncestor, {ignoreMarkers: true}) && model.hasContent(endAncestor, {ignoreMarkers: true})) {
    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);
  } else {
    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);
  }
}
function mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  }
  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement);
  if (!endPosition.isEqual(startPosition)) {
    writer.insert(endElement, startPosition);
  }
  writer.merge(startPosition);
  while (endPosition.parent.isEmpty) {
    const parentToRemove = endPosition.parent;
    endPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  }
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);
}
function mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  }
  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement);
  if (!endPosition.isEqual(startPosition)) {
    writer.insert(startElement, endPosition);
  }
  while (startPosition.parent.isEmpty) {
    const parentToRemove = startPosition.parent;
    startPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  }
  endPosition = writer.createPositionBefore(endElement);
  mergeRight(writer, endPosition);
  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  }
  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);
}
function mergeRight(writer, position) {
  const startElement = position.nodeBefore;
  const endElement = position.nodeAfter;
  if (startElement.name != endElement.name) {
    writer.rename(startElement, endElement.name);
  }
  writer.clearAttributes(startElement);
  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);
  writer.merge(position);
}
function checkShouldMerge(schema, startPosition, endPosition) {
  const startElement = startPosition.parent;
  const endElement = endPosition.parent;
  if (startElement == endElement) {
    return false;
  }
  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
    return false;
  }
  return isCrossingLimitElement(startPosition, endPosition, schema);
}
function getAncestorsJustBelowCommonAncestor(positionA, positionB) {
  const ancestorsA = positionA.getAncestors();
  const ancestorsB = positionB.getAncestors();
  let i = 0;
  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {
    i++;
  }
  return [ancestorsA[i], ancestorsB[i]];
}
function shouldAutoparagraph(schema, position) {
  const isTextAllowed = schema.checkChild(position, "$text");
  const isParagraphAllowed = schema.checkChild(position, "paragraph");
  return !isTextAllowed && isParagraphAllowed;
}
function isCrossingLimitElement(leftPos, rightPos, schema) {
  const rangeToCheck = new range_default2(leftPos, rightPos);
  for (const value of rangeToCheck.getWalker()) {
    if (schema.isLimit(value.item)) {
      return false;
    }
  }
  return true;
}
function insertParagraph(writer, position, selection, attributes = {}) {
  const paragraph = writer.createElement("paragraph");
  writer.model.schema.setAllowedAttributes(paragraph, attributes, writer);
  writer.insert(paragraph, position);
  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));
}
function replaceEntireContentWithParagraph(writer, selection) {
  const limitElement = writer.model.schema.getLimitElement(selection);
  writer.remove(writer.createRangeIn(limitElement));
  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);
}
function shouldEntireContentBeReplacedWithParagraph(schema, selection) {
  const limitElement = schema.getLimitElement(selection);
  if (!selection.containsEntireContent(limitElement)) {
    return false;
  }
  const range = selection.getFirstRange();
  if (range.start.parent == range.end.parent) {
    return false;
  }
  return schema.checkChild(limitElement, "paragraph");
}
function collapseSelectionAt(writer, selection, positionOrRange) {
  if (selection instanceof documentselection_default2) {
    writer.setSelection(positionOrRange);
  } else {
    selection.setTo(positionOrRange);
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/getselectedcontent.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getSelectedContent(model, selection) {
  return model.change((writer) => {
    const frag = writer.createDocumentFragment();
    const range = selection.getFirstRange();
    if (!range || range.isCollapsed) {
      return frag;
    }
    const root2 = range.start.root;
    const commonPath = range.start.getCommonPath(range.end);
    const commonParent = root2.getNodeByPath(commonPath);
    let flatSubtreeRange;
    if (range.start.parent == range.end.parent) {
      flatSubtreeRange = range;
    } else {
      flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));
    }
    const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;
    for (const item of flatSubtreeRange.getItems({shallow: true})) {
      if (item.is("$textProxy")) {
        writer.appendText(item.data, item.getAttributes(), frag);
      } else {
        writer.append(writer.cloneElement(item, true), frag);
      }
    }
    if (flatSubtreeRange != range) {
      const newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];
      const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);
      const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, "end"));
      removeRangeContent(rightExcessRange, writer);
      removeRangeContent(leftExcessRange, writer);
    }
    return frag;
  });
}
function removeRangeContent(range, writer) {
  const parentsToCheck = [];
  Array.from(range.getItems({direction: "backward"})).map((item) => writer.createRangeOn(item)).filter((itemRange) => {
    const contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) && (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));
    return contained;
  }).forEach((itemRange) => {
    parentsToCheck.push(itemRange.start.parent);
    writer.remove(itemRange);
  });
  parentsToCheck.forEach((parentToCheck) => {
    let parent2 = parentToCheck;
    while (parent2.parent && parent2.isEmpty) {
      const removeRange = writer.createRangeOn(parent2);
      parent2 = parent2.parent;
      writer.remove(removeRange);
    }
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function insertContent(model, content, selectable) {
  return model.change((writer) => {
    const selection = selectable ? selectable : model.document.selection;
    if (!selection.isCollapsed) {
      model.deleteContent(selection, {doNotAutoparagraph: true});
    }
    const insertion = new Insertion(model, writer, selection.anchor);
    const fakeMarkerElements = [];
    let nodesToInsert;
    if (content.is("documentFragment")) {
      if (content.markers.size) {
        const markersPosition = [];
        for (const [name, range] of content.markers) {
          const {start, end} = range;
          const isCollapsed = start.isEqual(end);
          markersPosition.push({position: start, name, isCollapsed}, {position: end, name, isCollapsed});
        }
        markersPosition.sort(({position: posA}, {position: posB}) => posA.isBefore(posB) ? 1 : -1);
        for (const {position, name, isCollapsed} of markersPosition) {
          let fakeElement = null;
          let collapsed = null;
          const isAtBeginning = position.parent === content && position.isAtStart;
          const isAtEnd = position.parent === content && position.isAtEnd;
          if (!isAtBeginning && !isAtEnd) {
            fakeElement = writer.createElement("$marker");
            writer.insert(fakeElement, position);
          } else if (isCollapsed) {
            collapsed = isAtBeginning ? "start" : "end";
          }
          fakeMarkerElements.push({
            name,
            element: fakeElement,
            collapsed
          });
        }
      }
      nodesToInsert = content.getChildren();
    } else {
      nodesToInsert = [content];
    }
    insertion.handleNodes(nodesToInsert);
    let newRange = insertion.getSelectionRange();
    if (content.is("documentFragment") && fakeMarkerElements.length) {
      const selectionLiveRange = newRange ? liverange_default.fromRange(newRange) : null;
      const markersData = {};
      for (let i = fakeMarkerElements.length - 1; i >= 0; i--) {
        const {name, element, collapsed} = fakeMarkerElements[i];
        const isStartBoundary = !markersData[name];
        if (isStartBoundary) {
          markersData[name] = [];
        }
        if (element) {
          const elementPosition = writer.createPositionAt(element, "before");
          markersData[name].push(elementPosition);
          writer.remove(element);
        } else {
          const rangeOnInsertion = insertion.getAffectedRange();
          if (!rangeOnInsertion) {
            if (collapsed) {
              markersData[name].push(insertion.position);
            }
            continue;
          }
          if (collapsed) {
            markersData[name].push(rangeOnInsertion[collapsed]);
          } else {
            markersData[name].push(isStartBoundary ? rangeOnInsertion.start : rangeOnInsertion.end);
          }
        }
      }
      for (const [name, [start, end]] of Object.entries(markersData)) {
        if (start && end && start.root === end.root) {
          writer.addMarker(name, {
            usingOperation: true,
            affectsData: true,
            range: new range_default2(start, end)
          });
        }
      }
      if (selectionLiveRange) {
        newRange = selectionLiveRange.toRange();
        selectionLiveRange.detach();
      }
    }
    /* istanbul ignore else -- @preserve */
    if (newRange) {
      if (selection instanceof documentselection_default2) {
        writer.setSelection(newRange);
      } else {
        selection.setTo(newRange);
      }
    } else {
    }
    const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);
    insertion.destroy();
    return affectedRange;
  });
}
var Insertion = class {
  constructor(model, writer, position) {
    this._firstNode = null;
    this._lastNode = null;
    this._lastAutoParagraph = null;
    this._filterAttributesOf = [];
    this._affectedStart = null;
    this._affectedEnd = null;
    this._nodeToSelect = null;
    this.model = model;
    this.writer = writer;
    this.position = position;
    this.canMergeWith = new Set([this.position.parent]);
    this.schema = model.schema;
    this._documentFragment = writer.createDocumentFragment();
    this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);
  }
  handleNodes(nodes) {
    for (const node of Array.from(nodes)) {
      this._handleNode(node);
    }
    this._insertPartialFragment();
    if (this._lastAutoParagraph) {
      this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
    }
    this._mergeOnRight();
    this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
    this._filterAttributesOf = [];
  }
  _updateLastNodeFromAutoParagraph(node) {
    const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);
    const positionAfterNode = this.writer.createPositionAfter(node);
    if (positionAfterNode.isAfter(positionAfterLastNode)) {
      this._lastNode = node;
      /* istanbul ignore if -- @preserve */
      if (this.position.parent != node || !this.position.isAtEnd) {
        throw new ckeditorerror_default("insertcontent-invalid-insertion-position", this);
      }
      this.position = positionAfterNode;
      this._setAffectedBoundaries(this.position);
    }
  }
  getSelectionRange() {
    if (this._nodeToSelect) {
      return range_default2._createOn(this._nodeToSelect);
    }
    return this.model.schema.getNearestSelectionRange(this.position);
  }
  getAffectedRange() {
    if (!this._affectedStart) {
      return null;
    }
    return new range_default2(this._affectedStart, this._affectedEnd);
  }
  destroy() {
    if (this._affectedStart) {
      this._affectedStart.detach();
    }
    if (this._affectedEnd) {
      this._affectedEnd.detach();
    }
  }
  _handleNode(node) {
    if (this.schema.isObject(node)) {
      this._handleObject(node);
      return;
    }
    let isAllowed = this._checkAndAutoParagraphToAllowedPosition(node);
    if (!isAllowed) {
      isAllowed = this._checkAndSplitToAllowedPosition(node);
      if (!isAllowed) {
        this._handleDisallowedNode(node);
        return;
      }
    }
    this._appendToFragment(node);
    if (!this._firstNode) {
      this._firstNode = node;
    }
    this._lastNode = node;
  }
  _insertPartialFragment() {
    if (this._documentFragment.isEmpty) {
      return;
    }
    const livePosition = liveposition_default.fromPosition(this.position, "toNext");
    this._setAffectedBoundaries(this.position);
    if (this._documentFragment.getChild(0) == this._firstNode) {
      this.writer.insert(this._firstNode, this.position);
      this._mergeOnLeft();
      this.position = livePosition.toPosition();
    }
    if (!this._documentFragment.isEmpty) {
      this.writer.insert(this._documentFragment, this.position);
    }
    this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);
    this.position = livePosition.toPosition();
    livePosition.detach();
  }
  _handleObject(node) {
    if (this._checkAndSplitToAllowedPosition(node)) {
      this._appendToFragment(node);
    } else {
      this._tryAutoparagraphing(node);
    }
  }
  _handleDisallowedNode(node) {
    if (node.is("element")) {
      this.handleNodes(node.getChildren());
    } else {
      this._tryAutoparagraphing(node);
    }
  }
  _appendToFragment(node) {
    /* istanbul ignore if -- @preserve */
    if (!this.schema.checkChild(this.position, node)) {
      throw new ckeditorerror_default("insertcontent-wrong-position", this, {node, position: this.position});
    }
    this.writer.insert(node, this._documentFragmentPosition);
    this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize);
    if (this.schema.isObject(node) && !this.schema.checkChild(this.position, "$text")) {
      this._nodeToSelect = node;
    } else {
      this._nodeToSelect = null;
    }
    this._filterAttributesOf.push(node);
  }
  _setAffectedBoundaries(position) {
    if (!this._affectedStart) {
      this._affectedStart = liveposition_default.fromPosition(position, "toPrevious");
    }
    if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {
      if (this._affectedEnd) {
        this._affectedEnd.detach();
      }
      this._affectedEnd = liveposition_default.fromPosition(position, "toNext");
    }
  }
  _mergeOnLeft() {
    const node = this._firstNode;
    if (!(node instanceof element_default2)) {
      return;
    }
    if (!this._canMergeLeft(node)) {
      return;
    }
    const mergePosLeft = liveposition_default._createBefore(node);
    mergePosLeft.stickiness = "toNext";
    const livePosition = liveposition_default.fromPosition(this.position, "toNext");
    if (this._affectedStart.isEqual(mergePosLeft)) {
      this._affectedStart.detach();
      this._affectedStart = liveposition_default._createAt(mergePosLeft.nodeBefore, "end", "toPrevious");
    }
    if (this._firstNode === this._lastNode) {
      this._firstNode = mergePosLeft.nodeBefore;
      this._lastNode = mergePosLeft.nodeBefore;
    }
    this.writer.merge(mergePosLeft);
    if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
      this._affectedEnd.detach();
      this._affectedEnd = liveposition_default._createAt(mergePosLeft.nodeBefore, "end", "toNext");
    }
    this.position = livePosition.toPosition();
    livePosition.detach();
    this._filterAttributesOf.push(this.position.parent);
    mergePosLeft.detach();
  }
  _mergeOnRight() {
    const node = this._lastNode;
    if (!(node instanceof element_default2)) {
      return;
    }
    if (!this._canMergeRight(node)) {
      return;
    }
    const mergePosRight = liveposition_default._createAfter(node);
    mergePosRight.stickiness = "toNext";
    /* istanbul ignore if -- @preserve */
    if (!this.position.isEqual(mergePosRight)) {
      throw new ckeditorerror_default("insertcontent-invalid-insertion-position", this);
    }
    this.position = position_default2._createAt(mergePosRight.nodeBefore, "end");
    const livePosition = liveposition_default.fromPosition(this.position, "toPrevious");
    if (this._affectedEnd.isEqual(mergePosRight)) {
      this._affectedEnd.detach();
      this._affectedEnd = liveposition_default._createAt(mergePosRight.nodeBefore, "end", "toNext");
    }
    if (this._firstNode === this._lastNode) {
      this._firstNode = mergePosRight.nodeBefore;
      this._lastNode = mergePosRight.nodeBefore;
    }
    this.writer.merge(mergePosRight);
    if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {
      this._affectedStart.detach();
      this._affectedStart = liveposition_default._createAt(mergePosRight.nodeBefore, 0, "toPrevious");
    }
    this.position = livePosition.toPosition();
    livePosition.detach();
    this._filterAttributesOf.push(this.position.parent);
    mergePosRight.detach();
  }
  _canMergeLeft(node) {
    const previousSibling = node.previousSibling;
    return previousSibling instanceof element_default2 && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);
  }
  _canMergeRight(node) {
    const nextSibling = node.nextSibling;
    return nextSibling instanceof element_default2 && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);
  }
  _tryAutoparagraphing(node) {
    const paragraph = this.writer.createElement("paragraph");
    if (this._getAllowedIn(this.position.parent, paragraph) && this.schema.checkChild(paragraph, node)) {
      paragraph._appendChild(node);
      this._handleNode(paragraph);
    }
  }
  _checkAndAutoParagraphToAllowedPosition(node) {
    if (this.schema.checkChild(this.position.parent, node)) {
      return true;
    }
    if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", node)) {
      return false;
    }
    this._insertPartialFragment();
    const paragraph = this.writer.createElement("paragraph");
    this.writer.insert(paragraph, this.position);
    this._setAffectedBoundaries(this.position);
    this._lastAutoParagraph = paragraph;
    this.position = this.writer.createPositionAt(paragraph, 0);
    return true;
  }
  _checkAndSplitToAllowedPosition(node) {
    const allowedIn = this._getAllowedIn(this.position.parent, node);
    if (!allowedIn) {
      return false;
    }
    if (allowedIn != this.position.parent) {
      this._insertPartialFragment();
    }
    while (allowedIn != this.position.parent) {
      if (this.position.isAtStart) {
        const parent2 = this.position.parent;
        this.position = this.writer.createPositionBefore(parent2);
        if (parent2.isEmpty && parent2.parent === allowedIn) {
          this.writer.remove(parent2);
        }
      } else if (this.position.isAtEnd) {
        this.position = this.writer.createPositionAfter(this.position.parent);
      } else {
        const tempPos = this.writer.createPositionAfter(this.position.parent);
        this._setAffectedBoundaries(this.position);
        this.writer.split(this.position);
        this.position = tempPos;
        this.canMergeWith.add(this.position.nodeAfter);
      }
    }
    return true;
  }
  _getAllowedIn(contextElement, childNode) {
    if (this.schema.checkChild(contextElement, childNode)) {
      return contextElement;
    }
    if (this.schema.isLimit(contextElement)) {
      return null;
    }
    return this._getAllowedIn(contextElement.parent, childNode);
  }
};

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/findoptimalinsertionrange.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function findOptimalInsertionRange(selection, model, place = "auto") {
  const selectedElement = selection.getSelectedElement();
  if (selectedElement && model.schema.isObject(selectedElement) && !model.schema.isInline(selectedElement)) {
    if (place == "before" || place == "after") {
      return model.createRange(model.createPositionAt(selectedElement, place));
    }
    return model.createRangeOn(selectedElement);
  }
  const firstBlock = first(selection.getSelectedBlocks());
  if (!firstBlock) {
    return model.createRange(selection.focus);
  }
  if (firstBlock.isEmpty) {
    return model.createRange(model.createPositionAt(firstBlock, 0));
  }
  const positionAfter = model.createPositionAfter(firstBlock);
  if (selection.focus.isTouching(positionAfter)) {
    return model.createRange(positionAfter);
  }
  return model.createRange(model.createPositionBefore(firstBlock));
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertobject.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function insertObject(model, object, selectable, options = {}) {
  if (!model.schema.isObject(object)) {
    throw new ckeditorerror_default("insertobject-element-not-an-object", model, {object});
  }
  const originalSelection = selectable ? selectable : model.document.selection;
  let insertionSelection = originalSelection;
  if (options.findOptimalPosition && model.schema.isBlock(object)) {
    insertionSelection = model.createSelection(findOptimalInsertionRange(originalSelection, model, options.findOptimalPosition));
  }
  const firstSelectedBlock = first(originalSelection.getSelectedBlocks());
  const attributesToCopy = {};
  if (firstSelectedBlock) {
    Object.assign(attributesToCopy, model.schema.getAttributesWithProperty(firstSelectedBlock, "copyOnReplace", true));
  }
  return model.change((writer) => {
    if (!insertionSelection.isCollapsed) {
      model.deleteContent(insertionSelection, {doNotAutoparagraph: true});
    }
    let elementToInsert = object;
    const insertionPositionParent = insertionSelection.anchor.parent;
    if (!model.schema.checkChild(insertionPositionParent, object) && model.schema.checkChild(insertionPositionParent, "paragraph") && model.schema.checkChild("paragraph", object)) {
      elementToInsert = writer.createElement("paragraph");
      writer.insert(object, elementToInsert);
    }
    model.schema.setAllowedAttributes(elementToInsert, attributesToCopy, writer);
    const affectedRange = model.insertContent(elementToInsert, insertionSelection);
    if (affectedRange.isCollapsed) {
      return affectedRange;
    }
    if (options.setSelection) {
      updateSelection(writer, object, options.setSelection, attributesToCopy);
    }
    return affectedRange;
  });
}
function updateSelection(writer, contextElement, place, paragraphAttributes) {
  const model = writer.model;
  if (place == "on") {
    writer.setSelection(contextElement, "on");
    return;
  }
  if (place != "after") {
    throw new ckeditorerror_default("insertobject-invalid-place-parameter-value", model);
  }
  let nextElement = contextElement.nextSibling;
  if (model.schema.isInline(contextElement)) {
    writer.setSelection(contextElement, "after");
    return;
  }
  const canSetSelection = nextElement && model.schema.checkChild(nextElement, "$text");
  if (!canSetSelection && model.schema.checkChild(contextElement.parent, "paragraph")) {
    nextElement = writer.createElement("paragraph");
    model.schema.setAllowedAttributes(nextElement, paragraphAttributes, writer);
    model.insertContent(nextElement, writer.createPositionAfter(contextElement));
  }
  if (nextElement) {
    writer.setSelection(nextElement, 0);
  }
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var wordBoundaryCharacters = ' ,.?!:;"-()';
function modifySelection(model, selection, options = {}) {
  const schema = model.schema;
  const isForward = options.direction != "backward";
  const unit = options.unit ? options.unit : "character";
  const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;
  const focus = selection.focus;
  const walker = new treewalker_default2({
    boundaries: getSearchRange(focus, isForward),
    singleCharacters: true,
    direction: isForward ? "forward" : "backward"
  });
  const data = {walker, schema, isForward, unit, treatEmojiAsSingleUnit};
  let next;
  while (next = walker.next()) {
    if (next.done) {
      return;
    }
    const position = tryExtendingTo(data, next.value);
    if (position) {
      if (selection instanceof documentselection_default2) {
        model.change((writer) => {
          writer.setSelectionFocus(position);
        });
      } else {
        selection.setFocus(position);
      }
      return;
    }
  }
}
function tryExtendingTo(data, value) {
  const {isForward, walker, unit, schema, treatEmojiAsSingleUnit} = data;
  const {type, item, nextPosition} = value;
  if (type == "text") {
    if (data.unit === "word") {
      return getCorrectWordBreakPosition(walker, isForward);
    }
    return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);
  }
  if (type == (isForward ? "elementStart" : "elementEnd")) {
    if (schema.isSelectable(item)) {
      return position_default2._createAt(item, isForward ? "after" : "before");
    }
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  } else {
    if (schema.isLimit(item)) {
      walker.skip(() => true);
      return;
    }
    if (schema.checkChild(nextPosition, "$text")) {
      return nextPosition;
    }
  }
}
function getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {
  const textNode = walker.position.textNode;
  if (textNode) {
    const data = textNode.data;
    let offset = walker.position.offset - textNode.startOffset;
    while (isInsideSurrogatePair(data, offset) || unit == "character" && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {
      walker.next();
      offset = walker.position.offset - textNode.startOffset;
    }
  }
  return walker.position;
}
function getCorrectWordBreakPosition(walker, isForward) {
  let textNode = walker.position.textNode;
  if (!textNode) {
    textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
  }
  while (textNode && textNode.is("$text")) {
    const offset = walker.position.offset - textNode.startOffset;
    if (isAtNodeBoundary(textNode, offset, isForward)) {
      textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
    } else if (isAtWordBoundary(textNode.data, offset, isForward)) {
      break;
    } else {
      walker.next();
    }
  }
  return walker.position;
}
function getSearchRange(start, isForward) {
  const root2 = start.root;
  const searchEnd = position_default2._createAt(root2, isForward ? "end" : 0);
  if (isForward) {
    return new range_default2(start, searchEnd);
  } else {
    return new range_default2(searchEnd, start);
  }
}
function isAtWordBoundary(data, offset, isForward) {
  const offsetToCheck = offset + (isForward ? 0 : -1);
  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));
}
function isAtNodeBoundary(textNode, offset, isForward) {
  return offset === (isForward ? textNode.offsetSize : 0);
}

// node_modules/@ckeditor/ckeditor5-engine/src/model/model.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Model = class extends ObservableMixin() {
  constructor() {
    super();
    this.markers = new markercollection_default();
    this.document = new document_default2(this);
    this.schema = new schema_default();
    this._pendingChanges = [];
    this._currentWriter = null;
    ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((methodName) => this.decorate(methodName));
    this.on("applyOperation", (evt, args) => {
      const operation = args[0];
      operation._validate();
    }, {priority: "highest"});
    this.schema.register("$root", {
      isLimit: true
    });
    this.schema.register("$container", {
      allowIn: ["$root", "$container"]
    });
    this.schema.register("$block", {
      allowIn: ["$root", "$container"],
      isBlock: true
    });
    this.schema.register("$blockObject", {
      allowWhere: "$block",
      isBlock: true,
      isObject: true
    });
    this.schema.register("$inlineObject", {
      allowWhere: "$text",
      allowAttributesOf: "$text",
      isInline: true,
      isObject: true
    });
    this.schema.register("$text", {
      allowIn: "$block",
      isInline: true,
      isContent: true
    });
    this.schema.register("$clipboardHolder", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: true
    });
    this.schema.register("$documentFragment", {
      allowContentOf: "$root",
      allowChildren: "$text",
      isLimit: true
    });
    this.schema.register("$marker");
    this.schema.addChildCheck((context, childDefinition) => {
      if (childDefinition.name === "$marker") {
        return true;
      }
    });
    injectSelectionPostFixer(this);
    this.document.registerPostFixer(autoParagraphEmptyRoots);
    this.on("insertContent", (evt, [content, selectable]) => {
      evt.return = insertContent(this, content, selectable);
    });
    this.on("insertObject", (evt, [element, selection, options]) => {
      evt.return = insertObject(this, element, selection, options);
    });
    this.on("canEditAt", (evt) => {
      const canEditAt = !this.document.isReadOnly;
      evt.return = canEditAt;
      if (!canEditAt) {
        evt.stop();
      }
    });
  }
  change(callback) {
    try {
      if (this._pendingChanges.length === 0) {
        this._pendingChanges.push({batch: new batch_default(), callback});
        return this._runPendingChanges()[0];
      } else {
        return callback(this._currentWriter);
      }
    } catch (err) {
      /* istanbul ignore next -- @preserve */
      ckeditorerror_default.rethrowUnexpectedError(err, this);
    }
  }
  enqueueChange(batchOrType, callback) {
    try {
      if (!batchOrType) {
        batchOrType = new batch_default();
      } else if (typeof batchOrType === "function") {
        callback = batchOrType;
        batchOrType = new batch_default();
      } else if (!(batchOrType instanceof batch_default)) {
        batchOrType = new batch_default(batchOrType);
      }
      this._pendingChanges.push({batch: batchOrType, callback});
      if (this._pendingChanges.length == 1) {
        this._runPendingChanges();
      }
    } catch (err) {
      /* istanbul ignore next -- @preserve */
      ckeditorerror_default.rethrowUnexpectedError(err, this);
    }
  }
  applyOperation(operation) {
    operation._execute();
  }
  insertContent(content, selectable, placeOrOffset, ...rest) {
    const selection = normalizeSelectable(selectable, placeOrOffset);
    return this.fire("insertContent", [content, selection, placeOrOffset, ...rest]);
  }
  insertObject(element, selectable, placeOrOffset, options, ...rest) {
    const selection = normalizeSelectable(selectable, placeOrOffset);
    return this.fire("insertObject", [element, selection, options, options, ...rest]);
  }
  deleteContent(selection, options) {
    deleteContent(this, selection, options);
  }
  modifySelection(selection, options) {
    modifySelection(this, selection, options);
  }
  getSelectedContent(selection) {
    return getSelectedContent(this, selection);
  }
  hasContent(rangeOrElement, options = {}) {
    const range = rangeOrElement instanceof range_default2 ? rangeOrElement : range_default2._createIn(rangeOrElement);
    if (range.isCollapsed) {
      return false;
    }
    const {ignoreWhitespaces = false, ignoreMarkers = false} = options;
    if (!ignoreMarkers) {
      for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range)) {
        if (intersectingMarker.affectsData) {
          return true;
        }
      }
    }
    for (const item of range.getItems()) {
      if (this.schema.isContent(item)) {
        if (item.is("$textProxy")) {
          if (!ignoreWhitespaces) {
            return true;
          } else if (item.data.search(/\S/) !== -1) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
  canEditAt(selectable) {
    const selection = normalizeSelectable(selectable);
    return this.fire("canEditAt", [selection]);
  }
  createPositionFromPath(root2, path, stickiness) {
    return new position_default2(root2, path, stickiness);
  }
  createPositionAt(itemOrPosition, offset) {
    return position_default2._createAt(itemOrPosition, offset);
  }
  createPositionAfter(item) {
    return position_default2._createAfter(item);
  }
  createPositionBefore(item) {
    return position_default2._createBefore(item);
  }
  createRange(start, end) {
    return new range_default2(start, end);
  }
  createRangeIn(element) {
    return range_default2._createIn(element);
  }
  createRangeOn(item) {
    return range_default2._createOn(item);
  }
  createSelection(...args) {
    return new selection_default2(...args);
  }
  createBatch(type) {
    return new batch_default(type);
  }
  createOperationFromJSON(json) {
    return operationfactory_default.fromJSON(json, this.document);
  }
  destroy() {
    this.document.destroy();
    this.stopListening();
  }
  _runPendingChanges() {
    const ret = [];
    this.fire("_beforeChanges");
    try {
      while (this._pendingChanges.length) {
        const currentBatch = this._pendingChanges[0].batch;
        this._currentWriter = new writer_default(this, currentBatch);
        const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);
        ret.push(callbackReturnValue);
        this.document._handleChangeBlock(this._currentWriter);
        this._pendingChanges.shift();
        this._currentWriter = null;
      }
    } finally {
      this._pendingChanges.length = 0;
      this._currentWriter = null;
      this.fire("_afterChanges");
    }
    return ret;
  }
};
var model_default = Model;
function normalizeSelectable(selectable, placeOrOffset) {
  if (!selectable) {
    return;
  }
  if (selectable instanceof selection_default2 || selectable instanceof documentselection_default2) {
    return selectable;
  }
  if (selectable instanceof node_default2) {
    if (placeOrOffset || placeOrOffset === 0) {
      return new selection_default2(selectable, placeOrOffset);
    } else if (selectable.is("rootElement")) {
      return new selection_default2(selectable, "in");
    } else {
      return new selection_default2(selectable, "on");
    }
  }
  return new selection_default2(selectable);
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/clickobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ClickObserver = class extends domeventobserver_default {
  constructor() {
    super(...arguments);
    this.domEventType = "click";
  }
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};
var clickobserver_default = ClickObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MouseObserver = class extends domeventobserver_default {
  constructor() {
    super(...arguments);
    this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
  }
  onDomEvent(domEvent) {
    this.fire(domEvent.type, domEvent);
  }
};
var mouseobserver_default = MouseObserver;

// node_modules/@ckeditor/ckeditor5-engine/src/view/upcastwriter.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var UpcastWriter = class {
  constructor(document2) {
    this.document = document2;
  }
  createDocumentFragment(children) {
    return new documentfragment_default(this.document, children);
  }
  createElement(name, attrs, children) {
    return new element_default(this.document, name, attrs, children);
  }
  createText(data) {
    return new text_default(this.document, data);
  }
  clone(element, deep = false) {
    return element._clone(deep);
  }
  appendChild(items, element) {
    return element._appendChild(items);
  }
  insertChild(index, items, element) {
    return element._insertChild(index, items);
  }
  removeChildren(index, howMany, element) {
    return element._removeChildren(index, howMany);
  }
  remove(element) {
    const parent2 = element.parent;
    if (parent2) {
      return this.removeChildren(parent2.getChildIndex(element), 1, parent2);
    }
    return [];
  }
  replace(oldElement, newElement) {
    const parent2 = oldElement.parent;
    if (parent2) {
      const index = parent2.getChildIndex(oldElement);
      this.removeChildren(index, 1, parent2);
      this.insertChild(index, newElement, parent2);
      return true;
    }
    return false;
  }
  unwrapElement(element) {
    const parent2 = element.parent;
    if (parent2) {
      const index = parent2.getChildIndex(element);
      this.remove(element);
      this.insertChild(index, element.getChildren(), parent2);
    }
  }
  rename(newName, element) {
    const newElement = new element_default(this.document, newName, element.getAttributes(), element.getChildren());
    return this.replace(element, newElement) ? newElement : null;
  }
  setAttribute(key, value, element) {
    element._setAttribute(key, value);
  }
  removeAttribute(key, element) {
    element._removeAttribute(key);
  }
  addClass(className, element) {
    element._addClass(className);
  }
  removeClass(className, element) {
    element._removeClass(className);
  }
  setStyle(property, valueOrElement, element) {
    if (isPlainObject_default(property) && element === void 0) {
      valueOrElement._setStyle(property);
    } else {
      element._setStyle(property, valueOrElement);
    }
  }
  removeStyle(property, element) {
    element._removeStyle(property);
  }
  setCustomProperty(key, value, element) {
    element._setCustomProperty(key, value);
  }
  removeCustomProperty(key, element) {
    return element._removeCustomProperty(key);
  }
  createPositionAt(itemOrPosition, offset) {
    return position_default._createAt(itemOrPosition, offset);
  }
  createPositionAfter(item) {
    return position_default._createAfter(item);
  }
  createPositionBefore(item) {
    return position_default._createBefore(item);
  }
  createRange(start, end) {
    return new range_default(start, end);
  }
  createRangeOn(item) {
    return range_default._createOn(item);
  }
  createRangeIn(element) {
    return range_default._createIn(element);
  }
  createSelection(...args) {
    return new selection_default(...args);
  }
};
var upcastwriter_default = UpcastWriter;

// node_modules/@ckeditor/ckeditor5-engine/src/view/styles/utils.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var HEX_COLOR_REGEXP = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
var RGB_COLOR_REGEXP = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
var RGBA_COLOR_REGEXP = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
var HSL_COLOR_REGEXP = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
var HSLA_COLOR_REGEXP = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
var CSS_SHORTHAND_VALUE_REGEXP = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi;
var COLOR_NAMES = new Set([
  "black",
  "silver",
  "gray",
  "white",
  "maroon",
  "red",
  "purple",
  "fuchsia",
  "green",
  "lime",
  "olive",
  "yellow",
  "navy",
  "blue",
  "teal",
  "aqua",
  "orange",
  "aliceblue",
  "antiquewhite",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "blanchedalmond",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkgrey",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkslategrey",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dimgrey",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "greenyellow",
  "grey",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightgrey",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightslategrey",
  "lightsteelblue",
  "lightyellow",
  "limegreen",
  "linen",
  "magenta",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "oldlace",
  "olivedrab",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "skyblue",
  "slateblue",
  "slategray",
  "slategrey",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "whitesmoke",
  "yellowgreen",
  "activeborder",
  "activecaption",
  "appworkspace",
  "background",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "captiontext",
  "graytext",
  "highlight",
  "highlighttext",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infobackground",
  "infotext",
  "menu",
  "menutext",
  "scrollbar",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "window",
  "windowframe",
  "windowtext",
  "rebeccapurple",
  "currentcolor",
  "transparent"
]);
function isColor(string) {
  if (string.startsWith("#")) {
    return HEX_COLOR_REGEXP.test(string);
  }
  if (string.startsWith("rgb")) {
    return RGB_COLOR_REGEXP.test(string) || RGBA_COLOR_REGEXP.test(string);
  }
  if (string.startsWith("hsl")) {
    return HSL_COLOR_REGEXP.test(string) || HSLA_COLOR_REGEXP.test(string);
  }
  return COLOR_NAMES.has(string.toLowerCase());
}
var lineStyleValues = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
function isLineStyle(string) {
  return lineStyleValues.includes(string);
}
var lengthRegExp = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
function isLength2(string) {
  return lengthRegExp.test(string);
}
var PERCENTAGE_VALUE_REGEXP = /^[+-]?[0-9]*([.][0-9]+)?%$/;
function isPercentage(string) {
  return PERCENTAGE_VALUE_REGEXP.test(string);
}
var repeatValues = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
function isRepeat(string) {
  return repeatValues.includes(string);
}
var positionValues = ["center", "top", "bottom", "left", "right"];
function isPosition(string) {
  return positionValues.includes(string);
}
var attachmentValues = ["fixed", "scroll", "local"];
function isAttachment(string) {
  return attachmentValues.includes(string);
}
var urlRegExp = /^url\(/;
function isURL(string) {
  return urlRegExp.test(string);
}
function getBoxSidesValues(value = "") {
  if (value === "") {
    return {top: void 0, right: void 0, bottom: void 0, left: void 0};
  }
  const values = getShorthandValues(value);
  const top = values[0];
  const bottom = values[2] || top;
  const right = values[1] || top;
  const left = values[3] || right;
  return {top, bottom, right, left};
}
function getBoxSidesValueReducer(styleShorthand) {
  return (value) => {
    const {top, right, bottom, left} = value;
    const reduced = [];
    if (![top, right, left, bottom].every((value2) => !!value2)) {
      if (top) {
        reduced.push([styleShorthand + "-top", top]);
      }
      if (right) {
        reduced.push([styleShorthand + "-right", right]);
      }
      if (bottom) {
        reduced.push([styleShorthand + "-bottom", bottom]);
      }
      if (left) {
        reduced.push([styleShorthand + "-left", left]);
      }
    } else {
      reduced.push([styleShorthand, getBoxSidesShorthandValue(value)]);
    }
    return reduced;
  };
}
function getBoxSidesShorthandValue({top, right, bottom, left}) {
  const out = [];
  if (left !== right) {
    out.push(top, right, bottom, left);
  } else if (bottom !== top) {
    out.push(top, right, bottom);
  } else if (right !== top) {
    out.push(top, right);
  } else {
    out.push(top);
  }
  return out.join(" ");
}
function getPositionShorthandNormalizer(shorthand) {
  return (value) => {
    return {
      path: shorthand,
      value: getBoxSidesValues(value)
    };
  };
}
function getShorthandValues(string) {
  const matches = string.matchAll(CSS_SHORTHAND_VALUE_REGEXP);
  return Array.from(matches).map((i) => i[0]);
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/styles/background.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function addBackgroundRules(stylesProcessor) {
  stylesProcessor.setNormalizer("background", getBackgroundNormalizer());
  stylesProcessor.setNormalizer("background-color", getBackgroundColorNormalizer());
  stylesProcessor.setReducer("background", getBackgroundReducer());
  stylesProcessor.setStyleRelation("background", ["background-color"]);
}
function getBackgroundNormalizer() {
  return (value) => {
    const background = {};
    const parts = getShorthandValues(value);
    for (const part of parts) {
      if (isRepeat(part)) {
        background.repeat = background.repeat || [];
        background.repeat.push(part);
      } else if (isPosition(part)) {
        background.position = background.position || [];
        background.position.push(part);
      } else if (isAttachment(part)) {
        background.attachment = part;
      } else if (isColor(part)) {
        background.color = part;
      } else if (isURL(part)) {
        background.image = part;
      }
    }
    return {
      path: "background",
      value: background
    };
  };
}
function getBackgroundColorNormalizer() {
  return (value) => ({path: "background.color", value});
}
function getBackgroundReducer() {
  return (value) => {
    const ret = [];
    ret.push(["background-color", value.color]);
    return ret;
  };
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/styles/border.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function addBorderRules(stylesProcessor) {
  stylesProcessor.setNormalizer("border", getBorderNormalizer());
  stylesProcessor.setNormalizer("border-top", getBorderPositionNormalizer("top"));
  stylesProcessor.setNormalizer("border-right", getBorderPositionNormalizer("right"));
  stylesProcessor.setNormalizer("border-bottom", getBorderPositionNormalizer("bottom"));
  stylesProcessor.setNormalizer("border-left", getBorderPositionNormalizer("left"));
  stylesProcessor.setNormalizer("border-color", getBorderPropertyNormalizer("color"));
  stylesProcessor.setNormalizer("border-width", getBorderPropertyNormalizer("width"));
  stylesProcessor.setNormalizer("border-style", getBorderPropertyNormalizer("style"));
  stylesProcessor.setNormalizer("border-top-color", getBorderPropertyPositionNormalizer("color", "top"));
  stylesProcessor.setNormalizer("border-top-style", getBorderPropertyPositionNormalizer("style", "top"));
  stylesProcessor.setNormalizer("border-top-width", getBorderPropertyPositionNormalizer("width", "top"));
  stylesProcessor.setNormalizer("border-right-color", getBorderPropertyPositionNormalizer("color", "right"));
  stylesProcessor.setNormalizer("border-right-style", getBorderPropertyPositionNormalizer("style", "right"));
  stylesProcessor.setNormalizer("border-right-width", getBorderPropertyPositionNormalizer("width", "right"));
  stylesProcessor.setNormalizer("border-bottom-color", getBorderPropertyPositionNormalizer("color", "bottom"));
  stylesProcessor.setNormalizer("border-bottom-style", getBorderPropertyPositionNormalizer("style", "bottom"));
  stylesProcessor.setNormalizer("border-bottom-width", getBorderPropertyPositionNormalizer("width", "bottom"));
  stylesProcessor.setNormalizer("border-left-color", getBorderPropertyPositionNormalizer("color", "left"));
  stylesProcessor.setNormalizer("border-left-style", getBorderPropertyPositionNormalizer("style", "left"));
  stylesProcessor.setNormalizer("border-left-width", getBorderPropertyPositionNormalizer("width", "left"));
  stylesProcessor.setExtractor("border-top", getBorderPositionExtractor("top"));
  stylesProcessor.setExtractor("border-right", getBorderPositionExtractor("right"));
  stylesProcessor.setExtractor("border-bottom", getBorderPositionExtractor("bottom"));
  stylesProcessor.setExtractor("border-left", getBorderPositionExtractor("left"));
  stylesProcessor.setExtractor("border-top-color", "border.color.top");
  stylesProcessor.setExtractor("border-right-color", "border.color.right");
  stylesProcessor.setExtractor("border-bottom-color", "border.color.bottom");
  stylesProcessor.setExtractor("border-left-color", "border.color.left");
  stylesProcessor.setExtractor("border-top-width", "border.width.top");
  stylesProcessor.setExtractor("border-right-width", "border.width.right");
  stylesProcessor.setExtractor("border-bottom-width", "border.width.bottom");
  stylesProcessor.setExtractor("border-left-width", "border.width.left");
  stylesProcessor.setExtractor("border-top-style", "border.style.top");
  stylesProcessor.setExtractor("border-right-style", "border.style.right");
  stylesProcessor.setExtractor("border-bottom-style", "border.style.bottom");
  stylesProcessor.setExtractor("border-left-style", "border.style.left");
  stylesProcessor.setReducer("border-color", getBoxSidesValueReducer("border-color"));
  stylesProcessor.setReducer("border-style", getBoxSidesValueReducer("border-style"));
  stylesProcessor.setReducer("border-width", getBoxSidesValueReducer("border-width"));
  stylesProcessor.setReducer("border-top", getBorderPositionReducer("top"));
  stylesProcessor.setReducer("border-right", getBorderPositionReducer("right"));
  stylesProcessor.setReducer("border-bottom", getBorderPositionReducer("bottom"));
  stylesProcessor.setReducer("border-left", getBorderPositionReducer("left"));
  stylesProcessor.setReducer("border", getBorderReducer());
  stylesProcessor.setStyleRelation("border", [
    "border-color",
    "border-style",
    "border-width",
    "border-top",
    "border-right",
    "border-bottom",
    "border-left",
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color",
    "border-top-style",
    "border-right-style",
    "border-bottom-style",
    "border-left-style",
    "border-top-width",
    "border-right-width",
    "border-bottom-width",
    "border-left-width"
  ]);
  stylesProcessor.setStyleRelation("border-color", [
    "border-top-color",
    "border-right-color",
    "border-bottom-color",
    "border-left-color"
  ]);
  stylesProcessor.setStyleRelation("border-style", [
    "border-top-style",
    "border-right-style",
    "border-bottom-style",
    "border-left-style"
  ]);
  stylesProcessor.setStyleRelation("border-width", [
    "border-top-width",
    "border-right-width",
    "border-bottom-width",
    "border-left-width"
  ]);
  stylesProcessor.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]);
  stylesProcessor.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]);
  stylesProcessor.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]);
  stylesProcessor.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"]);
}
function getBorderNormalizer() {
  return (value) => {
    const {color, style, width} = normalizeBorderShorthand(value);
    return {
      path: "border",
      value: {
        color: getBoxSidesValues(color),
        style: getBoxSidesValues(style),
        width: getBoxSidesValues(width)
      }
    };
  };
}
function getBorderPositionNormalizer(side) {
  return (value) => {
    const {color, style, width} = normalizeBorderShorthand(value);
    const border = {};
    if (color !== void 0) {
      border.color = {[side]: color};
    }
    if (style !== void 0) {
      border.style = {[side]: style};
    }
    if (width !== void 0) {
      border.width = {[side]: width};
    }
    return {
      path: "border",
      value: border
    };
  };
}
function getBorderPropertyNormalizer(propertyName) {
  return (value) => {
    return {
      path: "border",
      value: toBorderPropertyShorthand(value, propertyName)
    };
  };
}
function toBorderPropertyShorthand(value, property) {
  return {
    [property]: getBoxSidesValues(value)
  };
}
function getBorderPropertyPositionNormalizer(property, side) {
  return (value) => {
    return {
      path: "border",
      value: {
        [property]: {
          [side]: value
        }
      }
    };
  };
}
function getBorderPositionExtractor(which) {
  return (name, styles) => {
    if (styles.border) {
      return extractBorderPosition(styles.border, which);
    }
  };
}
function extractBorderPosition(border, which) {
  const value = {};
  if (border.width && border.width[which]) {
    value.width = border.width[which];
  }
  if (border.style && border.style[which]) {
    value.style = border.style[which];
  }
  if (border.color && border.color[which]) {
    value.color = border.color[which];
  }
  return value;
}
function normalizeBorderShorthand(string) {
  const result = {};
  const parts = getShorthandValues(string);
  for (const part of parts) {
    if (isLength2(part) || /thin|medium|thick/.test(part)) {
      result.width = part;
    } else if (isLineStyle(part)) {
      result.style = part;
    } else {
      result.color = part;
    }
  }
  return result;
}
function getBorderReducer() {
  return (value) => {
    const topStyles = extractBorderPosition(value, "top");
    const rightStyles = extractBorderPosition(value, "right");
    const bottomStyles = extractBorderPosition(value, "bottom");
    const leftStyles = extractBorderPosition(value, "left");
    const borderStyles = [topStyles, rightStyles, bottomStyles, leftStyles];
    const borderStylesByType = {
      width: getReducedStyleValueForType(borderStyles, "width"),
      style: getReducedStyleValueForType(borderStyles, "style"),
      color: getReducedStyleValueForType(borderStyles, "color")
    };
    const reducedBorderStyle = reduceBorderPosition(borderStylesByType, "all");
    if (reducedBorderStyle.length) {
      return reducedBorderStyle;
    }
    const reducedStyleTypes = Object.entries(borderStylesByType).reduce((reducedStyleTypes2, [type, value2]) => {
      if (value2) {
        reducedStyleTypes2.push([`border-${type}`, value2]);
        borderStyles.forEach((style) => delete style[type]);
      }
      return reducedStyleTypes2;
    }, []);
    return [
      ...reducedStyleTypes,
      ...reduceBorderPosition(topStyles, "top"),
      ...reduceBorderPosition(rightStyles, "right"),
      ...reduceBorderPosition(bottomStyles, "bottom"),
      ...reduceBorderPosition(leftStyles, "left")
    ];
  };
  function getReducedStyleValueForType(styles, type) {
    return styles.map((style) => style[type]).reduce((result, style) => result == style ? result : null);
  }
}
function getBorderPositionReducer(which) {
  return (value) => reduceBorderPosition(value, which);
}
function reduceBorderPosition(value, which) {
  const borderTypes = [];
  if (value && value.width) {
    borderTypes.push("width");
  }
  if (value && value.style) {
    borderTypes.push("style");
  }
  if (value && value.color) {
    borderTypes.push("color");
  }
  if (borderTypes.length == 3) {
    const borderValue = borderTypes.map((item) => value[item]).join(" ");
    return [
      which == "all" ? ["border", borderValue] : [`border-${which}`, borderValue]
    ];
  }
  if (which == "all") {
    return [];
  }
  return borderTypes.map((type) => {
    return [`border-${which}-${type}`, value[type]];
  });
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/styles/margin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function addMarginRules(stylesProcessor) {
  stylesProcessor.setNormalizer("margin", getPositionShorthandNormalizer("margin"));
  stylesProcessor.setNormalizer("margin-top", (value) => ({path: "margin.top", value}));
  stylesProcessor.setNormalizer("margin-right", (value) => ({path: "margin.right", value}));
  stylesProcessor.setNormalizer("margin-bottom", (value) => ({path: "margin.bottom", value}));
  stylesProcessor.setNormalizer("margin-left", (value) => ({path: "margin.left", value}));
  stylesProcessor.setReducer("margin", getBoxSidesValueReducer("margin"));
  stylesProcessor.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
}

// node_modules/@ckeditor/ckeditor5-engine/src/view/styles/padding.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function addPaddingRules(stylesProcessor) {
  stylesProcessor.setNormalizer("padding", getPositionShorthandNormalizer("padding"));
  stylesProcessor.setNormalizer("padding-top", (value) => ({path: "padding.top", value}));
  stylesProcessor.setNormalizer("padding-right", (value) => ({path: "padding.right", value}));
  stylesProcessor.setNormalizer("padding-bottom", (value) => ({path: "padding.bottom", value}));
  stylesProcessor.setNormalizer("padding-left", (value) => ({path: "padding.left", value}));
  stylesProcessor.setReducer("padding", getBoxSidesValueReducer("padding"));
  stylesProcessor.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"]);
}

// node_modules/@ckeditor/ckeditor5-engine/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-core/src/commandcollection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var CommandCollection = class {
  constructor() {
    this._commands = new Map();
  }
  add(commandName, command) {
    this._commands.set(commandName, command);
  }
  get(commandName) {
    return this._commands.get(commandName);
  }
  execute(commandName, ...commandParams) {
    const command = this.get(commandName);
    if (!command) {
      throw new ckeditorerror_default("commandcollection-command-not-found", this, {commandName});
    }
    return command.execute(...commandParams);
  }
  *names() {
    yield* this._commands.keys();
  }
  *commands() {
    yield* this._commands.values();
  }
  [Symbol.iterator]() {
    return this._commands[Symbol.iterator]();
  }
  destroy() {
    for (const command of this.commands()) {
      command.destroy();
    }
  }
};
var commandcollection_default = CommandCollection;

// node_modules/@ckeditor/ckeditor5-core/src/editingkeystrokehandler.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EditingKeystrokeHandler = class extends keystrokehandler_default {
  constructor(editor) {
    super();
    this.editor = editor;
  }
  set(keystroke, callback, options = {}) {
    if (typeof callback == "string") {
      const commandName = callback;
      callback = (evtData, cancel) => {
        this.editor.execute(commandName);
        cancel();
      };
    }
    super.set(keystroke, callback, options);
  }
};
var editingkeystrokehandler_default = EditingKeystrokeHandler;

// node_modules/@ckeditor/ckeditor5-core/src/editor/editor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Editor = class extends ObservableMixin() {
  constructor(config = {}) {
    super();
    const constructor = this.constructor;
    const language = config.language || constructor.defaultConfig && constructor.defaultConfig.language;
    this._context = config.context || new context_default({language});
    this._context._addEditor(this, !config.context);
    const availablePlugins = Array.from(constructor.builtinPlugins || []);
    this.config = new config_default(config, constructor.defaultConfig);
    this.config.define("plugins", availablePlugins);
    this.config.define(this._context._getEditorConfig());
    this.plugins = new plugincollection_default(this, availablePlugins, this._context.plugins);
    this.locale = this._context.locale;
    this.t = this.locale.t;
    this._readOnlyLocks = new Set();
    this.commands = new commandcollection_default();
    this.set("state", "initializing");
    this.once("ready", () => this.state = "ready", {priority: "high"});
    this.once("destroy", () => this.state = "destroyed", {priority: "high"});
    this.model = new model_default();
    this.on("change:isReadOnly", () => {
      this.model.document.isReadOnly = this.isReadOnly;
    });
    const stylesProcessor = new StylesProcessor();
    this.data = new datacontroller_default(this.model, stylesProcessor);
    this.editing = new editingcontroller_default(this.model, stylesProcessor);
    this.editing.view.document.bind("isReadOnly").to(this);
    this.conversion = new conversion_default([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
    this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
    this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
    this.keystrokes = new editingkeystrokehandler_default(this);
    this.keystrokes.listenTo(this.editing.view.document);
  }
  get isReadOnly() {
    return this._readOnlyLocks.size > 0;
  }
  set isReadOnly(value) {
    throw new ckeditorerror_default("editor-isreadonly-has-no-setter");
  }
  enableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new ckeditorerror_default("editor-read-only-lock-id-invalid", null, {lockId});
    }
    if (this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.add(lockId);
    if (this._readOnlyLocks.size === 1) {
      this.fire("change:isReadOnly", "isReadOnly", true, false);
    }
  }
  disableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new ckeditorerror_default("editor-read-only-lock-id-invalid", null, {lockId});
    }
    if (!this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.delete(lockId);
    if (this._readOnlyLocks.size === 0) {
      this.fire("change:isReadOnly", "isReadOnly", false, true);
    }
  }
  initPlugins() {
    const config = this.config;
    const plugins = config.get("plugins");
    const removePlugins = config.get("removePlugins") || [];
    const extraPlugins = config.get("extraPlugins") || [];
    const substitutePlugins = config.get("substitutePlugins") || [];
    return this.plugins.init(plugins.concat(extraPlugins), removePlugins, substitutePlugins);
  }
  destroy() {
    let readyPromise = Promise.resolve();
    if (this.state == "initializing") {
      readyPromise = new Promise((resolve) => this.once("ready", resolve));
    }
    return readyPromise.then(() => {
      this.fire("destroy");
      this.stopListening();
      this.commands.destroy();
    }).then(() => this.plugins.destroy()).then(() => {
      this.model.destroy();
      this.data.destroy();
      this.editing.destroy();
      this.keystrokes.destroy();
    }).then(() => this._context._removeEditor(this));
  }
  execute(commandName, ...commandParams) {
    try {
      return this.commands.execute(commandName, ...commandParams);
    } catch (err) {
      /* istanbul ignore next -- @preserve */
      ckeditorerror_default.rethrowUnexpectedError(err, this);
    }
  }
  focus() {
    this.editing.view.focus();
  }
  static create(...args) {
    throw new Error("This is an abstract method.");
  }
};
var editor_default = Editor;

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/attachtoform.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function attachToForm(editor) {
  if (!isFunction_default(editor.updateSourceElement)) {
    throw new ckeditorerror_default("attachtoform-missing-elementapi-interface", editor);
  }
  const sourceElement = editor.sourceElement;
  if (isTextArea(sourceElement) && sourceElement.form) {
    let originalSubmit;
    const form = sourceElement.form;
    const onSubmit = () => editor.updateSourceElement();
    if (isFunction_default(form.submit)) {
      originalSubmit = form.submit;
      form.submit = () => {
        onSubmit();
        originalSubmit.apply(form);
      };
    }
    form.addEventListener("submit", onSubmit);
    editor.on("destroy", () => {
      form.removeEventListener("submit", onSubmit);
      if (originalSubmit) {
        form.submit = originalSubmit;
      }
    });
  }
}
function isTextArea(sourceElement) {
  return !!sourceElement && sourceElement.tagName.toLowerCase() === "textarea";
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function DataApiMixin(base) {
  class Mixin extends base {
    setData(data) {
      this.data.set(data);
    }
    getData(options) {
      return this.data.get(options);
    }
  }
  return Mixin;
}
{
  const mixin = DataApiMixin(Object);
  DataApiMixin.setData = mixin.prototype.setData;
  DataApiMixin.getData = mixin.prototype.getData;
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function ElementApiMixin(base) {
  class Mixin extends base {
    updateSourceElement(data = this.data.get()) {
      if (!this.sourceElement) {
        throw new ckeditorerror_default("editor-missing-sourceelement", this);
      }
      const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
      const isSourceElementTextArea = this.sourceElement instanceof HTMLTextAreaElement;
      if (!shouldUpdateSourceElement && !isSourceElementTextArea) {
        setDataInElement(this.sourceElement, "");
        return;
      }
      setDataInElement(this.sourceElement, data);
    }
  }
  return Mixin;
}
ElementApiMixin.updateSourceElement = ElementApiMixin(Object).prototype.updateSourceElement;

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/securesourceelement.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function secureSourceElement(editor, sourceElement) {
  if (sourceElement.ckeditorInstance) {
    throw new ckeditorerror_default("editor-source-element-already-used", editor);
  }
  sourceElement.ckeditorInstance = editor;
  editor.once("destroy", () => {
    delete sourceElement.ckeditorInstance;
  });
}

// node_modules/@ckeditor/ckeditor5-core/src/pendingactions.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var PendingActions = class extends contextplugin_default {
  static get pluginName() {
    return "PendingActions";
  }
  init() {
    this.set("hasAny", false);
    this._actions = new collection_default({idProperty: "_id"});
    this._actions.delegate("add", "remove").to(this);
  }
  add(message) {
    if (typeof message !== "string") {
      throw new ckeditorerror_default("pendingactions-add-invalid-message", this);
    }
    const action = new (ObservableMixin())();
    action.set("message", message);
    this._actions.add(action);
    this.hasAny = true;
    return action;
  }
  remove(action) {
    this._actions.remove(action);
    this.hasAny = !!this._actions.length;
  }
  get first() {
    return this._actions.get(0);
  }
  [Symbol.iterator]() {
    return this._actions[Symbol.iterator]();
  }
};
var pendingactions_default = PendingActions;

// node_modules/@ckeditor/ckeditor5-core/theme/icons/cancel.svg
var cancel_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/caption.svg
var caption_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/check.svg
var check_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/cog.svg
var cog_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/eraser.svg
var eraser_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/history.svg
var history_default2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/low-vision.svg
var low_vision_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/loupe.svg
var loupe_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/image.svg
var image_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/align-bottom.svg
var align_bottom_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/align-middle.svg
var align_middle_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/align-top.svg
var align_top_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/align-left.svg
var align_left_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/align-center.svg
var align_center_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/align-right.svg
var align_right_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/align-justify.svg
var align_justify_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-left.svg
var object_left_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-center.svg
var object_center_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-right.svg
var object_right_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-full-width.svg
var object_full_width_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline.svg
var object_inline_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline-left.svg
var object_inline_left_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline-right.svg
var object_inline_right_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-full.svg
var object_size_full_default = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-large.svg
var object_size_large_default = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-small.svg
var object_size_small_default = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-medium.svg
var object_size_medium_default = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/pencil.svg
var pencil_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/pilcrow.svg
var pilcrow_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/quote.svg
var quote_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/three-vertical-dots.svg
var three_vertical_dots_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/drag-indicator.svg
var drag_indicator_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/bold.svg
var bold_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/paragraph.svg
var paragraph_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/plus.svg
var plus_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/text.svg
var text_default3 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/theme/icons/importexport.svg
var importexport_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>';

// node_modules/@ckeditor/ckeditor5-core/src/augmentation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-core/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var icons = {
  bold: bold_default,
  cancel: cancel_default,
  caption: caption_default,
  check: check_default,
  cog: cog_default,
  eraser: eraser_default,
  history: history_default2,
  image: image_default,
  lowVision: low_vision_default,
  loupe: loupe_default,
  importExport: importexport_default,
  paragraph: paragraph_default,
  plus: plus_default,
  text: text_default3,
  alignBottom: align_bottom_default,
  alignMiddle: align_middle_default,
  alignTop: align_top_default,
  alignLeft: align_left_default,
  alignCenter: align_center_default,
  alignRight: align_right_default,
  alignJustify: align_justify_default,
  objectLeft: object_inline_left_default,
  objectCenter: object_center_default,
  objectRight: object_inline_right_default,
  objectFullWidth: object_full_width_default,
  objectInline: object_inline_default,
  objectBlockLeft: object_left_default,
  objectBlockRight: object_right_default,
  objectSizeFull: object_size_full_default,
  objectSizeLarge: object_size_large_default,
  objectSizeSmall: object_size_small_default,
  objectSizeMedium: object_size_medium_default,
  pencil: pencil_default,
  pilcrow: pilcrow_default,
  quote: quote_default,
  threeVerticalDots: three_vertical_dots_default,
  dragIndicator: drag_indicator_default
};

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function clickOutsideHandler({emitter, activator, callback, contextElements}) {
  emitter.listenTo(document, "mousedown", (evt, domEvt) => {
    if (!activator()) {
      return;
    }
    const path = typeof domEvt.composedPath == "function" ? domEvt.composedPath() : [];
    const contextElementsList = typeof contextElements == "function" ? contextElements() : contextElements;
    for (const contextElement of contextElementsList) {
      if (contextElement.contains(domEvt.target) || path.includes(contextElement)) {
        return;
      }
    }
    callback();
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/injectcsstransitiondisabler.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function injectCssTransitionDisabler(view) {
  const decorated = view;
  decorated.set("_isCssTransitionsDisabled", false);
  decorated.disableCssTransitions = () => {
    decorated._isCssTransitionsDisabled = true;
  };
  decorated.enableCssTransitions = () => {
    decorated._isCssTransitionsDisabled = false;
  };
  decorated.extendTemplate({
    attributes: {
      class: [
        decorated.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
      ]
    }
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/csstransitiondisablermixin.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function CssTransitionDisablerMixin(view) {
  class Mixin extends view {
    disableCssTransitions() {
      this._isCssTransitionsDisabled = true;
    }
    enableCssTransitions() {
      this._isCssTransitionsDisabled = false;
    }
    constructor(...args) {
      super(...args);
      this.set("_isCssTransitionsDisabled", false);
      this.initializeCssTransitionDisablerMixin();
    }
    initializeCssTransitionDisablerMixin() {
      this.extendTemplate({
        attributes: {
          class: [
            this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
          ]
        }
      });
    }
  }
  return Mixin;
}

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/submithandler.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function submitHandler({view}) {
  view.listenTo(view.element, "submit", (evt, domEvt) => {
    domEvt.preventDefault();
    view.fire("submit");
  }, {useCapture: true});
}

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/addkeyboardhandlingforgrid.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function addKeyboardHandlingForGrid({keystrokeHandler, focusTracker, gridItems, numberOfColumns, uiLanguageDirection}) {
  const getNumberOfColumns = typeof numberOfColumns === "number" ? () => numberOfColumns : numberOfColumns;
  keystrokeHandler.set("arrowright", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    return uiLanguageDirection === "rtl" ? getLeftElementIndex(focusedElementIndex, gridItems2.length) : getRightElementIndex(focusedElementIndex, gridItems2.length);
  }));
  keystrokeHandler.set("arrowleft", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    return uiLanguageDirection === "rtl" ? getRightElementIndex(focusedElementIndex, gridItems2.length) : getLeftElementIndex(focusedElementIndex, gridItems2.length);
  }));
  keystrokeHandler.set("arrowup", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    let nextIndex = focusedElementIndex - getNumberOfColumns();
    if (nextIndex < 0) {
      nextIndex = focusedElementIndex + getNumberOfColumns() * Math.floor(gridItems2.length / getNumberOfColumns());
      if (nextIndex > gridItems2.length - 1) {
        nextIndex -= getNumberOfColumns();
      }
    }
    return nextIndex;
  }));
  keystrokeHandler.set("arrowdown", getGridItemFocuser((focusedElementIndex, gridItems2) => {
    let nextIndex = focusedElementIndex + getNumberOfColumns();
    if (nextIndex > gridItems2.length - 1) {
      nextIndex = focusedElementIndex % getNumberOfColumns();
    }
    return nextIndex;
  }));
  function getGridItemFocuser(getIndexToFocus) {
    return (evt) => {
      const focusedElement = gridItems.find((item) => item.element === focusTracker.focusedElement);
      const focusedElementIndex = gridItems.getIndex(focusedElement);
      const nextIndexToFocus = getIndexToFocus(focusedElementIndex, gridItems);
      gridItems.get(nextIndexToFocus).focus();
      evt.stopPropagation();
      evt.preventDefault();
    };
  }
  function getRightElementIndex(elementIndex, collectionLength) {
    if (elementIndex === collectionLength - 1) {
      return 0;
    } else {
      return elementIndex + 1;
    }
  }
  function getLeftElementIndex(elementIndex, collectionLength) {
    if (elementIndex === 0) {
      return collectionLength - 1;
    } else {
      return elementIndex - 1;
    }
  }
}

// node_modules/@ckeditor/ckeditor5-ui/src/viewcollection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ViewCollection = class extends collection_default {
  constructor(initialItems = []) {
    super(initialItems, {
      idProperty: "viewUid"
    });
    this.on("add", (evt, view, index) => {
      this._renderViewIntoCollectionParent(view, index);
    });
    this.on("remove", (evt, view) => {
      if (view.element && this._parentElement) {
        view.element.remove();
      }
    });
    this._parentElement = null;
  }
  destroy() {
    this.map((view) => view.destroy());
  }
  setParent(elementOrDocFragment) {
    this._parentElement = elementOrDocFragment;
    for (const view of this) {
      this._renderViewIntoCollectionParent(view);
    }
  }
  delegate(...events) {
    if (!events.length || !isStringArray2(events)) {
      throw new ckeditorerror_default("ui-viewcollection-delegate-wrong-events", this);
    }
    return {
      to: (dest) => {
        for (const view of this) {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        }
        this.on("add", (evt, view) => {
          for (const evtName of events) {
            view.delegate(evtName).to(dest);
          }
        });
        this.on("remove", (evt, view) => {
          for (const evtName of events) {
            view.stopDelegating(evtName, dest);
          }
        });
      }
    };
  }
  _renderViewIntoCollectionParent(view, index) {
    if (!view.isRendered) {
      view.render();
    }
    if (view.element && this._parentElement) {
      this._parentElement.insertBefore(view.element, this._parentElement.children[index]);
    }
  }
  remove(subject) {
    return super.remove(subject);
  }
};
var viewcollection_default = ViewCollection;
function isStringArray2(arr) {
  return arr.every((a) => typeof a == "string");
}

// node_modules/@ckeditor/ckeditor5-ui/src/view.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var View2 = class extends DomEmitterMixin(ObservableMixin()) {
  constructor(locale) {
    super();
    this.element = null;
    this.isRendered = false;
    this.locale = locale;
    this.t = locale && locale.t;
    this._viewCollections = new collection_default();
    this._unboundChildren = this.createCollection();
    this._viewCollections.on("add", (evt, collection) => {
      collection.locale = locale;
      collection.t = locale && locale.t;
    });
    this.decorate("render");
  }
  get bindTemplate() {
    if (this._bindTemplate) {
      return this._bindTemplate;
    }
    return this._bindTemplate = template_default.bind(this, this);
  }
  createCollection(views) {
    const collection = new viewcollection_default(views);
    this._viewCollections.add(collection);
    return collection;
  }
  registerChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.add(child);
    }
  }
  deregisterChild(children) {
    if (!isIterable(children)) {
      children = [children];
    }
    for (const child of children) {
      this._unboundChildren.remove(child);
    }
  }
  setTemplate(definition) {
    this.template = new template_default(definition);
  }
  extendTemplate(definition) {
    template_default.extend(this.template, definition);
  }
  render() {
    if (this.isRendered) {
      throw new ckeditorerror_default("ui-view-render-already-rendered", this);
    }
    if (this.template) {
      this.element = this.template.render();
      this.registerChild(this.template.getViews());
    }
    this.isRendered = true;
  }
  destroy() {
    this.stopListening();
    this._viewCollections.map((c) => c.destroy());
    if (this.template && this.template._revertData) {
      this.template.revert(this.element);
    }
  }
};
var view_default2 = View2;

// node_modules/@ckeditor/ckeditor5-ui/src/template.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var xhtmlNs = "http://www.w3.org/1999/xhtml";
var Template = class extends EmitterMixin() {
  constructor(def) {
    super();
    Object.assign(this, normalize5(clone2(def)));
    this._isRendered = false;
    this._revertData = null;
  }
  render() {
    const node = this._renderNode({
      intoFragment: true
    });
    this._isRendered = true;
    return node;
  }
  apply(node) {
    this._revertData = getEmptyRevertData();
    this._renderNode({
      node,
      intoFragment: false,
      isApplying: true,
      revertData: this._revertData
    });
    return node;
  }
  revert(node) {
    if (!this._revertData) {
      throw new ckeditorerror_default("ui-template-revert-not-applied", [this, node]);
    }
    this._revertTemplateFromNode(node, this._revertData);
  }
  *getViews() {
    function* search(def) {
      if (def.children) {
        for (const child of def.children) {
          if (isView(child)) {
            yield child;
          } else if (isTemplate(child)) {
            yield* search(child);
          }
        }
      }
    }
    yield* search(this);
  }
  static bind(observable, emitter) {
    return {
      to(eventNameOrFunctionOrAttribute, callback) {
        return new TemplateToBinding({
          eventNameOrFunction: eventNameOrFunctionOrAttribute,
          attribute: eventNameOrFunctionOrAttribute,
          observable,
          emitter,
          callback
        });
      },
      if(attribute, valueIfTrue, callback) {
        return new TemplateIfBinding({
          observable,
          emitter,
          attribute,
          valueIfTrue,
          callback
        });
      }
    };
  }
  static extend(template, def) {
    if (template._isRendered) {
      throw new ckeditorerror_default("template-extend-render", [this, template]);
    }
    extendTemplate(template, normalize5(clone2(def)));
  }
  _renderNode(data) {
    let isInvalid;
    if (data.node) {
      isInvalid = this.tag && this.text;
    } else {
      isInvalid = this.tag ? this.text : !this.text;
    }
    if (isInvalid) {
      throw new ckeditorerror_default("ui-template-wrong-syntax", this);
    }
    if (this.text) {
      return this._renderText(data);
    } else {
      return this._renderElement(data);
    }
  }
  _renderElement(data) {
    let node = data.node;
    if (!node) {
      node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
    }
    this._renderAttributes(data);
    this._renderElementChildren(data);
    this._setUpListeners(data);
    return node;
  }
  _renderText(data) {
    let node = data.node;
    if (node) {
      data.revertData.text = node.textContent;
    } else {
      node = data.node = document.createTextNode("");
    }
    if (hasTemplateBinding(this.text)) {
      this._bindToObservable({
        schema: this.text,
        updater: getTextUpdater(node),
        data
      });
    } else {
      node.textContent = this.text.join("");
    }
    return node;
  }
  _renderAttributes(data) {
    if (!this.attributes) {
      return;
    }
    const node = data.node;
    const revertData = data.revertData;
    for (const attrName in this.attributes) {
      const domAttrValue = node.getAttribute(attrName);
      const attrValue = this.attributes[attrName];
      if (revertData) {
        revertData.attributes[attrName] = domAttrValue;
      }
      const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
      if (hasTemplateBinding(attrValue)) {
        const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
        if (revertData && shouldExtend(attrName)) {
          valueToBind.unshift(domAttrValue);
        }
        this._bindToObservable({
          schema: valueToBind,
          updater: getAttributeUpdater(node, attrName, attrNs),
          data
        });
      } else if (attrName == "style" && typeof attrValue[0] !== "string") {
        this._renderStyleAttribute(attrValue[0], data);
      } else {
        if (revertData && domAttrValue && shouldExtend(attrName)) {
          attrValue.unshift(domAttrValue);
        }
        const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
        if (!isFalsy(value)) {
          node.setAttributeNS(attrNs, attrName, value);
        }
      }
    }
  }
  _renderStyleAttribute(styles, data) {
    const node = data.node;
    for (const styleName in styles) {
      const styleValue = styles[styleName];
      if (hasTemplateBinding(styleValue)) {
        this._bindToObservable({
          schema: [styleValue],
          updater: getStyleUpdater(node, styleName),
          data
        });
      } else {
        node.style[styleName] = styleValue;
      }
    }
  }
  _renderElementChildren(data) {
    const node = data.node;
    const container = data.intoFragment ? document.createDocumentFragment() : node;
    const isApplying = data.isApplying;
    let childIndex = 0;
    for (const child of this.children) {
      if (isViewCollection(child)) {
        if (!isApplying) {
          child.setParent(node);
          for (const view of child) {
            container.appendChild(view.element);
          }
        }
      } else if (isView(child)) {
        if (!isApplying) {
          if (!child.isRendered) {
            child.render();
          }
          container.appendChild(child.element);
        }
      } else if (isNode(child)) {
        container.appendChild(child);
      } else {
        if (isApplying) {
          const revertData = data.revertData;
          const childRevertData = getEmptyRevertData();
          revertData.children.push(childRevertData);
          child._renderNode({
            intoFragment: false,
            node: container.childNodes[childIndex++],
            isApplying: true,
            revertData: childRevertData
          });
        } else {
          container.appendChild(child.render());
        }
      }
    }
    if (data.intoFragment) {
      node.appendChild(container);
    }
  }
  _setUpListeners(data) {
    if (!this.eventListeners) {
      return;
    }
    for (const key in this.eventListeners) {
      const revertBindings = this.eventListeners[key].map((schemaItem) => {
        const [domEvtName, domSelector] = key.split("@");
        return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
      });
      if (data.revertData) {
        data.revertData.bindings.push(revertBindings);
      }
    }
  }
  _bindToObservable({schema, updater, data}) {
    const revertData = data.revertData;
    syncValueSchemaValue(schema, updater, data);
    const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
    if (revertData) {
      revertData.bindings.push(revertBindings);
    }
  }
  _revertTemplateFromNode(node, revertData) {
    for (const binding of revertData.bindings) {
      for (const revertBinding of binding) {
        revertBinding();
      }
    }
    if (revertData.text) {
      node.textContent = revertData.text;
      return;
    }
    const element = node;
    for (const attrName in revertData.attributes) {
      const attrValue = revertData.attributes[attrName];
      if (attrValue === null) {
        element.removeAttribute(attrName);
      } else {
        element.setAttribute(attrName, attrValue);
      }
    }
    for (let i = 0; i < revertData.children.length; ++i) {
      this._revertTemplateFromNode(element.childNodes[i], revertData.children[i]);
    }
  }
};
var template_default = Template;
var TemplateBinding = class {
  constructor(def) {
    this.attribute = def.attribute;
    this.observable = def.observable;
    this.emitter = def.emitter;
    this.callback = def.callback;
  }
  getValue(node) {
    const value = this.observable[this.attribute];
    return this.callback ? this.callback(value, node) : value;
  }
  activateAttributeListener(schema, updater, data) {
    const callback = () => syncValueSchemaValue(schema, updater, data);
    this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
    return () => {
      this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
    };
  }
};
var TemplateToBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.eventNameOrFunction = def.eventNameOrFunction;
  }
  activateDomEventListener(domEvtName, domSelector, data) {
    const callback = (evt, domEvt) => {
      if (!domSelector || domEvt.target.matches(domSelector)) {
        if (typeof this.eventNameOrFunction == "function") {
          this.eventNameOrFunction(domEvt);
        } else {
          this.observable.fire(this.eventNameOrFunction, domEvt);
        }
      }
    };
    this.emitter.listenTo(data.node, domEvtName, callback);
    return () => {
      this.emitter.stopListening(data.node, domEvtName, callback);
    };
  }
};
var TemplateIfBinding = class extends TemplateBinding {
  constructor(def) {
    super(def);
    this.valueIfTrue = def.valueIfTrue;
  }
  getValue(node) {
    const value = super.getValue(node);
    return isFalsy(value) ? false : this.valueIfTrue || true;
  }
};
function hasTemplateBinding(schema) {
  if (!schema) {
    return false;
  }
  if (schema.value) {
    schema = schema.value;
  }
  if (Array.isArray(schema)) {
    return schema.some(hasTemplateBinding);
  } else if (schema instanceof TemplateBinding) {
    return true;
  }
  return false;
}
function getValueSchemaValue(schema, node) {
  return schema.map((schemaItem) => {
    if (schemaItem instanceof TemplateBinding) {
      return schemaItem.getValue(node);
    }
    return schemaItem;
  });
}
function syncValueSchemaValue(schema, updater, {node}) {
  const values = getValueSchemaValue(schema, node);
  let value;
  if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
    value = values[0];
  } else {
    value = values.reduce(arrayValueReducer, "");
  }
  if (isFalsy(value)) {
    updater.remove();
  } else {
    updater.set(value);
  }
}
function getTextUpdater(node) {
  return {
    set(value) {
      node.textContent = value;
    },
    remove() {
      node.textContent = "";
    }
  };
}
function getAttributeUpdater(el, attrName, ns) {
  return {
    set(value) {
      el.setAttributeNS(ns, attrName, value);
    },
    remove() {
      el.removeAttributeNS(ns, attrName);
    }
  };
}
function getStyleUpdater(el, styleName) {
  return {
    set(value) {
      el.style[styleName] = value;
    },
    remove() {
      el.style[styleName] = null;
    }
  };
}
function clone2(def) {
  const clone3 = cloneDeepWith_default(def, (value) => {
    if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
      return value;
    }
  });
  return clone3;
}
function normalize5(def) {
  if (typeof def == "string") {
    def = normalizePlainTextDefinition(def);
  } else if (def.text) {
    normalizeTextDefinition(def);
  }
  if (def.on) {
    def.eventListeners = normalizeListeners(def.on);
    delete def.on;
  }
  if (!def.text) {
    if (def.attributes) {
      normalizeAttributes(def.attributes);
    }
    const children = [];
    if (def.children) {
      if (isViewCollection(def.children)) {
        children.push(def.children);
      } else {
        for (const child of def.children) {
          if (isTemplate(child) || isView(child) || isNode(child)) {
            children.push(child);
          } else {
            children.push(new Template(child));
          }
        }
      }
    }
    def.children = children;
  }
  return def;
}
function normalizeAttributes(attributes) {
  for (const a in attributes) {
    if (attributes[a].value) {
      attributes[a].value = toArray(attributes[a].value);
    }
    arrayify(attributes, a);
  }
}
function normalizeListeners(listeners) {
  for (const l in listeners) {
    arrayify(listeners, l);
  }
  return listeners;
}
function normalizePlainTextDefinition(def) {
  return {
    text: [def]
  };
}
function normalizeTextDefinition(def) {
  def.text = toArray(def.text);
}
function arrayify(obj, key) {
  obj[key] = toArray(obj[key]);
}
function arrayValueReducer(prev, cur) {
  if (isFalsy(cur)) {
    return prev;
  } else if (isFalsy(prev)) {
    return cur;
  } else {
    return `${prev} ${cur}`;
  }
}
function extendObjectValueArray(obj, ext) {
  for (const a in ext) {
    if (obj[a]) {
      obj[a].push(...ext[a]);
    } else {
      obj[a] = ext[a];
    }
  }
}
function extendTemplate(template, def) {
  if (def.attributes) {
    if (!template.attributes) {
      template.attributes = {};
    }
    extendObjectValueArray(template.attributes, def.attributes);
  }
  if (def.eventListeners) {
    if (!template.eventListeners) {
      template.eventListeners = {};
    }
    extendObjectValueArray(template.eventListeners, def.eventListeners);
  }
  if (def.text) {
    template.text.push(...def.text);
  }
  if (def.children && def.children.length) {
    if (template.children.length != def.children.length) {
      throw new ckeditorerror_default("ui-template-extend-children-mismatch", template);
    }
    let childIndex = 0;
    for (const childDef of def.children) {
      extendTemplate(template.children[childIndex++], childDef);
    }
  }
}
function isFalsy(value) {
  return !value && value !== 0;
}
function isView(item) {
  return item instanceof view_default2;
}
function isTemplate(item) {
  return item instanceof Template;
}
function isViewCollection(item) {
  return item instanceof viewcollection_default;
}
function isNamespaced(attrValue) {
  return isObject_default(attrValue[0]) && attrValue[0].ns;
}
function getEmptyRevertData() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
}
function shouldExtend(attrName) {
  return attrName == "class" || attrName == "style";
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/bodycollection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BodyCollection = class extends viewcollection_default {
  constructor(locale, initialItems = []) {
    super(initialItems);
    this.locale = locale;
  }
  get bodyCollectionContainer() {
    return this._bodyCollectionContainer;
  }
  attachToDom() {
    this._bodyCollectionContainer = new template_default({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset_all",
          "ck-body",
          "ck-rounded-corners"
        ],
        dir: this.locale.uiLanguageDirection
      },
      children: this
    }).render();
    let wrapper = document.querySelector(".ck-body-wrapper");
    if (!wrapper) {
      wrapper = createElement(document, "div", {class: "ck-body-wrapper"});
      document.body.appendChild(wrapper);
    }
    wrapper.appendChild(this._bodyCollectionContainer);
  }
  detachFromDom() {
    super.destroy();
    if (this._bodyCollectionContainer) {
      this._bodyCollectionContainer.remove();
    }
    const wrapper = document.querySelector(".ck-body-wrapper");
    if (wrapper && wrapper.childElementCount == 0) {
      wrapper.remove();
    }
  }
};
var bodycollection_default = BodyCollection;

// node_modules/@ckeditor/ckeditor5-ui/src/icon/iconview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var IconView = class extends view_default2 {
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set("content", "");
    this.set("viewBox", "0 0 20 20");
    this.set("fillColor", "");
    this.set("isColorInherited", true);
    this.set("isVisible", true);
    this.setTemplate({
      tag: "svg",
      ns: "http://www.w3.org/2000/svg",
      attributes: {
        class: [
          "ck",
          "ck-icon",
          bind.if("isVisible", "ck-hidden", (value) => !value),
          "ck-reset_all-excluded",
          bind.if("isColorInherited", "ck-icon_inherit-color")
        ],
        viewBox: bind.to("viewBox")
      }
    });
  }
  render() {
    super.render();
    this._updateXMLContent();
    this._colorFillPaths();
    this.on("change:content", () => {
      this._updateXMLContent();
      this._colorFillPaths();
    });
    this.on("change:fillColor", () => {
      this._colorFillPaths();
    });
  }
  _updateXMLContent() {
    if (this.content) {
      const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
      const svg = parsed.querySelector("svg");
      const viewBox = svg.getAttribute("viewBox");
      if (viewBox) {
        this.viewBox = viewBox;
      }
      for (const {name, value} of Array.from(svg.attributes)) {
        if (IconView.presentationalAttributeNames.includes(name)) {
          this.element.setAttribute(name, value);
        }
      }
      while (this.element.firstChild) {
        this.element.removeChild(this.element.firstChild);
      }
      while (svg.childNodes.length > 0) {
        this.element.appendChild(svg.childNodes[0]);
      }
    }
  }
  _colorFillPaths() {
    if (this.fillColor) {
      this.element.querySelectorAll(".ck-icon__fill").forEach((path) => {
        path.style.fill = this.fillColor;
      });
    }
  }
};
var iconview_default = IconView;
IconView.presentationalAttributeNames = [
  "alignment-baseline",
  "baseline-shift",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-rendering",
  "cursor",
  "direction",
  "display",
  "dominant-baseline",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "mask",
  "opacity",
  "overflow",
  "paint-order",
  "pointer-events",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-overflow",
  "text-rendering",
  "transform",
  "unicode-bidi",
  "vector-effect",
  "visibility",
  "white-space",
  "word-spacing",
  "writing-mode"
];

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonlabelview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ButtonLabelView = class extends view_default2 {
  constructor() {
    super();
    this.set({
      style: void 0,
      text: void 0,
      id: void 0
    });
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__label"
        ],
        style: bind.to("style"),
        id: bind.to("id")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};
var buttonlabelview_default = ButtonLabelView;

// node_modules/@ckeditor/ckeditor5-ui/src/button/buttonview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ButtonView = class extends view_default2 {
  constructor(locale, labelView = new buttonlabelview_default()) {
    super(locale);
    this._focusDelayed = null;
    const bind = this.bindTemplate;
    const ariaLabelUid = uid();
    this.set("ariaChecked", void 0);
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isVisible", true);
    this.set("isToggleable", false);
    this.set("keystroke", void 0);
    this.set("label", void 0);
    this.set("role", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.set("withKeystroke", false);
    this.children = this.createCollection();
    this.labelView = this._setupLabelView(labelView);
    this.iconView = new iconview_default();
    this.iconView.extendTemplate({
      attributes: {
        class: "ck-button__icon"
      }
    });
    this.keystrokeView = this._createKeystrokeView();
    this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
    const template = {
      tag: "button",
      attributes: {
        class: [
          "ck",
          "ck-button",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          bind.to("isOn", (value) => value ? "ck-on" : "ck-off"),
          bind.if("withText", "ck-button_with-text"),
          bind.if("withKeystroke", "ck-button_with-keystroke")
        ],
        role: bind.to("role"),
        type: bind.to("type", (value) => value ? value : "button"),
        tabindex: bind.to("tabindex"),
        "aria-label": bind.to("ariaLabel"),
        "aria-labelledby": bind.to("ariaLabelledBy"),
        "aria-disabled": bind.if("isEnabled", true, (value) => !value),
        "aria-checked": bind.to("isOn"),
        "aria-pressed": bind.to("isOn", (value) => this.isToggleable ? String(!!value) : false),
        "data-cke-tooltip-text": bind.to("_tooltipString"),
        "data-cke-tooltip-position": bind.to("tooltipPosition")
      },
      children: this.children,
      on: {
        click: bind.to((evt) => {
          if (this.isEnabled) {
            this.fire("execute");
          } else {
            evt.preventDefault();
          }
        })
      }
    };
    if (env_default.isSafari) {
      if (!this._focusDelayed) {
        this._focusDelayed = delay(() => this.focus(), 0);
      }
      template.on.mousedown = bind.to(() => {
        this._focusDelayed();
      });
      template.on.mouseup = bind.to(() => {
        this._focusDelayed.cancel();
      });
    }
    this.setTemplate(template);
  }
  render() {
    super.render();
    if (this.icon) {
      this.iconView.bind("content").to(this, "icon");
      this.children.add(this.iconView);
    }
    this.children.add(this.labelView);
    if (this.withKeystroke && this.keystroke) {
      this.children.add(this.keystrokeView);
    }
  }
  focus() {
    this.element.focus();
  }
  destroy() {
    if (this._focusDelayed) {
      this._focusDelayed.cancel();
    }
    super.destroy();
  }
  _setupLabelView(labelView) {
    labelView.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
    return labelView;
  }
  _createKeystrokeView() {
    const keystrokeView = new view_default2();
    keystrokeView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__keystroke"
        ]
      },
      children: [
        {
          text: this.bindTemplate.to("keystroke", (text) => getEnvKeystrokeText(text))
        }
      ]
    });
    return keystrokeView;
  }
  _getTooltipString(tooltip, label, keystroke) {
    if (tooltip) {
      if (typeof tooltip == "string") {
        return tooltip;
      } else {
        if (keystroke) {
          keystroke = getEnvKeystrokeText(keystroke);
        }
        if (tooltip instanceof Function) {
          return tooltip(label, keystroke);
        } else {
          return `${label}${keystroke ? ` (${keystroke})` : ""}`;
        }
      }
    }
    return "";
  }
};
var buttonview_default = ButtonView;

// node_modules/@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SwitchButtonView = class extends buttonview_default {
  constructor(locale) {
    super(locale);
    this.isToggleable = true;
    this.toggleSwitchView = this._createToggleView();
    this.extendTemplate({
      attributes: {
        class: "ck-switchbutton"
      }
    });
  }
  render() {
    super.render();
    this.children.add(this.toggleSwitchView);
  }
  _createToggleView() {
    const toggleSwitchView = new view_default2();
    toggleSwitchView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-button__toggle"
        ]
      },
      children: [
        {
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle__inner"
            ]
          }
        }
      ]
    });
    return toggleSwitchView;
  }
};
var switchbuttonview_default = SwitchButtonView;

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/utils.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getLocalizedColorOptions(locale, options) {
  const t = locale.t;
  const localizedColorNames = {
    Black: t("Black"),
    "Dim grey": t("Dim grey"),
    Grey: t("Grey"),
    "Light grey": t("Light grey"),
    White: t("White"),
    Red: t("Red"),
    Orange: t("Orange"),
    Yellow: t("Yellow"),
    "Light green": t("Light green"),
    Green: t("Green"),
    Aquamarine: t("Aquamarine"),
    Turquoise: t("Turquoise"),
    "Light blue": t("Light blue"),
    Blue: t("Blue"),
    Purple: t("Purple")
  };
  return options.map((colorOption) => {
    const label = localizedColorNames[colorOption.label];
    if (label && label != colorOption.label) {
      colorOption.label = label;
    }
    return colorOption;
  });
}
function normalizeColorOptions(options) {
  return options.map(normalizeSingleColorDefinition).filter((option) => !!option);
}
function normalizeSingleColorDefinition(color) {
  if (typeof color === "string") {
    return {
      model: color,
      label: color,
      hasBorder: false,
      view: {
        name: "span",
        styles: {
          color
        }
      }
    };
  } else {
    return {
      model: color.color,
      label: color.label || color.color,
      hasBorder: color.hasBorder === void 0 ? false : color.hasBorder,
      view: {
        name: "span",
        styles: {
          color: `${color.color}`
        }
      }
    };
  }
}

// node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-tile-check.svg
var color_tile_check_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ColorTileView = class extends buttonview_default {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("color", void 0);
    this.set("hasBorder", false);
    this.icon = color_tile_check_default;
    this.extendTemplate({
      attributes: {
        style: {
          backgroundColor: bind.to("color")
        },
        class: [
          "ck",
          "ck-color-grid__tile",
          bind.if("hasBorder", "ck-color-selector__color-tile_bordered")
        ]
      }
    });
  }
  render() {
    super.render();
    this.iconView.fillColor = "hsl(0, 0%, 100%)";
  }
};
var colortileview_default = ColorTileView;

// node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ColorGridView = class extends view_default2 {
  constructor(locale, options) {
    super(locale);
    const colorDefinitions = options && options.colorDefinitions ? options.colorDefinitions : [];
    this.columns = options && options.columns ? options.columns : 5;
    const viewStyleAttribute = {
      gridTemplateColumns: `repeat( ${this.columns}, 1fr)`
    };
    this.set("selectedColor", void 0);
    this.items = this.createCollection();
    this.focusTracker = new focustracker_default();
    this.keystrokes = new keystrokehandler_default();
    this.items.on("add", (evt, colorTile) => {
      colorTile.isOn = colorTile.color === this.selectedColor;
    });
    colorDefinitions.forEach((color) => {
      const colorTile = new colortileview_default();
      colorTile.set({
        color: color.color,
        label: color.label,
        tooltip: true,
        hasBorder: color.options.hasBorder
      });
      colorTile.on("execute", () => {
        this.fire("execute", {
          value: color.color,
          hasBorder: color.options.hasBorder,
          label: color.label
        });
      });
      this.items.add(colorTile);
    });
    this.setTemplate({
      tag: "div",
      children: this.items,
      attributes: {
        class: [
          "ck",
          "ck-color-grid"
        ],
        style: viewStyleAttribute
      }
    });
    this.on("change:selectedColor", (evt, name, selectedColor) => {
      for (const item of this.items) {
        item.isOn = item.color === selectedColor;
      }
    });
  }
  focus() {
    if (this.items.length) {
      this.items.first.focus();
    }
  }
  focusLast() {
    if (this.items.length) {
      this.items.last.focus();
    }
  }
  render() {
    super.render();
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item.element);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item.element);
    });
    this.keystrokes.listenTo(this.element);
    addKeyboardHandlingForGrid({
      keystrokeHandler: this.keystrokes,
      focusTracker: this.focusTracker,
      gridItems: this.items,
      numberOfColumns: this.columns,
      uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
    });
  }
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
};
var colorgridview_default = ColorGridView;

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/utils.js
var import_color_parse = __toModule(require_color_parse());
var convert = __toModule(require_color_convert());
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function convertColor(color, outputFormat) {
  if (!color) {
    return "";
  }
  const colorObject = parseColorString(color);
  if (!colorObject) {
    return "";
  }
  if (colorObject.space === outputFormat) {
    return color;
  }
  if (!canConvertParsedColor(colorObject)) {
    return "";
  }
  const fromColorSpace = convert[colorObject.space];
  const toColorSpace = fromColorSpace[outputFormat];
  if (!toColorSpace) {
    return "";
  }
  const convertedColorChannels = toColorSpace(colorObject.space === "hex" ? colorObject.hexValue : colorObject.values);
  return formatColorOutput(convertedColorChannels, outputFormat);
}
function convertToHex(color) {
  if (!color) {
    return "";
  }
  const colorObject = parseColorString(color);
  if (!colorObject) {
    return "#000";
  }
  if (colorObject.space === "hex") {
    return colorObject.hexValue;
  }
  return convertColor(color, "hex");
}
function formatColorOutput(values, format2) {
  switch (format2) {
    case "hex":
      return `#${values}`;
    case "rgb":
      return `rgb( ${values[0]}, ${values[1]}, ${values[2]} )`;
    case "hsl":
      return `hsl( ${values[0]}, ${values[1]}%, ${values[2]}% )`;
    case "hwb":
      return `hwb( ${values[0]}, ${values[1]}, ${values[2]} )`;
    case "lab":
      return `lab( ${values[0]}% ${values[1]} ${values[2]} )`;
    case "lch":
      return `lch( ${values[0]}% ${values[1]} ${values[2]} )`;
    default:
      return "";
  }
}
function parseColorString(colorString) {
  if (colorString.startsWith("#")) {
    const parsedHex = (0, import_color_parse.default)(colorString);
    return {
      space: "hex",
      values: parsedHex.values,
      hexValue: colorString,
      alpha: parsedHex.alpha
    };
  }
  const parsed = (0, import_color_parse.default)(colorString);
  if (!parsed.space) {
    return null;
  }
  return parsed;
}
function canConvertParsedColor(parsedColor) {
  return Object.keys(convert).includes(parsedColor.space);
}

// node_modules/@ckeditor/ckeditor5-ui/src/label/labelview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var LabelView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.set("text", void 0);
    this.set("for", void 0);
    this.id = `ck-editor__label_${uid()}`;
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "label",
      attributes: {
        class: [
          "ck",
          "ck-label"
        ],
        id: this.id,
        for: bind.to("for")
      },
      children: [
        {
          text: bind.to("text")
        }
      ]
    });
  }
};
var labelview_default = LabelView;

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var LabeledFieldView = class extends view_default2 {
  constructor(locale, viewCreator) {
    super(locale);
    const viewUid = `ck-labeled-field-view-${uid()}`;
    const statusUid = `ck-labeled-field-view-status-${uid()}`;
    this.fieldView = viewCreator(this, viewUid, statusUid);
    this.set("label", void 0);
    this.set("isEnabled", true);
    this.set("isEmpty", true);
    this.set("isFocused", false);
    this.set("errorText", null);
    this.set("infoText", null);
    this.set("class", void 0);
    this.set("placeholder", void 0);
    this.labelView = this._createLabelView(viewUid);
    this.statusView = this._createStatusView(statusUid);
    this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]);
    this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value),
          bind.if("isEmpty", "ck-labeled-field-view_empty"),
          bind.if("isFocused", "ck-labeled-field-view_focused"),
          bind.if("placeholder", "ck-labeled-field-view_placeholder"),
          bind.if("errorText", "ck-error")
        ]
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__input-wrapper"
            ]
          },
          children: this.fieldWrapperChildren
        },
        this.statusView
      ]
    });
  }
  _createLabelView(id) {
    const labelView = new labelview_default(this.locale);
    labelView.for = id;
    labelView.bind("text").to(this, "label");
    return labelView;
  }
  _createStatusView(statusUid) {
    const statusView = new view_default2(this.locale);
    const bind = this.bindTemplate;
    statusView.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-labeled-field-view__status",
          bind.if("errorText", "ck-labeled-field-view__status_error"),
          bind.if("_statusText", "ck-hidden", (value) => !value)
        ],
        id: statusUid,
        role: bind.if("errorText", "alert")
      },
      children: [
        {
          text: bind.to("_statusText")
        }
      ]
    });
    return statusView;
  }
  focus(direction) {
    this.fieldView.focus(direction);
  }
};
var labeledfieldview_default = LabeledFieldView;

// node_modules/@ckeditor/ckeditor5-ui/src/input/inputbase.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InputBase = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.set("value", void 0);
    this.set("id", void 0);
    this.set("placeholder", void 0);
    this.set("isReadOnly", false);
    this.set("hasError", false);
    this.set("ariaDescribedById", void 0);
    this.focusTracker = new focustracker_default();
    this.bind("isFocused").to(this.focusTracker);
    this.set("isEmpty", true);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "input",
      attributes: {
        class: [
          "ck",
          "ck-input",
          bind.if("isFocused", "ck-input_focused"),
          bind.if("isEmpty", "ck-input-text_empty"),
          bind.if("hasError", "ck-error")
        ],
        id: bind.to("id"),
        placeholder: bind.to("placeholder"),
        readonly: bind.to("isReadOnly"),
        "aria-invalid": bind.if("hasError", true),
        "aria-describedby": bind.to("ariaDescribedById")
      },
      on: {
        input: bind.to((...args) => {
          this.fire("input", ...args);
          this._updateIsEmpty();
        }),
        change: bind.to(this._updateIsEmpty.bind(this))
      }
    });
  }
  render() {
    super.render();
    this.focusTracker.add(this.element);
    this._setDomElementValue(this.value);
    this._updateIsEmpty();
    this.on("change:value", (evt, name, value) => {
      this._setDomElementValue(value);
      this._updateIsEmpty();
    });
  }
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  select() {
    this.element.select();
  }
  focus() {
    this.element.focus();
  }
  reset() {
    this.value = this.element.value = "";
    this._updateIsEmpty();
  }
  _updateIsEmpty() {
    this.isEmpty = isInputElementEmpty(this.element);
  }
  _setDomElementValue(value) {
    this.element.value = !value && value !== 0 ? "" : value;
  }
};
var inputbase_default = InputBase;
function isInputElementEmpty(domElement) {
  return !domElement.value;
}

// node_modules/@ckeditor/ckeditor5-ui/src/input/inputview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InputView = class extends inputbase_default {
  constructor(locale) {
    super(locale);
    this.set("inputMode", "text");
    const bind = this.bindTemplate;
    this.extendTemplate({
      attributes: {
        inputmode: bind.to("inputMode")
      }
    });
  }
};
var inputview_default = InputView;

// node_modules/@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InputTextView = class extends inputview_default {
  constructor(locale) {
    super(locale);
    this.extendTemplate({
      attributes: {
        type: "text",
        class: [
          "ck-input-text"
        ]
      }
    });
  }
};
var inputtextview_default = InputTextView;

// node_modules/@ckeditor/ckeditor5-ui/src/inputnumber/inputnumberview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InputNumberView = class extends inputview_default {
  constructor(locale, {min, max, step} = {}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("min", min);
    this.set("max", max);
    this.set("step", step);
    this.extendTemplate({
      attributes: {
        type: "number",
        class: [
          "ck-input-number"
        ],
        min: bind.to("min"),
        max: bind.to("max"),
        step: bind.to("step")
      }
    });
  }
};
var inputnumberview_default = InputNumberView;

// node_modules/@ckeditor/ckeditor5-ui/src/textarea/textareaview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var TextareaView = class extends inputbase_default {
  constructor(locale) {
    super(locale);
    const toPx8 = toUnit("px");
    this.set("minRows", 2);
    this.set("maxRows", 5);
    this.set("_height", null);
    this.set("resize", "none");
    this.on("change:minRows", this._validateMinMaxRows.bind(this));
    this.on("change:maxRows", this._validateMinMaxRows.bind(this));
    const bind = this.bindTemplate;
    this.template.tag = "textarea";
    this.extendTemplate({
      attributes: {
        class: ["ck-textarea"],
        style: {
          height: bind.to("_height", (height) => height ? toPx8(height) : null),
          resize: bind.to("resize")
        },
        rows: bind.to("minRows")
      }
    });
  }
  render() {
    super.render();
    this.on("input", () => {
      this._updateAutoGrowHeight(true);
      this.fire("update");
    });
    this.on("change:value", () => {
      global_default.window.requestAnimationFrame(() => {
        this._updateAutoGrowHeight();
        this.fire("update");
      });
    });
  }
  reset() {
    super.reset();
    this._updateAutoGrowHeight();
    this.fire("update");
  }
  _updateAutoGrowHeight(shouldScroll) {
    const viewElement = this.element;
    const singleLineContentClone = getTextareaElementClone(viewElement, "1");
    const fullTextValueClone = getTextareaElementClone(viewElement, viewElement.value);
    const singleLineContentStyles = singleLineContentClone.ownerDocument.defaultView.getComputedStyle(singleLineContentClone);
    const verticalPaddings = parseFloat(singleLineContentStyles.paddingTop) + parseFloat(singleLineContentStyles.paddingBottom);
    const borders = getBorderWidths(singleLineContentClone);
    const lineHeight = parseFloat(singleLineContentStyles.lineHeight);
    const verticalBorder = borders.top + borders.bottom;
    const singleLineAreaDefaultHeight = new rect_default(singleLineContentClone).height;
    const numberOfLines = Math.round((fullTextValueClone.scrollHeight - verticalPaddings) / lineHeight);
    const maxHeight = this.maxRows * lineHeight + verticalPaddings + verticalBorder;
    const minHeight = numberOfLines === 1 ? singleLineAreaDefaultHeight : this.minRows * lineHeight + verticalPaddings + verticalBorder;
    this._height = Math.min(Math.max(Math.max(numberOfLines, this.minRows) * lineHeight + verticalPaddings + verticalBorder, minHeight), maxHeight);
    if (shouldScroll) {
      viewElement.scrollTop = viewElement.scrollHeight;
    }
    singleLineContentClone.remove();
    fullTextValueClone.remove();
  }
  _validateMinMaxRows() {
    if (this.minRows > this.maxRows) {
      throw new ckeditorerror_default("ui-textarea-view-min-rows-greater-than-max-rows", {
        textareaView: this,
        minRows: this.minRows,
        maxRows: this.maxRows
      });
    }
  }
};
var textareaview_default = TextareaView;
function getTextareaElementClone(element, value) {
  const clone3 = element.cloneNode();
  clone3.style.position = "absolute";
  clone3.style.top = "-99999px";
  clone3.style.left = "-99999px";
  clone3.style.height = "auto";
  clone3.style.overflow = "hidden";
  clone3.style.width = element.ownerDocument.defaultView.getComputedStyle(element).width;
  clone3.tabIndex = -1;
  clone3.rows = 1;
  clone3.value = value;
  element.parentNode.insertBefore(clone3, element);
  return clone3;
}

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DropdownPanelView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", false);
    this.set("position", "se");
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-dropdown__panel",
          bind.to("position", (value) => `ck-dropdown__panel_${value}`),
          bind.if("isVisible", "ck-dropdown__panel-visible")
        ],
        tabindex: "-1"
      },
      children: this.children,
      on: {
        selectstart: bind.to((evt) => {
          if (evt.target.tagName.toLocaleLowerCase() === "input") {
            return;
          }
          evt.preventDefault();
        })
      }
    });
  }
  focus() {
    if (this.children.length) {
      const firstChild = this.children.first;
      if (typeof firstChild.focus === "function") {
        firstChild.focus();
      } else {
        logWarning("ui-dropdown-panel-focus-child-missing-focus", {childView: this.children.first, dropdownPanel: this});
      }
    }
  }
  focusLast() {
    if (this.children.length) {
      const lastChild = this.children.last;
      if (typeof lastChild.focusLast === "function") {
        lastChild.focusLast();
      } else {
        lastChild.focus();
      }
    }
  }
};
var dropdownpanelview_default = DropdownPanelView;

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DropdownView = class extends view_default2 {
  constructor(locale, buttonView, panelView) {
    super(locale);
    const bind = this.bindTemplate;
    this.buttonView = buttonView;
    this.panelView = panelView;
    this.set("isOpen", false);
    this.set("isEnabled", true);
    this.set("class", void 0);
    this.set("id", void 0);
    this.set("panelPosition", "auto");
    this.keystrokes = new keystrokehandler_default();
    this.focusTracker = new focustracker_default();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-dropdown",
          bind.to("class"),
          bind.if("isEnabled", "ck-disabled", (value) => !value)
        ],
        id: bind.to("id"),
        "aria-describedby": bind.to("ariaDescribedById")
      },
      children: [
        buttonView,
        panelView
      ]
    });
    buttonView.extendTemplate({
      attributes: {
        class: [
          "ck-dropdown__button"
        ],
        "data-cke-tooltip-disabled": bind.to("isOpen")
      }
    });
  }
  render() {
    super.render();
    this.focusTracker.add(this.buttonView.element);
    this.focusTracker.add(this.panelView.element);
    this.listenTo(this.buttonView, "open", () => {
      this.isOpen = !this.isOpen;
    });
    this.panelView.bind("isVisible").to(this, "isOpen");
    this.on("change:isOpen", (evt, name, isOpen) => {
      if (!isOpen) {
        return;
      }
      if (this.panelPosition === "auto") {
        const optimalPanelPosition = DropdownView._getOptimalPosition({
          element: this.panelView.element,
          target: this.buttonView.element,
          fitInViewport: true,
          positions: this._panelPositions
        });
        this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._panelPositions[0].name;
      } else {
        this.panelView.position = this.panelPosition;
      }
    });
    this.keystrokes.listenTo(this.element);
    const closeDropdown = (data, cancel) => {
      if (this.isOpen) {
        this.isOpen = false;
        cancel();
      }
    };
    this.keystrokes.set("arrowdown", (data, cancel) => {
      if (this.buttonView.isEnabled && !this.isOpen) {
        this.isOpen = true;
        cancel();
      }
    });
    this.keystrokes.set("arrowright", (data, cancel) => {
      if (this.isOpen) {
        cancel();
      }
    });
    this.keystrokes.set("arrowleft", closeDropdown);
    this.keystrokes.set("esc", closeDropdown);
  }
  focus() {
    this.buttonView.focus();
  }
  get _panelPositions() {
    const {south, north, southEast, southWest, northEast, northWest, southMiddleEast, southMiddleWest, northMiddleEast, northMiddleWest} = DropdownView.defaultPanelPositions;
    if (this.locale.uiLanguageDirection !== "rtl") {
      return [
        southEast,
        southWest,
        southMiddleEast,
        southMiddleWest,
        south,
        northEast,
        northWest,
        northMiddleEast,
        northMiddleWest,
        north
      ];
    } else {
      return [
        southWest,
        southEast,
        southMiddleWest,
        southMiddleEast,
        south,
        northWest,
        northEast,
        northMiddleWest,
        northMiddleEast,
        north
      ];
    }
  }
};
var dropdownview_default = DropdownView;
DropdownView.defaultPanelPositions = {
  south: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "s"
    };
  },
  southEast: (buttonRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: "se"
    };
  },
  southWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "sw"
    };
  },
  southMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "sme"
    };
  },
  southMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "smw"
    };
  },
  north: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
      name: "n"
    };
  },
  northEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: "ne"
    };
  },
  northWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: "nw"
    };
  },
  northMiddleEast: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
      name: "nme"
    };
  },
  northMiddleWest: (buttonRect, panelRect) => {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
      name: "nmw"
    };
  }
};
DropdownView._getOptimalPosition = getOptimalPosition;

// node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg
var dropdown_arrow_default = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DropdownButtonView = class extends buttonview_default {
  constructor(locale) {
    super(locale);
    this.arrowView = this._createArrowView();
    this.extendTemplate({
      attributes: {
        "aria-haspopup": true,
        "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value))
      }
    });
    this.delegate("execute").to(this, "open");
  }
  render() {
    super.render();
    this.children.add(this.arrowView);
  }
  _createArrowView() {
    const arrowView = new iconview_default();
    arrowView.content = dropdown_arrow_default;
    arrowView.extendTemplate({
      attributes: {
        class: "ck-dropdown__arrow"
      }
    });
    return arrowView;
  }
};
var dropdownbuttonview_default = DropdownButtonView;

// node_modules/@ckeditor/ckeditor5-ui/src/focuscycler.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var FocusCycler = class extends EmitterMixin() {
  constructor(options) {
    super();
    this.focusables = options.focusables;
    this.focusTracker = options.focusTracker;
    this.keystrokeHandler = options.keystrokeHandler;
    this.actions = options.actions;
    if (options.actions && options.keystrokeHandler) {
      for (const methodName in options.actions) {
        let actions = options.actions[methodName];
        if (typeof actions == "string") {
          actions = [actions];
        }
        for (const keystroke of actions) {
          options.keystrokeHandler.set(keystroke, (data, cancel) => {
            this[methodName]();
            cancel();
          });
        }
      }
    }
    this.on("forwardCycle", () => this.focusFirst(), {priority: "low"});
    this.on("backwardCycle", () => this.focusLast(), {priority: "low"});
  }
  get first() {
    return this.focusables.find(isFocusable) || null;
  }
  get last() {
    return this.focusables.filter(isFocusable).slice(-1)[0] || null;
  }
  get next() {
    return this._getFocusableItem(1);
  }
  get previous() {
    return this._getFocusableItem(-1);
  }
  get current() {
    let index = null;
    if (this.focusTracker.focusedElement === null) {
      return null;
    }
    this.focusables.find((view, viewIndex) => {
      const focused = view.element === this.focusTracker.focusedElement;
      if (focused) {
        index = viewIndex;
      }
      return focused;
    });
    return index;
  }
  focusFirst() {
    this._focus(this.first, 1);
  }
  focusLast() {
    this._focus(this.last, -1);
  }
  focusNext() {
    const next = this.next;
    if (next && this.focusables.getIndex(next) === this.current) {
      return;
    }
    if (next === this.first) {
      this.fire("forwardCycle");
    } else {
      this._focus(next, 1);
    }
  }
  focusPrevious() {
    const previous = this.previous;
    if (previous && this.focusables.getIndex(previous) === this.current) {
      return;
    }
    if (previous === this.last) {
      this.fire("backwardCycle");
    } else {
      this._focus(previous, -1);
    }
  }
  _focus(view, direction) {
    if (view) {
      view.focus(direction);
    }
  }
  _getFocusableItem(step) {
    const current = this.current;
    const collectionLength = this.focusables.length;
    if (!collectionLength) {
      return null;
    }
    if (current === null) {
      return this[step === 1 ? "first" : "last"];
    }
    let index = (current + collectionLength + step) % collectionLength;
    do {
      const view = this.focusables.get(index);
      if (isFocusable(view)) {
        return view;
      }
      index = (index + collectionLength + step) % collectionLength;
    } while (index !== current);
    return null;
  }
};
var focuscycler_default = FocusCycler;
function isFocusable(view) {
  return !!("focus" in view && isVisible(view.element));
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ToolbarSeparatorView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__separator"
        ]
      }
    });
  }
};
var toolbarseparatorview_default = ToolbarSeparatorView;

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarlinebreakview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ToolbarLineBreakView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__line-break"
        ]
      }
    });
  }
};
var toolbarlinebreakview_default = ToolbarLineBreakView;

// node_modules/@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function preventDefault(view) {
  return view.bindTemplate.to((evt) => {
    if (evt.target === view.element) {
      evt.preventDefault();
    }
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function normalizeToolbarConfig(config) {
  if (Array.isArray(config)) {
    return {
      items: config,
      removeItems: []
    };
  }
  if (!config) {
    return {
      items: [],
      removeItems: []
    };
  }
  return Object.assign({
    items: [],
    removeItems: []
  }, config);
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var {threeVerticalDots} = icons;
var NESTED_TOOLBAR_ICONS = {
  alignLeft: icons.alignLeft,
  bold: icons.bold,
  importExport: icons.importExport,
  paragraph: icons.paragraph,
  plus: icons.plus,
  text: icons.text,
  threeVerticalDots: icons.threeVerticalDots,
  pilcrow: icons.pilcrow,
  dragIndicator: icons.dragIndicator
};
var ToolbarView = class extends view_default2 {
  constructor(locale, options) {
    super(locale);
    const bind = this.bindTemplate;
    const t = this.t;
    this.options = options || {};
    this.set("ariaLabel", t("Editor toolbar"));
    this.set("maxWidth", "auto");
    this.items = this.createCollection();
    this.focusTracker = new focustracker_default();
    this.keystrokes = new keystrokehandler_default();
    this.set("class", void 0);
    this.set("isCompact", false);
    this.itemsView = new ItemsView(locale);
    this.children = this.createCollection();
    this.children.add(this.itemsView);
    this.focusables = this.createCollection();
    const isRtl = locale.uiLanguageDirection === "rtl";
    this._focusCycler = new focuscycler_default({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: [isRtl ? "arrowright" : "arrowleft", "arrowup"],
        focusNext: [isRtl ? "arrowleft" : "arrowright", "arrowdown"]
      }
    });
    const classes = [
      "ck",
      "ck-toolbar",
      bind.to("class"),
      bind.if("isCompact", "ck-toolbar_compact")
    ];
    if (this.options.shouldGroupWhenFull && this.options.isFloating) {
      classes.push("ck-toolbar_floating");
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: classes,
        role: "toolbar",
        "aria-label": bind.to("ariaLabel"),
        style: {
          maxWidth: bind.to("maxWidth")
        },
        tabindex: -1
      },
      children: this.children,
      on: {
        mousedown: preventDefault(this)
      }
    });
    this._behavior = this.options.shouldGroupWhenFull ? new DynamicGrouping(this) : new StaticLayout(this);
  }
  render() {
    super.render();
    this.focusTracker.add(this.element);
    for (const item of this.items) {
      this.focusTracker.add(item.element);
    }
    this.items.on("add", (evt, item) => {
      this.focusTracker.add(item.element);
    });
    this.items.on("remove", (evt, item) => {
      this.focusTracker.remove(item.element);
    });
    this.keystrokes.listenTo(this.element);
    this._behavior.render(this);
  }
  destroy() {
    this._behavior.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
    return super.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
  fillFromConfig(itemsOrConfig, factory, removeItems) {
    this.items.addMany(this._buildItemsFromConfig(itemsOrConfig, factory, removeItems));
  }
  _buildItemsFromConfig(itemsOrConfig, factory, removeItems) {
    const config = normalizeToolbarConfig(itemsOrConfig);
    const normalizedRemoveItems = removeItems || config.removeItems;
    const itemsToAdd = this._cleanItemsConfiguration(config.items, factory, normalizedRemoveItems).map((item) => {
      if (isObject_default(item)) {
        return this._createNestedToolbarDropdown(item, factory, normalizedRemoveItems);
      } else if (item === "|") {
        return new toolbarseparatorview_default();
      } else if (item === "-") {
        return new toolbarlinebreakview_default();
      }
      return factory.create(item);
    }).filter((item) => !!item);
    return itemsToAdd;
  }
  _cleanItemsConfiguration(items, factory, removeItems) {
    const filteredItems = items.filter((item, idx, items2) => {
      if (item === "|") {
        return true;
      }
      if (removeItems.indexOf(item) !== -1) {
        return false;
      }
      if (item === "-") {
        if (this.options.shouldGroupWhenFull) {
          logWarning("toolbarview-line-break-ignored-when-grouping-items", items2);
          return false;
        }
        return true;
      }
      if (!isObject_default(item) && !factory.has(item)) {
        logWarning("toolbarview-item-unavailable", {item});
        return false;
      }
      return true;
    });
    return this._cleanSeparatorsAndLineBreaks(filteredItems);
  }
  _cleanSeparatorsAndLineBreaks(items) {
    const nonSeparatorPredicate = (item) => item !== "-" && item !== "|";
    const count2 = items.length;
    const firstCommandItemIndex = items.findIndex(nonSeparatorPredicate);
    if (firstCommandItemIndex === -1) {
      return [];
    }
    const lastCommandItemIndex = count2 - items.slice().reverse().findIndex(nonSeparatorPredicate);
    return items.slice(firstCommandItemIndex, lastCommandItemIndex).filter((name, idx, items2) => {
      if (nonSeparatorPredicate(name)) {
        return true;
      }
      const isDuplicated = idx > 0 && items2[idx - 1] === name;
      return !isDuplicated;
    });
  }
  _createNestedToolbarDropdown(definition, componentFactory, removeItems) {
    let {label, icon, items, tooltip = true, withText = false} = definition;
    items = this._cleanItemsConfiguration(items, componentFactory, removeItems);
    if (!items.length) {
      return null;
    }
    const locale = this.locale;
    const dropdownView = createDropdown(locale);
    if (!label) {
      logWarning("toolbarview-nested-toolbar-dropdown-missing-label", definition);
    }
    dropdownView.class = "ck-toolbar__nested-toolbar-dropdown";
    dropdownView.buttonView.set({
      label,
      tooltip,
      withText: !!withText
    });
    if (icon !== false) {
      dropdownView.buttonView.icon = NESTED_TOOLBAR_ICONS[icon] || icon || threeVerticalDots;
    } else {
      dropdownView.buttonView.withText = true;
    }
    addToolbarToDropdown(dropdownView, () => dropdownView.toolbarView._buildItemsFromConfig(items, componentFactory, removeItems));
    return dropdownView;
  }
};
var toolbarview_default = ToolbarView;
var ItemsView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-toolbar__items"
        ]
      },
      children: this.children
    });
  }
};
var StaticLayout = class {
  constructor(view) {
    const bind = view.bindTemplate;
    view.set("isVertical", false);
    view.itemsView.children.bindTo(view.items).using((item) => item);
    view.focusables.bindTo(view.items).using((item) => item);
    view.extendTemplate({
      attributes: {
        class: [
          bind.if("isVertical", "ck-toolbar_vertical")
        ]
      }
    });
  }
  render() {
  }
  destroy() {
  }
};
var DynamicGrouping = class {
  constructor(view) {
    this.resizeObserver = null;
    this.cachedPadding = null;
    this.shouldUpdateGroupingOnNextResize = false;
    this.view = view;
    this.viewChildren = view.children;
    this.viewFocusables = view.focusables;
    this.viewItemsView = view.itemsView;
    this.viewFocusTracker = view.focusTracker;
    this.viewLocale = view.locale;
    this.ungroupedItems = view.createCollection();
    this.groupedItems = view.createCollection();
    this.groupedItemsDropdown = this._createGroupedItemsDropdown();
    view.itemsView.children.bindTo(this.ungroupedItems).using((item) => item);
    this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this));
    view.children.on("change", this._updateFocusCycleableItems.bind(this));
    view.items.on("change", (evt, changeData) => {
      const index = changeData.index;
      const added = Array.from(changeData.added);
      for (const removedItem of changeData.removed) {
        if (index >= this.ungroupedItems.length) {
          this.groupedItems.remove(removedItem);
        } else {
          this.ungroupedItems.remove(removedItem);
        }
      }
      for (let currentIndex = index; currentIndex < index + added.length; currentIndex++) {
        const addedItem = added[currentIndex - index];
        if (currentIndex > this.ungroupedItems.length) {
          this.groupedItems.add(addedItem, currentIndex - this.ungroupedItems.length);
        } else {
          this.ungroupedItems.add(addedItem, currentIndex);
        }
      }
      this._updateGrouping();
    });
    view.extendTemplate({
      attributes: {
        class: [
          "ck-toolbar_grouping"
        ]
      }
    });
  }
  render(view) {
    this.viewElement = view.element;
    this._enableGroupingOnResize();
    this._enableGroupingOnMaxWidthChange(view);
  }
  destroy() {
    this.groupedItemsDropdown.destroy();
    this.resizeObserver.destroy();
  }
  _updateGrouping() {
    if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
      return;
    }
    if (!isVisible(this.viewElement)) {
      this.shouldUpdateGroupingOnNextResize = true;
      return;
    }
    const initialGroupedItemsCount = this.groupedItems.length;
    let wereItemsGrouped;
    while (this._areItemsOverflowing) {
      this._groupLastItem();
      wereItemsGrouped = true;
    }
    if (!wereItemsGrouped && this.groupedItems.length) {
      while (this.groupedItems.length && !this._areItemsOverflowing) {
        this._ungroupFirstItem();
      }
      if (this._areItemsOverflowing) {
        this._groupLastItem();
      }
    }
    if (this.groupedItems.length !== initialGroupedItemsCount) {
      this.view.fire("groupedItemsUpdate");
    }
  }
  get _areItemsOverflowing() {
    if (!this.ungroupedItems.length) {
      return false;
    }
    const element = this.viewElement;
    const uiLanguageDirection = this.viewLocale.uiLanguageDirection;
    const lastChildRect = new rect_default(element.lastChild);
    const toolbarRect = new rect_default(element);
    if (!this.cachedPadding) {
      const computedStyle = global_default.window.getComputedStyle(element);
      const paddingProperty = uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
      this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);
    }
    if (uiLanguageDirection === "ltr") {
      return lastChildRect.right > toolbarRect.right - this.cachedPadding;
    } else {
      return lastChildRect.left < toolbarRect.left + this.cachedPadding;
    }
  }
  _enableGroupingOnResize() {
    let previousWidth;
    this.resizeObserver = new resizeobserver_default(this.viewElement, (entry) => {
      if (!previousWidth || previousWidth !== entry.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
        this.shouldUpdateGroupingOnNextResize = false;
        this._updateGrouping();
        previousWidth = entry.contentRect.width;
      }
    });
    this._updateGrouping();
  }
  _enableGroupingOnMaxWidthChange(view) {
    view.on("change:maxWidth", () => {
      this._updateGrouping();
    });
  }
  _groupLastItem() {
    if (!this.groupedItems.length) {
      this.viewChildren.add(new toolbarseparatorview_default());
      this.viewChildren.add(this.groupedItemsDropdown);
      this.viewFocusTracker.add(this.groupedItemsDropdown.element);
    }
    this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
  }
  _ungroupFirstItem() {
    this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
    if (!this.groupedItems.length) {
      this.viewChildren.remove(this.groupedItemsDropdown);
      this.viewChildren.remove(this.viewChildren.last);
      this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
    }
  }
  _createGroupedItemsDropdown() {
    const locale = this.viewLocale;
    const t = locale.t;
    const dropdown = createDropdown(locale);
    dropdown.class = "ck-toolbar__grouped-dropdown";
    dropdown.panelPosition = locale.uiLanguageDirection === "ltr" ? "sw" : "se";
    addToolbarToDropdown(dropdown, this.groupedItems);
    dropdown.buttonView.set({
      label: t("Show more items"),
      tooltip: true,
      tooltipPosition: locale.uiLanguageDirection === "rtl" ? "se" : "sw",
      icon: threeVerticalDots
    });
    return dropdown;
  }
  _updateFocusCycleableItems() {
    this.viewFocusables.clear();
    this.ungroupedItems.map((item) => {
      this.viewFocusables.add(item);
    });
    if (this.groupedItems.length) {
      this.viewFocusables.add(this.groupedItemsDropdown);
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/list/listitemgroupview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ListItemGroupView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    const groupLabelId = `ck-editor__label_${uid()}`;
    const nestedList = new listview_default(locale);
    this.children = this.createCollection();
    this.children.addMany([this._createLabel(groupLabelId), nestedList]);
    this.set({
      label: "",
      isVisible: true
    });
    nestedList.set({
      role: "group",
      ariaLabelledBy: groupLabelId
    });
    nestedList.focusTracker.destroy();
    nestedList.keystrokes.destroy();
    this.items = nestedList.items;
    this.setTemplate({
      tag: "li",
      attributes: {
        role: "presentation",
        class: [
          "ck",
          "ck-list__group",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.children
    });
  }
  _createLabel(groupLabelId) {
    const labelView = new view_default2(this.locale);
    const bind = this.bindTemplate;
    labelView.setTemplate({
      tag: "span",
      attributes: {
        id: groupLabelId
      },
      children: [
        {text: bind.to("label")}
      ]
    });
    return labelView;
  }
  focus() {
    if (this.items.first) {
      this.items.first.focus();
    }
  }
};
var listitemgroupview_default = ListItemGroupView;

// node_modules/@ckeditor/ckeditor5-ui/src/list/listview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ListView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this._listItemGroupToChangeListeners = new WeakMap();
    const bind = this.bindTemplate;
    this.focusables = new viewcollection_default();
    this.items = this.createCollection();
    this.focusTracker = new focustracker_default();
    this.keystrokes = new keystrokehandler_default();
    this._focusCycler = new focuscycler_default({
      focusables: this.focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: "arrowup",
        focusNext: "arrowdown"
      }
    });
    this.set("ariaLabel", void 0);
    this.set("ariaLabelledBy", void 0);
    this.set("role", void 0);
    this.setTemplate({
      tag: "ul",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-list"
        ],
        role: bind.to("role"),
        "aria-label": bind.to("ariaLabel"),
        "aria-labelledby": bind.to("ariaLabelledBy")
      },
      children: this.items
    });
  }
  render() {
    super.render();
    for (const item of this.items) {
      if (item instanceof listitemgroupview_default) {
        this._registerFocusableItemsGroup(item);
      } else {
        this._registerFocusableListItem(item);
      }
    }
    this.items.on("change", (evt, data) => {
      for (const removed of data.removed) {
        if (removed instanceof listitemgroupview_default) {
          this._deregisterFocusableItemsGroup(removed);
        } else {
          this._deregisterFocusableListItem(removed);
        }
      }
      for (const added of Array.from(data.added).reverse()) {
        if (added instanceof listitemgroupview_default) {
          this._registerFocusableItemsGroup(added, data.index);
        } else {
          this._registerFocusableListItem(added, data.index);
        }
      }
    });
    this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
  _registerFocusableListItem(item, index) {
    this.focusTracker.add(item.element);
    this.focusables.add(item, index);
  }
  _deregisterFocusableListItem(item) {
    this.focusTracker.remove(item.element);
    this.focusables.remove(item);
  }
  _getOnGroupItemsChangeCallback(groupView) {
    return (evt, data) => {
      for (const removed of data.removed) {
        this._deregisterFocusableListItem(removed);
      }
      for (const added of Array.from(data.added).reverse()) {
        this._registerFocusableListItem(added, this.items.getIndex(groupView) + data.index);
      }
    };
  }
  _registerFocusableItemsGroup(groupView, groupIndex) {
    Array.from(groupView.items).forEach((child, childIndex) => {
      const registeredChildIndex = typeof groupIndex !== "undefined" ? groupIndex + childIndex : void 0;
      this._registerFocusableListItem(child, registeredChildIndex);
    });
    const groupItemsChangeCallback = this._getOnGroupItemsChangeCallback(groupView);
    this._listItemGroupToChangeListeners.set(groupView, groupItemsChangeCallback);
    groupView.items.on("change", groupItemsChangeCallback);
  }
  _deregisterFocusableItemsGroup(groupView) {
    for (const child of groupView.items) {
      this._deregisterFocusableListItem(child);
    }
    groupView.items.off("change", this._listItemGroupToChangeListeners.get(groupView));
    this._listItemGroupToChangeListeners.delete(groupView);
  }
};
var listview_default = ListView;

// node_modules/@ckeditor/ckeditor5-ui/src/list/listitemview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ListItemView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", true);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__item",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        role: "presentation"
      },
      children: this.children
    });
  }
  focus() {
    if (this.children.first) {
      this.children.first.focus();
    }
  }
};
var listitemview_default = ListItemView;

// node_modules/@ckeditor/ckeditor5-ui/src/list/listseparatorview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ListSeparatorView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "li",
      attributes: {
        class: [
          "ck",
          "ck-list__separator"
        ]
      }
    });
  }
};
var listseparatorview_default = ListSeparatorView;

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SplitButtonView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("class", void 0);
    this.set("labelStyle", void 0);
    this.set("icon", void 0);
    this.set("isEnabled", true);
    this.set("isOn", false);
    this.set("isToggleable", false);
    this.set("isVisible", true);
    this.set("keystroke", void 0);
    this.set("withKeystroke", false);
    this.set("label", void 0);
    this.set("tabindex", -1);
    this.set("tooltip", false);
    this.set("tooltipPosition", "s");
    this.set("type", "button");
    this.set("withText", false);
    this.children = this.createCollection();
    this.actionView = this._createActionView();
    this.arrowView = this._createArrowView();
    this.keystrokes = new keystrokehandler_default();
    this.focusTracker = new focustracker_default();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-splitbutton",
          bind.to("class"),
          bind.if("isVisible", "ck-hidden", (value) => !value),
          this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
        ]
      },
      children: this.children
    });
  }
  render() {
    super.render();
    this.children.add(this.actionView);
    this.children.add(this.arrowView);
    this.focusTracker.add(this.actionView.element);
    this.focusTracker.add(this.arrowView.element);
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", (evt, cancel) => {
      if (this.focusTracker.focusedElement === this.actionView.element) {
        this.arrowView.focus();
        cancel();
      }
    });
    this.keystrokes.set("arrowleft", (evt, cancel) => {
      if (this.focusTracker.focusedElement === this.arrowView.element) {
        this.actionView.focus();
        cancel();
      }
    });
  }
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  focus() {
    this.actionView.focus();
  }
  _createActionView() {
    const actionView = new buttonview_default();
    actionView.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
    actionView.extendTemplate({
      attributes: {
        class: "ck-splitbutton__action"
      }
    });
    actionView.delegate("execute").to(this);
    return actionView;
  }
  _createArrowView() {
    const arrowView = new buttonview_default();
    const bind = arrowView.bindTemplate;
    arrowView.icon = dropdown_arrow_default;
    arrowView.extendTemplate({
      attributes: {
        class: [
          "ck-splitbutton__arrow"
        ],
        "data-cke-tooltip-disabled": bind.to("isOn"),
        "aria-haspopup": true,
        "aria-expanded": bind.to("isOn", (value) => String(value))
      }
    });
    arrowView.bind("isEnabled").to(this);
    arrowView.bind("label").to(this);
    arrowView.bind("tooltip").to(this);
    arrowView.delegate("execute").to(this, "open");
    return arrowView;
  }
};
var splitbuttonview_default = SplitButtonView;

// node_modules/@ckeditor/ckeditor5-ui/src/dropdown/utils.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function createDropdown(locale, ButtonClass = dropdownbuttonview_default) {
  const buttonView = new ButtonClass(locale);
  const panelView = new dropdownpanelview_default(locale);
  const dropdownView = new dropdownview_default(locale, buttonView, panelView);
  buttonView.bind("isEnabled").to(dropdownView);
  if (buttonView instanceof splitbuttonview_default) {
    buttonView.arrowView.bind("isOn").to(dropdownView, "isOpen");
  } else {
    buttonView.bind("isOn").to(dropdownView, "isOpen");
  }
  addDefaultBehavior(dropdownView);
  return dropdownView;
}
function addToolbarToDropdown(dropdownView, buttonsOrCallback, options = {}) {
  dropdownView.extendTemplate({
    attributes: {
      class: ["ck-toolbar-dropdown"]
    }
  });
  if (dropdownView.isOpen) {
    addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options);
  } else {
    dropdownView.once("change:isOpen", () => addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options), {priority: "highest"});
  }
  if (options.enableActiveItemFocusOnDropdownOpen) {
    focusChildOnDropdownOpen(dropdownView, () => dropdownView.toolbarView.items.find((item) => item.isOn));
  }
}
function addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options) {
  const locale = dropdownView.locale;
  const t = locale.t;
  const toolbarView = dropdownView.toolbarView = new toolbarview_default(locale);
  const buttons = typeof buttonsOrCallback == "function" ? buttonsOrCallback() : buttonsOrCallback;
  toolbarView.ariaLabel = options.ariaLabel || t("Dropdown toolbar");
  if (options.maxWidth) {
    toolbarView.maxWidth = options.maxWidth;
  }
  if (options.class) {
    toolbarView.class = options.class;
  }
  if (options.isCompact) {
    toolbarView.isCompact = options.isCompact;
  }
  if (options.isVertical) {
    toolbarView.isVertical = true;
  }
  if (buttons instanceof viewcollection_default) {
    toolbarView.items.bindTo(buttons).using((item) => item);
  } else {
    toolbarView.items.addMany(buttons);
  }
  dropdownView.panelView.children.add(toolbarView);
  toolbarView.items.delegate("execute").to(dropdownView);
}
function addListToDropdown(dropdownView, itemsOrCallback, options = {}) {
  if (dropdownView.isOpen) {
    addListToOpenDropdown(dropdownView, itemsOrCallback, options);
  } else {
    dropdownView.once("change:isOpen", () => addListToOpenDropdown(dropdownView, itemsOrCallback, options), {priority: "highest"});
  }
  focusChildOnDropdownOpen(dropdownView, () => dropdownView.listView.items.find((item) => {
    if (item instanceof listitemview_default) {
      return item.children.first.isOn;
    }
    return false;
  }));
}
function addListToOpenDropdown(dropdownView, itemsOrCallback, options) {
  const locale = dropdownView.locale;
  const listView = dropdownView.listView = new listview_default(locale);
  const items = typeof itemsOrCallback == "function" ? itemsOrCallback() : itemsOrCallback;
  listView.ariaLabel = options.ariaLabel;
  listView.role = options.role;
  bindViewCollectionItemsToDefinitions(dropdownView, listView.items, items, locale);
  dropdownView.panelView.children.add(listView);
  listView.items.delegate("execute").to(dropdownView);
}
function focusChildOnDropdownOpen(dropdownView, childSelectorCallback) {
  dropdownView.on("change:isOpen", () => {
    if (!dropdownView.isOpen) {
      return;
    }
    const childToFocus = childSelectorCallback();
    if (!childToFocus) {
      return;
    }
    if (typeof childToFocus.focus === "function") {
      childToFocus.focus();
    } else {
      logWarning("ui-dropdown-focus-child-on-open-child-missing-focus", {view: childToFocus});
    }
  }, {priority: priorities_default.low - 10});
}
function addDefaultBehavior(dropdownView) {
  closeDropdownOnClickOutside(dropdownView);
  closeDropdownOnExecute(dropdownView);
  closeDropdownOnBlur(dropdownView);
  focusDropdownContentsOnArrows(dropdownView);
  focusDropdownButtonOnClose(dropdownView);
  focusDropdownPanelOnOpen(dropdownView);
}
function closeDropdownOnClickOutside(dropdownView) {
  dropdownView.on("render", () => {
    clickOutsideHandler({
      emitter: dropdownView,
      activator: () => dropdownView.isOpen,
      callback: () => {
        dropdownView.isOpen = false;
      },
      contextElements: () => [
        dropdownView.element,
        ...dropdownView.focusTracker._elements
      ]
    });
  });
}
function closeDropdownOnExecute(dropdownView) {
  dropdownView.on("execute", (evt) => {
    if (evt.source instanceof switchbuttonview_default) {
      return;
    }
    dropdownView.isOpen = false;
  });
}
function closeDropdownOnBlur(dropdownView) {
  dropdownView.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
    if (dropdownView.isOpen && !isFocused) {
      dropdownView.isOpen = false;
    }
  });
}
function focusDropdownContentsOnArrows(dropdownView) {
  dropdownView.keystrokes.set("arrowdown", (data, cancel) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focus();
      cancel();
    }
  });
  dropdownView.keystrokes.set("arrowup", (data, cancel) => {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focusLast();
      cancel();
    }
  });
}
function focusDropdownButtonOnClose(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (isOpen) {
      return;
    }
    const element = dropdownView.panelView.element;
    if (element && element.contains(global_default.document.activeElement)) {
      dropdownView.buttonView.focus();
    }
  });
}
function focusDropdownPanelOnOpen(dropdownView) {
  dropdownView.on("change:isOpen", (evt, name, isOpen) => {
    if (!isOpen) {
      return;
    }
    dropdownView.panelView.focus();
  }, {priority: "low"});
}
function bindViewCollectionItemsToDefinitions(dropdownView, listItems, definitions, locale) {
  listItems.bindTo(definitions).using((def) => {
    if (def.type === "separator") {
      return new listseparatorview_default(locale);
    } else if (def.type === "group") {
      const groupView = new listitemgroupview_default(locale);
      groupView.set({label: def.label});
      bindViewCollectionItemsToDefinitions(dropdownView, groupView.items, def.items, locale);
      groupView.items.delegate("execute").to(dropdownView);
      return groupView;
    } else if (def.type === "button" || def.type === "switchbutton") {
      const listItemView = new listitemview_default(locale);
      let buttonView;
      if (def.type === "button") {
        buttonView = new buttonview_default(locale);
      } else {
        buttonView = new switchbuttonview_default(locale);
      }
      buttonView.bind(...Object.keys(def.model)).to(def.model);
      buttonView.delegate("execute").to(listItemView);
      listItemView.children.add(buttonView);
      return listItemView;
    }
    return null;
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/utils.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var createLabeledInputText = (labeledFieldView, viewUid, statusUid) => {
  const inputView = new inputtextview_default(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
};
var createLabeledInputNumber = (labeledFieldView, viewUid, statusUid) => {
  const inputView = new inputnumberview_default(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid,
    inputMode: "numeric"
  });
  inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  inputView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
  return inputView;
};
var createLabeledTextarea = (labeledFieldView, viewUid, statusUid) => {
  const textareaView = new textareaview_default(labeledFieldView.locale);
  textareaView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  textareaView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
  textareaView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
  textareaView.on("input", () => {
    labeledFieldView.errorText = null;
  });
  labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(textareaView);
  return textareaView;
};
var createLabeledDropdown = (labeledFieldView, viewUid, statusUid) => {
  const dropdownView = createDropdown(labeledFieldView.locale);
  dropdownView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  dropdownView.bind("isEnabled").to(labeledFieldView);
  return dropdownView;
};

// node_modules/vanilla-colorful/lib/utils/math.js
var clamp = (number, min = 0, max = 1) => {
  return number > max ? max : number < min ? min : number;
};
var round = (number, digits = 0, base = Math.pow(10, digits)) => {
  return Math.round(base * number) / base;
};

// node_modules/vanilla-colorful/lib/utils/convert.js
var angleUnits = {
  grad: 360 / 400,
  turn: 360,
  rad: 360 / (Math.PI * 2)
};
var hexToHsva = (hex) => rgbaToHsva(hexToRgba(hex));
var hexToRgba = (hex) => {
  if (hex[0] === "#")
    hex = hex.substring(1);
  if (hex.length < 6) {
    return {
      r: parseInt(hex[0] + hex[0], 16),
      g: parseInt(hex[1] + hex[1], 16),
      b: parseInt(hex[2] + hex[2], 16),
      a: hex.length === 4 ? round(parseInt(hex[3] + hex[3], 16) / 255, 2) : 1
    };
  }
  return {
    r: parseInt(hex.substring(0, 2), 16),
    g: parseInt(hex.substring(2, 4), 16),
    b: parseInt(hex.substring(4, 6), 16),
    a: hex.length === 8 ? round(parseInt(hex.substring(6, 8), 16) / 255, 2) : 1
  };
};
var hsvaToHex = (hsva) => rgbaToHex(hsvaToRgba(hsva));
var hsvaToHsla = ({h, s, v, a}) => {
  const hh = (200 - s) * v / 100;
  return {
    h: round(h),
    s: round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
    l: round(hh / 2),
    a: round(a, 2)
  };
};
var hsvaToHslString = (hsva) => {
  const {h, s, l} = hsvaToHsla(hsva);
  return `hsl(${h}, ${s}%, ${l}%)`;
};
var hsvaToRgba = ({h, s, v, a}) => {
  h = h / 360 * 6;
  s = s / 100;
  v = v / 100;
  const hh = Math.floor(h), b = v * (1 - s), c = v * (1 - (h - hh) * s), d = v * (1 - (1 - h + hh) * s), module = hh % 6;
  return {
    r: round([v, c, b, b, d, v][module] * 255),
    g: round([d, v, v, c, b, b][module] * 255),
    b: round([b, b, d, v, v, c][module] * 255),
    a: round(a, 2)
  };
};
var format = (number) => {
  const hex = number.toString(16);
  return hex.length < 2 ? "0" + hex : hex;
};
var rgbaToHex = ({r, g, b, a}) => {
  const alphaHex = a < 1 ? format(round(a * 255)) : "";
  return "#" + format(r) + format(g) + format(b) + alphaHex;
};
var rgbaToHsva = ({r, g, b, a}) => {
  const max = Math.max(r, g, b);
  const delta = max - Math.min(r, g, b);
  const hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
  return {
    h: round(60 * (hh < 0 ? hh + 6 : hh)),
    s: round(max ? delta / max * 100 : 0),
    v: round(max / 255 * 100),
    a
  };
};

// node_modules/vanilla-colorful/lib/utils/compare.js
var equalColorObjects = (first2, second) => {
  if (first2 === second)
    return true;
  for (const prop in first2) {
    if (first2[prop] !== second[prop])
      return false;
  }
  return true;
};
var equalHex = (first2, second) => {
  if (first2.toLowerCase() === second.toLowerCase())
    return true;
  return equalColorObjects(hexToRgba(first2), hexToRgba(second));
};

// node_modules/vanilla-colorful/lib/utils/dom.js
var cache = {};
var tpl = (html) => {
  let template = cache[html];
  if (!template) {
    template = document.createElement("template");
    template.innerHTML = html;
    cache[html] = template;
  }
  return template;
};
var fire = (target, type, detail) => {
  target.dispatchEvent(new CustomEvent(type, {
    bubbles: true,
    detail
  }));
};

// node_modules/vanilla-colorful/lib/components/slider.js
var hasTouched = false;
var isTouch = (e) => "touches" in e;
var isValid = (event) => {
  if (hasTouched && !isTouch(event))
    return false;
  if (!hasTouched)
    hasTouched = isTouch(event);
  return true;
};
var pointerMove = (target, event) => {
  const pointer = isTouch(event) ? event.touches[0] : event;
  const rect = target.el.getBoundingClientRect();
  fire(target.el, "move", target.getMove({
    x: clamp((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),
    y: clamp((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height)
  }));
};
var keyMove = (target, event) => {
  const keyCode = event.keyCode;
  if (keyCode > 40 || target.xy && keyCode < 37 || keyCode < 33)
    return;
  event.preventDefault();
  fire(target.el, "move", target.getMove({
    x: keyCode === 39 ? 0.01 : keyCode === 37 ? -0.01 : keyCode === 34 ? 0.05 : keyCode === 33 ? -0.05 : keyCode === 35 ? 1 : keyCode === 36 ? -1 : 0,
    y: keyCode === 40 ? 0.01 : keyCode === 38 ? -0.01 : 0
  }, true));
};
var Slider = class {
  constructor(root2, part, aria, xy) {
    const template = tpl(`<div role="slider" tabindex="0" part="${part}" ${aria}><div part="${part}-pointer"></div></div>`);
    root2.appendChild(template.content.cloneNode(true));
    const el = root2.querySelector(`[part=${part}]`);
    el.addEventListener("mousedown", this);
    el.addEventListener("touchstart", this);
    el.addEventListener("keydown", this);
    this.el = el;
    this.xy = xy;
    this.nodes = [el.firstChild, el];
  }
  set dragging(state) {
    const toggleEvent = state ? document.addEventListener : document.removeEventListener;
    toggleEvent(hasTouched ? "touchmove" : "mousemove", this);
    toggleEvent(hasTouched ? "touchend" : "mouseup", this);
  }
  handleEvent(event) {
    switch (event.type) {
      case "mousedown":
      case "touchstart":
        event.preventDefault();
        if (!isValid(event) || !hasTouched && event.button != 0)
          return;
        this.el.focus();
        pointerMove(this, event);
        this.dragging = true;
        break;
      case "mousemove":
      case "touchmove":
        event.preventDefault();
        pointerMove(this, event);
        break;
      case "mouseup":
      case "touchend":
        this.dragging = false;
        break;
      case "keydown":
        keyMove(this, event);
        break;
    }
  }
  style(styles) {
    styles.forEach((style, i) => {
      for (const p in style) {
        this.nodes[i].style.setProperty(p, style[p]);
      }
    });
  }
};

// node_modules/vanilla-colorful/lib/components/hue.js
var Hue = class extends Slider {
  constructor(root2) {
    super(root2, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
  }
  update({h}) {
    this.h = h;
    this.style([
      {
        left: `${h / 360 * 100}%`,
        color: hsvaToHslString({h, s: 100, v: 100, a: 1})
      }
    ]);
    this.el.setAttribute("aria-valuenow", `${round(h)}`);
  }
  getMove(offset, key) {
    return {h: key ? clamp(this.h + offset.x * 360, 0, 360) : 360 * offset.x};
  }
};

// node_modules/vanilla-colorful/lib/components/saturation.js
var Saturation = class extends Slider {
  constructor(root2) {
    super(root2, "saturation", 'aria-label="Color"', true);
  }
  update(hsva) {
    this.hsva = hsva;
    this.style([
      {
        top: `${100 - hsva.v}%`,
        left: `${hsva.s}%`,
        color: hsvaToHslString(hsva)
      },
      {
        "background-color": hsvaToHslString({h: hsva.h, s: 100, v: 100, a: 1})
      }
    ]);
    this.el.setAttribute("aria-valuetext", `Saturation ${round(hsva.s)}%, Brightness ${round(hsva.v)}%`);
  }
  getMove(offset, key) {
    return {
      s: key ? clamp(this.hsva.s + offset.x * 100, 0, 100) : offset.x * 100,
      v: key ? clamp(this.hsva.v - offset.y * 100, 0, 100) : Math.round(100 - offset.y * 100)
    };
  }
};

// node_modules/vanilla-colorful/lib/styles/color-picker.js
var color_picker_default = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;

// node_modules/vanilla-colorful/lib/styles/hue.js
var hue_default = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;

// node_modules/vanilla-colorful/lib/styles/saturation.js
var saturation_default = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;

// node_modules/vanilla-colorful/lib/components/color-picker.js
var $isSame = Symbol("same");
var $color = Symbol("color");
var $hsva = Symbol("hsva");
var $update = Symbol("update");
var $parts = Symbol("parts");
var $css = Symbol("css");
var $sliders = Symbol("sliders");
var ColorPicker = class extends HTMLElement {
  static get observedAttributes() {
    return ["color"];
  }
  get [$css]() {
    return [color_picker_default, hue_default, saturation_default];
  }
  get [$sliders]() {
    return [Saturation, Hue];
  }
  get color() {
    return this[$color];
  }
  set color(newColor) {
    if (!this[$isSame](newColor)) {
      const newHsva = this.colorModel.toHsva(newColor);
      this[$update](newHsva);
      this[$color] = newColor;
    }
  }
  constructor() {
    super();
    const template = tpl(`<style>${this[$css].join("")}</style>`);
    const root2 = this.attachShadow({mode: "open"});
    root2.appendChild(template.content.cloneNode(true));
    root2.addEventListener("move", this);
    this[$parts] = this[$sliders].map((slider) => new slider(root2));
  }
  connectedCallback() {
    if (this.hasOwnProperty("color")) {
      const value = this.color;
      delete this["color"];
      this.color = value;
    } else if (!this.color) {
      this.color = this.colorModel.defaultColor;
    }
  }
  attributeChangedCallback(_attr, _oldVal, newVal) {
    const color = this.colorModel.fromAttr(newVal);
    if (!this[$isSame](color)) {
      this.color = color;
    }
  }
  handleEvent(event) {
    const oldHsva = this[$hsva];
    const newHsva = {...oldHsva, ...event.detail};
    this[$update](newHsva);
    let newColor;
    if (!equalColorObjects(newHsva, oldHsva) && !this[$isSame](newColor = this.colorModel.fromHsva(newHsva))) {
      this[$color] = newColor;
      fire(this, "color-changed", {value: newColor});
    }
  }
  [$isSame](color) {
    return this.color && this.colorModel.equal(color, this.color);
  }
  [$update](hsva) {
    this[$hsva] = hsva;
    this[$parts].forEach((part) => part.update(hsva));
  }
};

// node_modules/vanilla-colorful/lib/entrypoints/hex.js
var colorModel = {
  defaultColor: "#000",
  toHsva: hexToHsva,
  fromHsva: ({h, s, v}) => hsvaToHex({h, s, v, a: 1}),
  equal: equalHex,
  fromAttr: (color) => color
};
var HexBase = class extends ColorPicker {
  get colorModel() {
    return colorModel;
  }
};

// node_modules/vanilla-colorful/hex-color-picker.js
var HexColorPicker = class extends HexBase {
};
customElements.define("hex-color-picker", HexColorPicker);

// node_modules/@ckeditor/ckeditor5-ui/src/colorpicker/colorpickerview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var waitingTime = 150;
var ColorPickerView = class extends view_default2 {
  constructor(locale, config = {}) {
    super(locale);
    this.set({
      color: "",
      _hexColor: ""
    });
    this.hexInputRow = this._createInputRow();
    const children = this.createCollection();
    if (!config.hideInput) {
      children.add(this.hexInputRow);
    }
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-color-picker"],
        tabindex: -1
      },
      children
    });
    this._config = config;
    this._debounceColorPickerEvent = debounce_default((color) => {
      this.set("color", color);
      this.fire("colorSelected", {color: this.color});
    }, waitingTime, {
      leading: true
    });
    this.on("set:color", (evt, propertyName, newValue) => {
      evt.return = convertColor(newValue, this._config.format || "hsl");
    });
    this.on("change:color", () => {
      this._hexColor = convertColorToCommonHexFormat(this.color);
    });
    this.on("change:_hexColor", () => {
      if (document.activeElement !== this.picker) {
        this.picker.setAttribute("color", this._hexColor);
      }
      if (convertColorToCommonHexFormat(this.color) != convertColorToCommonHexFormat(this._hexColor)) {
        this.color = this._hexColor;
      }
    });
  }
  render() {
    super.render();
    this.picker = global_default.document.createElement("hex-color-picker");
    this.picker.setAttribute("class", "hex-color-picker");
    this.picker.setAttribute("tabindex", "-1");
    this._createSlidersView();
    if (this.element) {
      if (this.hexInputRow.element) {
        this.element.insertBefore(this.picker, this.hexInputRow.element);
      } else {
        this.element.appendChild(this.picker);
      }
      const styleSheetForFocusedColorPicker = document.createElement("style");
      styleSheetForFocusedColorPicker.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}';
      this.picker.shadowRoot.appendChild(styleSheetForFocusedColorPicker);
    }
    this.picker.addEventListener("color-changed", (event) => {
      const customEvent = event;
      const color = customEvent.detail.value;
      this._debounceColorPickerEvent(color);
    });
  }
  focus() {
    /* istanbul ignore next -- @preserve */
    if (!this._config.hideInput && (env_default.isGecko || env_default.isiOS || env_default.isSafari)) {
      const input = this.hexInputRow.children.get(1);
      input.focus();
    }
    const firstSlider = this.slidersView.first;
    firstSlider.focus();
  }
  _createSlidersView() {
    const colorPickersChildren = [...this.picker.shadowRoot.children];
    const sliders = colorPickersChildren.filter((item) => item.getAttribute("role") === "slider");
    const slidersView = sliders.map((slider) => {
      const view = new SliderView(slider);
      return view;
    });
    this.slidersView = this.createCollection();
    slidersView.forEach((item) => {
      this.slidersView.add(item);
    });
  }
  _createInputRow() {
    const hashView = new HashView();
    const colorInput = this._createColorInput();
    return new ColorPickerInputRowView(this.locale, [hashView, colorInput]);
  }
  _createColorInput() {
    const labeledInput = new labeledfieldview_default(this.locale, createLabeledInputText);
    const {t} = this.locale;
    labeledInput.set({
      label: t("HEX"),
      class: "color-picker-hex-input"
    });
    labeledInput.fieldView.bind("value").to(this, "_hexColor", (pickerColor) => {
      if (labeledInput.isFocused) {
        return labeledInput.fieldView.value;
      } else {
        return pickerColor.startsWith("#") ? pickerColor.substring(1) : pickerColor;
      }
    });
    labeledInput.fieldView.on("input", () => {
      const inputValue = labeledInput.fieldView.element.value;
      if (inputValue) {
        const trimmedValue = inputValue.trim();
        const hashlessInput = trimmedValue.startsWith("#") ? trimmedValue.substring(1) : trimmedValue;
        const isValidHexColor = [3, 4, 6, 8].includes(hashlessInput.length) && /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(hashlessInput);
        if (isValidHexColor) {
          this._debounceColorPickerEvent("#" + hashlessInput);
        }
      }
    });
    return labeledInput;
  }
};
var colorpickerview_default = ColorPickerView;
function convertColorToCommonHexFormat(inputColor) {
  let ret = convertToHex(inputColor);
  if (!ret) {
    ret = "#000";
  }
  if (ret.length === 4) {
    ret = "#" + [ret[1], ret[1], ret[2], ret[2], ret[3], ret[3]].join("");
  }
  return ret.toLowerCase();
}
var SliderView = class extends view_default2 {
  constructor(element) {
    super();
    this.element = element;
  }
  focus() {
    this.element.focus();
  }
};
var HashView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__hash-view"
        ]
      },
      children: "#"
    });
  }
};
var ColorPickerInputRowView = class extends view_default2 {
  constructor(locale, children) {
    super(locale);
    this.children = this.createCollection(children);
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-picker__row"
        ]
      },
      children: this.children
    });
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/documentcolorcollection.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DocumentColorCollection = class extends ObservableMixin(collection_default) {
  constructor(options) {
    super(options);
    this.set("isEmpty", true);
    this.on("change", () => {
      this.set("isEmpty", this.length === 0);
    });
  }
  add(item, index) {
    if (this.find((element) => element.color === item.color)) {
      return this;
    }
    return super.add(item, index);
  }
  hasColor(color) {
    return !!this.find((item) => item.color === color);
  }
};
var documentcolorcollection_default = DocumentColorCollection;

// node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-palette.svg
var color_palette_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>';

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorgridsfragmentview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ColorGridsFragmentView = class extends view_default2 {
  constructor(locale, {colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, focusTracker, focusables}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isVisible", true);
    this.focusTracker = focusTracker;
    this.items = this.createCollection();
    this.colorDefinitions = colors;
    this.columns = columns;
    this.documentColors = new documentcolorcollection_default();
    this.documentColorsCount = documentColorsCount;
    this._focusables = focusables;
    this._removeButtonLabel = removeButtonLabel;
    this._colorPickerLabel = colorPickerLabel;
    this._documentColorsLabel = documentColorsLabel;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-grids-fragment",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.items
    });
    this.removeColorButtonView = this._createRemoveColorButton();
    this.items.add(this.removeColorButtonView);
  }
  updateDocumentColors(model, attributeName) {
    const document2 = model.document;
    const maxCount = this.documentColorsCount;
    this.documentColors.clear();
    for (const root2 of document2.getRoots()) {
      const range = model.createRangeIn(root2);
      for (const node of range.getItems()) {
        if (node.is("$textProxy") && node.hasAttribute(attributeName)) {
          this._addColorToDocumentColors(node.getAttribute(attributeName));
          if (this.documentColors.length >= maxCount) {
            return;
          }
        }
      }
    }
  }
  updateSelectedColors() {
    const documentColorsGrid = this.documentColorsGrid;
    const staticColorsGrid = this.staticColorsGrid;
    const selectedColor = this.selectedColor;
    staticColorsGrid.selectedColor = selectedColor;
    if (documentColorsGrid) {
      documentColorsGrid.selectedColor = selectedColor;
    }
  }
  render() {
    super.render();
    this.staticColorsGrid = this._createStaticColorsGrid();
    this.items.add(this.staticColorsGrid);
    if (this.documentColorsCount) {
      const bind = template_default.bind(this.documentColors, this.documentColors);
      const label = new labelview_default(this.locale);
      label.text = this._documentColorsLabel;
      label.extendTemplate({
        attributes: {
          class: [
            "ck",
            "ck-color-grid__label",
            bind.if("isEmpty", "ck-hidden")
          ]
        }
      });
      this.items.add(label);
      this.documentColorsGrid = this._createDocumentColorsGrid();
      this.items.add(this.documentColorsGrid);
    }
    this._createColorPickerButton();
    this._addColorSelectorElementsToFocusTracker();
    this.focus();
  }
  focus() {
    this.removeColorButtonView.focus();
  }
  destroy() {
    super.destroy();
  }
  addColorPickerButton() {
    if (this.colorPickerButtonView) {
      this.items.add(this.colorPickerButtonView);
      this.focusTracker.add(this.colorPickerButtonView.element);
      this._focusables.add(this.colorPickerButtonView);
    }
  }
  _addColorSelectorElementsToFocusTracker() {
    this.focusTracker.add(this.removeColorButtonView.element);
    this._focusables.add(this.removeColorButtonView);
    if (this.staticColorsGrid) {
      this.focusTracker.add(this.staticColorsGrid.element);
      this._focusables.add(this.staticColorsGrid);
    }
    if (this.documentColorsGrid) {
      this.focusTracker.add(this.documentColorsGrid.element);
      this._focusables.add(this.documentColorsGrid);
    }
  }
  _createColorPickerButton() {
    this.colorPickerButtonView = new buttonview_default();
    this.colorPickerButtonView.set({
      label: this._colorPickerLabel,
      withText: true,
      icon: color_palette_default,
      class: "ck-color-selector__color-picker"
    });
    this.colorPickerButtonView.on("execute", () => {
      this.fire("colorPicker:show");
    });
  }
  _createRemoveColorButton() {
    const buttonView = new buttonview_default();
    buttonView.set({
      withText: true,
      icon: eraser_default,
      label: this._removeButtonLabel
    });
    buttonView.class = "ck-color-selector__remove-color";
    buttonView.on("execute", () => {
      this.fire("execute", {
        value: null,
        source: "removeColorButton"
      });
    });
    buttonView.render();
    return buttonView;
  }
  _createStaticColorsGrid() {
    const colorGrid = new colorgridview_default(this.locale, {
      colorDefinitions: this.colorDefinitions,
      columns: this.columns
    });
    colorGrid.on("execute", (evt, data) => {
      this.fire("execute", {
        value: data.value,
        source: "staticColorsGrid"
      });
    });
    return colorGrid;
  }
  _createDocumentColorsGrid() {
    const bind = template_default.bind(this.documentColors, this.documentColors);
    const documentColorsGrid = new colorgridview_default(this.locale, {
      columns: this.columns
    });
    documentColorsGrid.extendTemplate({
      attributes: {
        class: bind.if("isEmpty", "ck-hidden")
      }
    });
    documentColorsGrid.items.bindTo(this.documentColors).using((colorObj) => {
      const colorTile = new colortileview_default();
      colorTile.set({
        color: colorObj.color,
        hasBorder: colorObj.options && colorObj.options.hasBorder
      });
      if (colorObj.label) {
        colorTile.set({
          label: colorObj.label,
          tooltip: true
        });
      }
      colorTile.on("execute", () => {
        this.fire("execute", {
          value: colorObj.color,
          source: "documentColorsGrid"
        });
      });
      return colorTile;
    });
    this.documentColors.on("change:isEmpty", (evt, name, val) => {
      if (val) {
        documentColorsGrid.selectedColor = null;
      }
    });
    return documentColorsGrid;
  }
  _addColorToDocumentColors(color) {
    const predefinedColor = this.colorDefinitions.find((definition) => definition.color === color);
    if (!predefinedColor) {
      this.documentColors.add({
        color,
        label: color,
        options: {
          hasBorder: false
        }
      });
    } else {
      this.documentColors.add(Object.assign({}, predefinedColor));
    }
  }
};
var colorgridsfragmentview_default = ColorGridsFragmentView;

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorpickerfragmentview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ColorPickerFragmentView = class extends view_default2 {
  constructor(locale, {focusTracker, focusables, keystrokes, colorPickerViewConfig}) {
    super(locale);
    this.items = this.createCollection();
    this.focusTracker = focusTracker;
    this.keystrokes = keystrokes;
    this.set("isVisible", false);
    this.set("selectedColor", void 0);
    this._focusables = focusables;
    this._colorPickerViewConfig = colorPickerViewConfig;
    const bind = this.bindTemplate;
    const {saveButtonView, cancelButtonView} = this._createActionButtons();
    this.saveButtonView = saveButtonView;
    this.cancelButtonView = cancelButtonView;
    this.actionBarView = this._createActionBarView({saveButtonView, cancelButtonView});
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-color-picker-fragment",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: this.items
    });
  }
  render() {
    super.render();
    const colorPickerView = new colorpickerview_default(this.locale, {
      ...this._colorPickerViewConfig
    });
    this.colorPickerView = colorPickerView;
    this.colorPickerView.render();
    if (this.selectedColor) {
      colorPickerView.color = this.selectedColor;
    }
    this.listenTo(this, "change:selectedColor", (evt, name, value) => {
      colorPickerView.color = value;
    });
    this.items.add(this.colorPickerView);
    this.items.add(this.actionBarView);
    this._addColorPickersElementsToFocusTracker();
    this._stopPropagationOnArrowsKeys();
    this._executeOnEnterPress();
    this._executeUponColorChange();
  }
  destroy() {
    super.destroy();
  }
  focus() {
    this.colorPickerView.focus();
  }
  _executeOnEnterPress() {
    this.keystrokes.set("enter", (evt) => {
      if (this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element) {
        this.fire("execute", {
          value: this.selectedColor
        });
        evt.stopPropagation();
        evt.preventDefault();
      }
    });
  }
  _stopPropagationOnArrowsKeys() {
    const stopPropagation = (data) => data.stopPropagation();
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  _addColorPickersElementsToFocusTracker() {
    for (const slider of this.colorPickerView.slidersView) {
      this.focusTracker.add(slider.element);
      this._focusables.add(slider);
    }
    const input = this.colorPickerView.hexInputRow.children.get(1);
    if (input.element) {
      this.focusTracker.add(input.element);
      this._focusables.add(input);
    }
    this.focusTracker.add(this.saveButtonView.element);
    this._focusables.add(this.saveButtonView);
    this.focusTracker.add(this.cancelButtonView.element);
    this._focusables.add(this.cancelButtonView);
  }
  _createActionBarView({saveButtonView, cancelButtonView}) {
    const actionBarRow = new view_default2();
    const children = this.createCollection();
    children.add(saveButtonView);
    children.add(cancelButtonView);
    actionBarRow.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector_action-bar"
        ]
      },
      children
    });
    return actionBarRow;
  }
  _createActionButtons() {
    const locale = this.locale;
    const t = locale.t;
    const saveButtonView = new buttonview_default(locale);
    const cancelButtonView = new buttonview_default(locale);
    saveButtonView.set({
      icon: check_default,
      class: "ck-button-save",
      type: "button",
      withText: false,
      label: t("Accept")
    });
    cancelButtonView.set({
      icon: cancel_default,
      class: "ck-button-cancel",
      type: "button",
      withText: false,
      label: t("Cancel")
    });
    saveButtonView.on("execute", () => {
      this.fire("execute", {
        source: "colorPickerSaveButton",
        value: this.selectedColor
      });
    });
    cancelButtonView.on("execute", () => {
      this.fire("colorPicker:cancel");
    });
    return {
      saveButtonView,
      cancelButtonView
    };
  }
  _executeUponColorChange() {
    this.colorPickerView.on("colorSelected", (evt, data) => {
      this.fire("execute", {
        value: data.color,
        source: "colorPicker"
      });
      this.set("selectedColor", data.color);
    });
  }
};
var colorpickerfragmentview_default = ColorPickerFragmentView;

// node_modules/@ckeditor/ckeditor5-ui/src/colorselector/colorselectorview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ColorSelectorView = class extends view_default2 {
  constructor(locale, {colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, colorPickerViewConfig}) {
    super(locale);
    this.items = this.createCollection();
    this.focusTracker = new focustracker_default();
    this.keystrokes = new keystrokehandler_default();
    this._focusables = new viewcollection_default();
    this._colorPickerViewConfig = colorPickerViewConfig;
    this._focusCycler = new focuscycler_default({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: "shift + tab",
        focusNext: "tab"
      }
    });
    this.colorGridsFragmentView = new colorgridsfragmentview_default(locale, {
      colors,
      columns,
      removeButtonLabel,
      documentColorsLabel,
      documentColorsCount,
      colorPickerLabel,
      focusTracker: this.focusTracker,
      focusables: this._focusables
    });
    this.colorPickerFragmentView = new colorpickerfragmentview_default(locale, {
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokes: this.keystrokes,
      colorPickerViewConfig
    });
    this.set("_isColorGridsFragmentVisible", true);
    this.set("_isColorPickerFragmentVisible", false);
    this.set("selectedColor", void 0);
    this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible");
    this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible");
    this.on("change:selectedColor", (evt, evtName, data) => {
      this.colorGridsFragmentView.set("selectedColor", data);
      this.colorPickerFragmentView.set("selectedColor", data);
    });
    this.colorGridsFragmentView.on("change:selectedColor", (evt, evtName, data) => {
      this.set("selectedColor", data);
    });
    this.colorPickerFragmentView.on("change:selectedColor", (evt, evtName, data) => {
      this.set("selectedColor", data);
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-color-selector"
        ]
      },
      children: this.items
    });
  }
  render() {
    super.render();
    this.keystrokes.listenTo(this.element);
  }
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
    this.keystrokes.destroy();
  }
  appendUI() {
    this._appendColorGridsFragment();
    if (this._colorPickerViewConfig) {
      this._appendColorPickerFragment();
    }
  }
  showColorPickerFragment() {
    if (!this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible) {
      return;
    }
    this._isColorPickerFragmentVisible = true;
    this.colorPickerFragmentView.focus();
    this._isColorGridsFragmentVisible = false;
  }
  showColorGridsFragment() {
    if (this._isColorGridsFragmentVisible) {
      return;
    }
    this._isColorGridsFragmentVisible = true;
    this.colorGridsFragmentView.focus();
    this._isColorPickerFragmentVisible = false;
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
  updateDocumentColors(model, attributeName) {
    this.colorGridsFragmentView.updateDocumentColors(model, attributeName);
  }
  updateSelectedColors() {
    this.colorGridsFragmentView.updateSelectedColors();
  }
  _appendColorGridsFragment() {
    if (this.items.length) {
      return;
    }
    this.items.add(this.colorGridsFragmentView);
    this.colorGridsFragmentView.delegate("execute").to(this);
    this.colorGridsFragmentView.delegate("colorPicker:show").to(this);
  }
  _appendColorPickerFragment() {
    if (this.items.length === 2) {
      return;
    }
    this.items.add(this.colorPickerFragmentView);
    if (this.colorGridsFragmentView.colorPickerButtonView) {
      this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
        this.showColorPickerFragment();
      });
    }
    this.colorGridsFragmentView.addColorPickerButton();
    this.colorPickerFragmentView.delegate("execute").to(this);
    this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this);
  }
};
var colorselectorview_default = ColorSelectorView;

// node_modules/@ckeditor/ckeditor5-ui/src/componentfactory.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ComponentFactory = class {
  constructor(editor) {
    this._components = new Map();
    this.editor = editor;
  }
  *names() {
    for (const value of this._components.values()) {
      yield value.originalName;
    }
  }
  add(name, callback) {
    this._components.set(getNormalized(name), {callback, originalName: name});
  }
  create(name) {
    if (!this.has(name)) {
      throw new ckeditorerror_default("componentfactory-item-missing", this, {name});
    }
    return this._components.get(getNormalized(name)).callback(this.editor.locale);
  }
  has(name) {
    return this._components.has(getNormalized(name));
  }
};
var componentfactory_default = ComponentFactory;
function getNormalized(name) {
  return String(name).toLowerCase();
}

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var toPx = toUnit("px");
var defaultLimiterElement = global_default.document.body;
var POSITION_OFF_SCREEN = {
  top: -99999,
  left: -99999,
  name: "arrowless",
  config: {
    withArrow: false
  }
};
var BalloonPanelView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("position", "arrow_nw");
    this.set("isVisible", false);
    this.set("withArrow", true);
    this.set("class", void 0);
    this._pinWhenIsVisibleCallback = null;
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-panel",
          bind.to("position", (value) => `ck-balloon-panel_${value}`),
          bind.if("isVisible", "ck-balloon-panel_visible"),
          bind.if("withArrow", "ck-balloon-panel_with-arrow"),
          bind.to("class")
        ],
        style: {
          top: bind.to("top", toPx),
          left: bind.to("left", toPx)
        }
      },
      children: this.content
    });
  }
  show() {
    this.isVisible = true;
  }
  hide() {
    this.isVisible = false;
  }
  attachTo(options) {
    this.show();
    const defaultPositions = BalloonPanelView.defaultPositions;
    const positionOptions = Object.assign({}, {
      element: this.element,
      positions: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthMiddleWest,
        defaultPositions.southArrowNorthMiddleEast,
        defaultPositions.southArrowNorthWest,
        defaultPositions.southArrowNorthEast,
        defaultPositions.northArrowSouth,
        defaultPositions.northArrowSouthMiddleWest,
        defaultPositions.northArrowSouthMiddleEast,
        defaultPositions.northArrowSouthWest,
        defaultPositions.northArrowSouthEast,
        defaultPositions.viewportStickyNorth
      ],
      limiter: defaultLimiterElement,
      fitInViewport: true
    }, options);
    const optimalPosition = BalloonPanelView._getOptimalPosition(positionOptions) || POSITION_OFF_SCREEN;
    const left = parseInt(optimalPosition.left);
    const top = parseInt(optimalPosition.top);
    const position = optimalPosition.name;
    const config = optimalPosition.config || {};
    const {withArrow = true} = config;
    this.top = top;
    this.left = left;
    this.position = position;
    this.withArrow = withArrow;
  }
  pin(options) {
    this.unpin();
    this._pinWhenIsVisibleCallback = () => {
      if (this.isVisible) {
        this._startPinning(options);
      } else {
        this._stopPinning();
      }
    };
    this._startPinning(options);
    this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
  }
  unpin() {
    if (this._pinWhenIsVisibleCallback) {
      this._stopPinning();
      this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
      this._pinWhenIsVisibleCallback = null;
      this.hide();
    }
  }
  _startPinning(options) {
    this.attachTo(options);
    const targetElement = getDomElement(options.target);
    const limiterElement = options.limiter ? getDomElement(options.limiter) : defaultLimiterElement;
    this.listenTo(global_default.document, "scroll", (evt, domEvt) => {
      const scrollTarget = domEvt.target;
      const isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement);
      const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement);
      if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
        this.attachTo(options);
      }
    }, {useCapture: true});
    this.listenTo(global_default.window, "resize", () => {
      this.attachTo(options);
    });
  }
  _stopPinning() {
    this.stopListening(global_default.document, "scroll");
    this.stopListening(global_default.window, "resize");
  }
};
var balloonpanelview_default = BalloonPanelView;
BalloonPanelView.arrowSideOffset = 25;
BalloonPanelView.arrowHeightOffset = 10;
BalloonPanelView.stickyVerticalOffset = 20;
BalloonPanelView._getOptimalPosition = getOptimalPosition;
BalloonPanelView.defaultPositions = generatePositions();
function getDomElement(object) {
  if (isElement_default(object)) {
    return object;
  }
  if (isRange(object)) {
    return object.commonAncestorContainer;
  }
  if (typeof object == "function") {
    return getDomElement(object());
  }
  return null;
}
function generatePositions(options = {}) {
  const {sideOffset = BalloonPanelView.arrowSideOffset, heightOffset = BalloonPanelView.arrowHeightOffset, stickyVerticalOffset = BalloonPanelView.stickyVerticalOffset, config} = options;
  return {
    northWestArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - sideOffset,
      name: "arrow_sw",
      ...config && {config}
    }),
    northWestArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && {config}
    }),
    northWestArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width / 2,
      name: "arrow_s",
      ...config && {config}
    }),
    northWestArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && {config}
    }),
    northWestArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && {config}
    }),
    northArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - sideOffset,
      name: "arrow_sw",
      ...config && {config}
    }),
    northArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && {config}
    }),
    northArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: "arrow_s",
      ...config && {config}
    }),
    northArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && {config}
    }),
    northArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && {config}
    }),
    northEastArrowSouthWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - sideOffset,
      name: "arrow_sw",
      ...config && {config}
    }),
    northEastArrowSouthMiddleWest: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_smw",
      ...config && {config}
    }),
    northEastArrowSouth: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width / 2,
      name: "arrow_s",
      ...config && {config}
    }),
    northEastArrowSouthMiddleEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_sme",
      ...config && {config}
    }),
    northEastArrowSouthEast: (targetRect, balloonRect) => ({
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width + sideOffset,
      name: "arrow_se",
      ...config && {config}
    }),
    southWestArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - sideOffset,
      name: "arrow_nw",
      ...config && {config}
    }),
    southWestArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && {config}
    }),
    southWestArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width / 2,
      name: "arrow_n",
      ...config && {config}
    }),
    southWestArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && {config}
    }),
    southWestArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && {config}
    }),
    southArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - sideOffset,
      name: "arrow_nw",
      ...config && {config}
    }),
    southArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && {config}
    }),
    southArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: "arrow_n",
      ...config && {config}
    }),
    southArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && {config}
    }),
    southArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && {config}
    }),
    southEastArrowNorthWest: (targetRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - sideOffset,
      name: "arrow_nw",
      ...config && {config}
    }),
    southEastArrowNorthMiddleWest: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
      name: "arrow_nmw",
      ...config && {config}
    }),
    southEastArrowNorth: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width / 2,
      name: "arrow_n",
      ...config && {config}
    }),
    southEastArrowNorthMiddleEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
      name: "arrow_nme",
      ...config && {config}
    }),
    southEastArrowNorthEast: (targetRect, balloonRect) => ({
      top: getSouthTop(targetRect),
      left: targetRect.right - balloonRect.width + sideOffset,
      name: "arrow_ne",
      ...config && {config}
    }),
    westArrowEast: (targetRect, balloonRect) => ({
      top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
      left: targetRect.left - balloonRect.width - heightOffset,
      name: "arrow_e",
      ...config && {config}
    }),
    eastArrowWest: (targetRect, balloonRect) => ({
      top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
      left: targetRect.right + heightOffset,
      name: "arrow_w",
      ...config && {config}
    }),
    viewportStickyNorth: (targetRect, balloonRect, viewportRect, limiterRect) => {
      const boundaryRect = limiterRect || viewportRect;
      if (!targetRect.getIntersection(boundaryRect)) {
        return null;
      }
      if (boundaryRect.height - targetRect.height > stickyVerticalOffset) {
        return null;
      }
      return {
        top: boundaryRect.top + stickyVerticalOffset,
        left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
        name: "arrowless",
        config: {
          withArrow: false,
          ...config
        }
      };
    }
  };
  function getNorthTop(targetRect, balloonRect) {
    return targetRect.top - balloonRect.height - heightOffset;
  }
  function getSouthTop(targetRect) {
    return targetRect.bottom + heightOffset;
  }
}

// node_modules/@ckeditor/ckeditor5-ui/src/tooltipmanager.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BALLOON_CLASS = "ck-tooltip";
var TooltipManager = class extends DomEmitterMixin() {
  constructor(editor) {
    super();
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    this._resizeObserver = null;
    TooltipManager._editors.add(editor);
    if (TooltipManager._instance) {
      return TooltipManager._instance;
    }
    TooltipManager._instance = this;
    this.tooltipTextView = new view_default2(editor.locale);
    this.tooltipTextView.set("text", "");
    this.tooltipTextView.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-tooltip__text"
        ]
      },
      children: [
        {
          text: this.tooltipTextView.bindTemplate.to("text")
        }
      ]
    });
    this.balloonPanelView = new balloonpanelview_default(editor.locale);
    this.balloonPanelView.class = BALLOON_CLASS;
    this.balloonPanelView.content.add(this.tooltipTextView);
    this._pinTooltipDebounced = debounce_default(this._pinTooltip, 600);
    this.listenTo(global_default.document, "mouseenter", this._onEnterOrFocus.bind(this), {useCapture: true});
    this.listenTo(global_default.document, "mouseleave", this._onLeaveOrBlur.bind(this), {useCapture: true});
    this.listenTo(global_default.document, "focus", this._onEnterOrFocus.bind(this), {useCapture: true});
    this.listenTo(global_default.document, "blur", this._onLeaveOrBlur.bind(this), {useCapture: true});
    this.listenTo(global_default.document, "scroll", this._onScroll.bind(this), {useCapture: true});
    this._watchdogExcluded = true;
  }
  destroy(editor) {
    const editorBodyViewCollection = editor.ui.view && editor.ui.view.body;
    TooltipManager._editors.delete(editor);
    this.stopListening(editor.ui);
    if (editorBodyViewCollection && editorBodyViewCollection.has(this.balloonPanelView)) {
      editorBodyViewCollection.remove(this.balloonPanelView);
    }
    if (!TooltipManager._editors.size) {
      this._unpinTooltip();
      this.balloonPanelView.destroy();
      this.stopListening();
      TooltipManager._instance = null;
    }
  }
  static getPositioningFunctions(position) {
    const defaultPositions = TooltipManager.defaultBalloonPositions;
    return {
      s: [
        defaultPositions.southArrowNorth,
        defaultPositions.southArrowNorthEast,
        defaultPositions.southArrowNorthWest
      ],
      n: [defaultPositions.northArrowSouth],
      e: [defaultPositions.eastArrowWest],
      w: [defaultPositions.westArrowEast],
      sw: [defaultPositions.southArrowNorthEast],
      se: [defaultPositions.southArrowNorthWest]
    }[position];
  }
  _onEnterOrFocus(evt, {target}) {
    const elementWithTooltipAttribute = getDescendantWithTooltip(target);
    if (!elementWithTooltipAttribute) {
      return;
    }
    if (elementWithTooltipAttribute === this._currentElementWithTooltip) {
      return;
    }
    this._unpinTooltip();
    this._pinTooltipDebounced(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
  }
  _onLeaveOrBlur(evt, {target, relatedTarget}) {
    if (evt.name === "mouseleave") {
      if (!isElement_default(target)) {
        return;
      }
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      const descendantWithTooltip = getDescendantWithTooltip(target);
      const relatedDescendantWithTooltip = getDescendantWithTooltip(relatedTarget);
      if (descendantWithTooltip && descendantWithTooltip !== relatedDescendantWithTooltip) {
        this._unpinTooltip();
      }
    } else {
      if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
        return;
      }
      this._unpinTooltip();
    }
  }
  _onScroll(evt, {target}) {
    if (!this._currentElementWithTooltip) {
      return;
    }
    if (target.contains(this.balloonPanelView.element) && target.contains(this._currentElementWithTooltip)) {
      return;
    }
    this._unpinTooltip();
  }
  _pinTooltip(targetDomElement, {text, position, cssClass}) {
    const bodyViewCollection = first(TooltipManager._editors.values()).ui.view.body;
    if (!bodyViewCollection.has(this.balloonPanelView)) {
      bodyViewCollection.add(this.balloonPanelView);
    }
    this.tooltipTextView.text = text;
    this.balloonPanelView.pin({
      target: targetDomElement,
      positions: TooltipManager.getPositioningFunctions(position)
    });
    this._resizeObserver = new resizeobserver_default(targetDomElement, () => {
      if (!isVisible(targetDomElement)) {
        this._unpinTooltip();
      }
    });
    this.balloonPanelView.class = [BALLOON_CLASS, cssClass].filter((className) => className).join(" ");
    for (const editor of TooltipManager._editors) {
      this.listenTo(editor.ui, "update", this._updateTooltipPosition.bind(this), {priority: "low"});
    }
    this._currentElementWithTooltip = targetDomElement;
    this._currentTooltipPosition = position;
  }
  _unpinTooltip() {
    this._pinTooltipDebounced.cancel();
    this.balloonPanelView.unpin();
    for (const editor of TooltipManager._editors) {
      this.stopListening(editor.ui, "update");
    }
    this._currentElementWithTooltip = null;
    this._currentTooltipPosition = null;
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  _updateTooltipPosition() {
    if (!isVisible(this._currentElementWithTooltip)) {
      this._unpinTooltip();
      return;
    }
    this.balloonPanelView.pin({
      target: this._currentElementWithTooltip,
      positions: TooltipManager.getPositioningFunctions(this._currentTooltipPosition)
    });
  }
};
var tooltipmanager_default = TooltipManager;
TooltipManager.defaultBalloonPositions = generatePositions({
  heightOffset: 5,
  sideOffset: 13
});
TooltipManager._editors = new Set();
TooltipManager._instance = null;
function getDescendantWithTooltip(element) {
  if (!isElement_default(element)) {
    return null;
  }
  return element.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
}
function getTooltipData(element) {
  return {
    text: element.dataset.ckeTooltipText,
    position: element.dataset.ckeTooltipPosition || "s",
    cssClass: element.dataset.ckeTooltipClass || ""
  };
}

// node_modules/@ckeditor/ckeditor5-ui/theme/icons/project-logo.svg
var project_logo_default = '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n';

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/poweredby.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ICON_WIDTH = 53;
var ICON_HEIGHT = 10;
var NARROW_ROOT_HEIGHT_THRESHOLD = 50;
var NARROW_ROOT_WIDTH_THRESHOLD = 350;
var DEFAULT_LABEL = "Powered by";
var PoweredBy = class extends DomEmitterMixin() {
  constructor(editor) {
    super();
    this.editor = editor;
    this._balloonView = null;
    this._lastFocusedEditableElement = null;
    this._showBalloonThrottled = throttle_default(this._showBalloon.bind(this), 50, {leading: true});
    editor.on("ready", this._handleEditorReady.bind(this));
  }
  destroy() {
    const balloon = this._balloonView;
    if (balloon) {
      balloon.unpin();
      this._balloonView = null;
    }
    this._showBalloonThrottled.cancel();
    this.stopListening();
  }
  _handleEditorReady() {
    const editor = this.editor;
    const forceVisible = !!editor.config.get("ui.poweredBy.forceVisible");
    /* istanbul ignore next -- @preserve */
    if (!forceVisible && verifyLicense(editor.config.get("licenseKey")) === "VALID") {
      return;
    }
    if (!editor.ui.view) {
      return;
    }
    editor.ui.focusTracker.on("change:isFocused", (evt, data, isFocused) => {
      this._updateLastFocusedEditableElement();
      if (isFocused) {
        this._showBalloon();
      } else {
        this._hideBalloon();
      }
    });
    editor.ui.focusTracker.on("change:focusedElement", (evt, data, focusedElement) => {
      this._updateLastFocusedEditableElement();
      if (focusedElement) {
        this._showBalloon();
      }
    });
    editor.ui.on("update", () => {
      this._showBalloonThrottled();
    });
  }
  _createBalloonView() {
    const editor = this.editor;
    const balloon = this._balloonView = new balloonpanelview_default();
    const poweredByConfig = getNormalizedConfig(editor);
    const view = new PoweredByView(editor.locale, poweredByConfig.label);
    balloon.content.add(view);
    balloon.set({
      class: "ck-powered-by-balloon"
    });
    editor.ui.view.body.add(balloon);
    editor.ui.focusTracker.add(balloon.element);
    this._balloonView = balloon;
  }
  _showBalloon() {
    if (!this._lastFocusedEditableElement) {
      return;
    }
    const attachOptions = getBalloonAttachOptions(this.editor, this._lastFocusedEditableElement);
    if (attachOptions) {
      if (!this._balloonView) {
        this._createBalloonView();
      }
      this._balloonView.pin(attachOptions);
    }
  }
  _hideBalloon() {
    if (this._balloonView) {
      this._balloonView.unpin();
    }
  }
  _updateLastFocusedEditableElement() {
    const editor = this.editor;
    const isFocused = editor.ui.focusTracker.isFocused;
    const focusedElement = editor.ui.focusTracker.focusedElement;
    if (!isFocused || !focusedElement) {
      this._lastFocusedEditableElement = null;
      return;
    }
    const editableEditorElements = Array.from(editor.ui.getEditableElementsNames()).map((name) => {
      return editor.ui.getEditableElement(name);
    });
    if (editableEditorElements.includes(focusedElement)) {
      this._lastFocusedEditableElement = focusedElement;
    } else {
      this._lastFocusedEditableElement = editableEditorElements[0];
    }
  }
};
var poweredby_default = PoweredBy;
var PoweredByView = class extends view_default2 {
  constructor(locale, label) {
    super(locale);
    const iconView = new iconview_default();
    const bind = this.bindTemplate;
    iconView.set({
      content: project_logo_default,
      isColorInherited: false
    });
    iconView.extendTemplate({
      attributes: {
        style: {
          width: ICON_WIDTH + "px",
          height: ICON_HEIGHT + "px"
        }
      }
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: ["ck", "ck-powered-by"],
        "aria-hidden": true
      },
      children: [
        {
          tag: "a",
          attributes: {
            href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
            target: "_blank",
            tabindex: "-1"
          },
          children: [
            ...label ? [
              {
                tag: "span",
                attributes: {
                  class: ["ck", "ck-powered-by__label"]
                },
                children: [label]
              }
            ] : [],
            iconView
          ],
          on: {
            dragstart: bind.to((evt) => evt.preventDefault())
          }
        }
      ]
    });
  }
};
function getBalloonAttachOptions(editor, focusedEditableElement) {
  const poweredByConfig = getNormalizedConfig(editor);
  const positioningFunction = poweredByConfig.side === "right" ? getLowerRightCornerPosition(focusedEditableElement, poweredByConfig) : getLowerLeftCornerPosition(focusedEditableElement, poweredByConfig);
  return {
    target: focusedEditableElement,
    positions: [positioningFunction]
  };
}
function getLowerRightCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect, balloonRect) => {
    return rootRect.left + rootRect.width - balloonRect.width - config.horizontalOffset;
  });
}
function getLowerLeftCornerPosition(focusedEditableElement, config) {
  return getLowerCornerPosition(focusedEditableElement, config, (rootRect) => rootRect.left + config.horizontalOffset);
}
function getLowerCornerPosition(focusedEditableElement, config, getBalloonLeft) {
  return (visibleEditableElementRect, balloonRect) => {
    const editableElementRect = new rect_default(focusedEditableElement);
    if (editableElementRect.width < NARROW_ROOT_WIDTH_THRESHOLD || editableElementRect.height < NARROW_ROOT_HEIGHT_THRESHOLD) {
      return null;
    }
    let balloonTop;
    if (config.position === "inside") {
      balloonTop = editableElementRect.bottom - balloonRect.height;
    } else {
      balloonTop = editableElementRect.bottom - balloonRect.height / 2;
    }
    balloonTop -= config.verticalOffset;
    const balloonLeft = getBalloonLeft(editableElementRect, balloonRect);
    const newBalloonPositionRect = visibleEditableElementRect.clone().moveTo(balloonLeft, balloonTop).getIntersection(balloonRect.clone().moveTo(balloonLeft, balloonTop));
    const newBalloonPositionVisibleRect = newBalloonPositionRect.getVisible();
    if (!newBalloonPositionVisibleRect || newBalloonPositionVisibleRect.getArea() < balloonRect.getArea()) {
      return null;
    }
    return {
      top: balloonTop,
      left: balloonLeft,
      name: `position_${config.position}-side_${config.side}`,
      config: {
        withArrow: false
      }
    };
  };
}
function getNormalizedConfig(editor) {
  const userConfig = editor.config.get("ui.poweredBy");
  const position = userConfig && userConfig.position || "border";
  return {
    position,
    label: DEFAULT_LABEL,
    verticalOffset: position === "inside" ? 5 : 0,
    horizontalOffset: 5,
    side: editor.locale.contentLanguageDirection === "ltr" ? "right" : "left",
    ...userConfig
  };
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editorui.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EditorUI = class extends ObservableMixin() {
  constructor(editor) {
    super();
    this.isReady = false;
    this._editableElementsMap = new Map();
    this._focusableToolbarDefinitions = [];
    const editingView = editor.editing.view;
    this.editor = editor;
    this.componentFactory = new componentfactory_default(editor);
    this.focusTracker = new focustracker_default();
    this.tooltipManager = new tooltipmanager_default(editor);
    this.poweredBy = new poweredby_default(editor);
    this.set("viewportOffset", this._readViewportOffsetFromConfig());
    this.once("ready", () => {
      this.isReady = true;
    });
    this.listenTo(editingView.document, "layoutChanged", this.update.bind(this));
    this.listenTo(editingView, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
    this._initFocusTracking();
  }
  get element() {
    return null;
  }
  update() {
    this.fire("update");
  }
  destroy() {
    this.stopListening();
    this.focusTracker.destroy();
    this.tooltipManager.destroy(this.editor);
    this.poweredBy.destroy();
    for (const domElement of this._editableElementsMap.values()) {
      domElement.ckeditorInstance = null;
      this.editor.keystrokes.stopListening(domElement);
    }
    this._editableElementsMap = new Map();
    this._focusableToolbarDefinitions = [];
  }
  setEditableElement(rootName, domElement) {
    this._editableElementsMap.set(rootName, domElement);
    if (!domElement.ckeditorInstance) {
      domElement.ckeditorInstance = this.editor;
    }
    this.focusTracker.add(domElement);
    const setUpKeystrokeHandler = () => {
      if (this.editor.editing.view.getDomRoot(rootName)) {
        return;
      }
      this.editor.keystrokes.listenTo(domElement);
    };
    if (this.isReady) {
      setUpKeystrokeHandler();
    } else {
      this.once("ready", setUpKeystrokeHandler);
    }
  }
  removeEditableElement(rootName) {
    const domElement = this._editableElementsMap.get(rootName);
    if (!domElement) {
      return;
    }
    this._editableElementsMap.delete(rootName);
    this.editor.keystrokes.stopListening(domElement);
    this.focusTracker.remove(domElement);
    domElement.ckeditorInstance = null;
  }
  getEditableElement(rootName = "main") {
    return this._editableElementsMap.get(rootName);
  }
  getEditableElementsNames() {
    return this._editableElementsMap.keys();
  }
  addToolbar(toolbarView, options = {}) {
    if (toolbarView.isRendered) {
      this.focusTracker.add(toolbarView.element);
      this.editor.keystrokes.listenTo(toolbarView.element);
    } else {
      toolbarView.once("render", () => {
        this.focusTracker.add(toolbarView.element);
        this.editor.keystrokes.listenTo(toolbarView.element);
      });
    }
    this._focusableToolbarDefinitions.push({toolbarView, options});
  }
  get _editableElements() {
    console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {editorUI: this});
    return this._editableElementsMap;
  }
  _readViewportOffsetFromConfig() {
    const editor = this.editor;
    const viewportOffsetConfig = editor.config.get("ui.viewportOffset");
    if (viewportOffsetConfig) {
      return viewportOffsetConfig;
    }
    const legacyOffsetConfig = editor.config.get("toolbar.viewportTopOffset");
    if (legacyOffsetConfig) {
      console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
      return {top: legacyOffsetConfig};
    }
    return {top: 0};
  }
  _initFocusTracking() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    let lastFocusedForeignElement;
    let candidateDefinitions;
    editor.keystrokes.set("Alt+F10", (data, cancel) => {
      const focusedElement = this.focusTracker.focusedElement;
      if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(editingView.domRoots.values()).includes(focusedElement)) {
        lastFocusedForeignElement = focusedElement;
      }
      const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();
      if (!currentFocusedToolbarDefinition || !candidateDefinitions) {
        candidateDefinitions = this._getFocusableCandidateToolbarDefinitions();
      }
      for (let i = 0; i < candidateDefinitions.length; i++) {
        const candidateDefinition = candidateDefinitions.shift();
        candidateDefinitions.push(candidateDefinition);
        if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {
          if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {
            currentFocusedToolbarDefinition.options.afterBlur();
          }
          break;
        }
      }
      cancel();
    });
    editor.keystrokes.set("Esc", (data, cancel) => {
      const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();
      if (!focusedToolbarDef) {
        return;
      }
      if (lastFocusedForeignElement) {
        lastFocusedForeignElement.focus();
        lastFocusedForeignElement = null;
      } else {
        editor.editing.view.focus();
      }
      if (focusedToolbarDef.options.afterBlur) {
        focusedToolbarDef.options.afterBlur();
      }
      cancel();
    });
  }
  _getFocusableCandidateToolbarDefinitions() {
    const definitions = [];
    for (const toolbarDef of this._focusableToolbarDefinitions) {
      const {toolbarView, options} = toolbarDef;
      if (isVisible(toolbarView.element) || options.beforeFocus) {
        definitions.push(toolbarDef);
      }
    }
    definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));
    return definitions;
  }
  _getCurrentFocusedToolbarDefinition() {
    for (const definition of this._focusableToolbarDefinitions) {
      if (definition.toolbarView.element && definition.toolbarView.element.contains(this.focusTracker.focusedElement)) {
        return definition;
      }
    }
    return null;
  }
  _focusFocusableCandidateToolbar(candidateToolbarDefinition) {
    const {toolbarView, options: {beforeFocus}} = candidateToolbarDefinition;
    if (beforeFocus) {
      beforeFocus();
    }
    if (!isVisible(toolbarView.element)) {
      return false;
    }
    toolbarView.focus();
    return true;
  }
  _handleScrollToTheSelection(evt, data) {
    const configuredViewportOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      ...this.viewportOffset
    };
    data.viewportOffset.top += configuredViewportOffset.top;
    data.viewportOffset.bottom += configuredViewportOffset.bottom;
    data.viewportOffset.left += configuredViewportOffset.left;
    data.viewportOffset.right += configuredViewportOffset.right;
  }
};
var editorui_default = EditorUI;
function getToolbarDefinitionWeight(toolbarDef) {
  const {toolbarView, options} = toolbarDef;
  let weight = 10;
  if (isVisible(toolbarView.element)) {
    weight--;
  }
  if (options.isContextual) {
    weight--;
  }
  return weight;
}

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EditorUIView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.body = new bodycollection_default(locale);
  }
  render() {
    super.render();
    this.body.attachToDom();
  }
  destroy() {
    this.body.detachFromDom();
    return super.destroy();
  }
};
var editoruiview_default = EditorUIView;

// node_modules/@ckeditor/ckeditor5-ui/src/editorui/boxed/boxededitoruiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BoxedEditorUIView = class extends editoruiview_default {
  constructor(locale) {
    super(locale);
    this.top = this.createCollection();
    this.main = this.createCollection();
    this._voiceLabelView = this._createVoiceLabel();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-reset",
          "ck-editor",
          "ck-rounded-corners"
        ],
        role: "application",
        dir: locale.uiLanguageDirection,
        lang: locale.uiLanguage,
        "aria-labelledby": this._voiceLabelView.id
      },
      children: [
        this._voiceLabelView,
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__top",
              "ck-reset_all"
            ],
            role: "presentation"
          },
          children: this.top
        },
        {
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-editor__main"
            ],
            role: "presentation"
          },
          children: this.main
        }
      ]
    });
  }
  _createVoiceLabel() {
    const t = this.t;
    const voiceLabel = new labelview_default();
    voiceLabel.text = t("Rich Text Editor");
    voiceLabel.extendTemplate({
      attributes: {
        class: "ck-voice-label"
      }
    });
    return voiceLabel;
  }
};
var boxededitoruiview_default = BoxedEditorUIView;

// node_modules/@ckeditor/ckeditor5-ui/src/editableui/editableuiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EditableUIView = class extends view_default2 {
  constructor(locale, editingView, editableElement) {
    super(locale);
    this.name = null;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-content",
          "ck-editor__editable",
          "ck-rounded-corners"
        ],
        lang: locale.contentLanguage,
        dir: locale.contentLanguageDirection
      }
    });
    this.set("isFocused", false);
    this._editableElement = editableElement;
    this._hasExternalElement = !!this._editableElement;
    this._editingView = editingView;
  }
  render() {
    super.render();
    if (this._hasExternalElement) {
      this.template.apply(this.element = this._editableElement);
    } else {
      this._editableElement = this.element;
    }
    this.on("change:isFocused", () => this._updateIsFocusedClasses());
    this._updateIsFocusedClasses();
  }
  destroy() {
    if (this._hasExternalElement) {
      this.template.revert(this._editableElement);
    }
    super.destroy();
  }
  get hasExternalElement() {
    return this._hasExternalElement;
  }
  _updateIsFocusedClasses() {
    const editingView = this._editingView;
    if (editingView.isRenderingInProgress) {
      updateAfterRender(this);
    } else {
      update(this);
    }
    function update(view) {
      editingView.change((writer) => {
        const viewRoot = editingView.document.getRoot(view.name);
        writer.addClass(view.isFocused ? "ck-focused" : "ck-blurred", viewRoot);
        writer.removeClass(view.isFocused ? "ck-blurred" : "ck-focused", viewRoot);
      });
    }
    function updateAfterRender(view) {
      editingView.once("change:isRenderingInProgress", (evt, name, value) => {
        if (!value) {
          update(view);
        } else {
          updateAfterRender(view);
        }
      });
    }
  }
};
var editableuiview_default = EditableUIView;

// node_modules/@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InlineEditableUIView = class extends editableuiview_default {
  constructor(locale, editingView, editableElement, options = {}) {
    super(locale, editingView, editableElement);
    const t = locale.t;
    this.extendTemplate({
      attributes: {
        role: "textbox",
        class: "ck-editor__editable_inline"
      }
    });
    this._generateLabel = options.label || (() => t("Editor editing area: %0", this.name));
  }
  render() {
    super.render();
    const editingView = this._editingView;
    editingView.change((writer) => {
      const viewRoot = editingView.document.getRoot(this.name);
      writer.setAttribute("aria-label", this._generateLabel(this), viewRoot);
    });
  }
};
var inlineeditableuiview_default = InlineEditableUIView;

// node_modules/@ckeditor/ckeditor5-ui/src/formheader/formheaderview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var FormHeaderView = class extends view_default2 {
  constructor(locale, options = {}) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("label", options.label || "");
    this.set("class", options.class || null);
    this.children = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-form__header",
          bind.to("class")
        ]
      },
      children: this.children
    });
    if (options.icon) {
      this.iconView = new iconview_default();
      this.iconView.content = options.icon;
      this.children.add(this.iconView);
    }
    const label = new view_default2(locale);
    label.setTemplate({
      tag: "h2",
      attributes: {
        class: [
          "ck",
          "ck-form__header__label"
        ]
      },
      children: [
        {text: bind.to("label")}
      ]
    });
    this.children.add(label);
  }
};
var formheaderview_default = FormHeaderView;

// node_modules/@ckeditor/ckeditor5-ui/src/iframe/iframeview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var IframeView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "iframe",
      attributes: {
        class: [
          "ck",
          "ck-reset_all"
        ],
        sandbox: "allow-same-origin allow-scripts"
      },
      on: {
        load: bind.to("loaded")
      }
    });
  }
  render() {
    return new Promise((resolve) => {
      this.on("loaded", resolve);
      return super.render();
    });
  }
};
var iframeview_default = IframeView;

// node_modules/@ckeditor/ckeditor5-ui/src/notification/notification.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Notification = class extends contextplugin_default {
  static get pluginName() {
    return "Notification";
  }
  init() {
    this.on("show:warning", (evt, data) => {
      window.alert(data.message);
    }, {priority: "lowest"});
  }
  showSuccess(message, data = {}) {
    this._showNotification({
      message,
      type: "success",
      namespace: data.namespace,
      title: data.title
    });
  }
  showInfo(message, data = {}) {
    this._showNotification({
      message,
      type: "info",
      namespace: data.namespace,
      title: data.title
    });
  }
  showWarning(message, data = {}) {
    this._showNotification({
      message,
      type: "warning",
      namespace: data.namespace,
      title: data.title
    });
  }
  _showNotification(data) {
    const event = data.namespace ? `show:${data.type}:${data.namespace}` : `show:${data.type}`;
    this.fire(event, {
      message: data.message,
      type: data.type,
      title: data.title || ""
    });
  }
};
var notification_default = Notification;

// node_modules/@ckeditor/ckeditor5-ui/src/model.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Model2 = class extends ObservableMixin() {
  constructor(attributes, properties) {
    super();
    if (properties) {
      assignIn_default(this, properties);
    }
    if (attributes) {
      this.set(attributes);
    }
  }
};
var model_default2 = Model2;

// node_modules/@ckeditor/ckeditor5-ui/theme/icons/previous-arrow.svg
var previous_arrow_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';

// node_modules/@ckeditor/ckeditor5-ui/theme/icons/next-arrow.svg
var next_arrow_default = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';

// node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var toPx2 = toUnit("px");
var ContextualBalloon = class extends plugin_default {
  static get pluginName() {
    return "ContextualBalloon";
  }
  constructor(editor) {
    super(editor);
    this._viewToStack = new Map();
    this._idToStack = new Map();
    this._view = null;
    this._rotatorView = null;
    this._fakePanelsView = null;
    this.positionLimiter = () => {
      const view = this.editor.editing.view;
      const viewDocument = view.document;
      const editableElement = viewDocument.selection.editableElement;
      if (editableElement) {
        return view.domConverter.mapViewToDom(editableElement.root);
      }
      return null;
    };
    this.set("visibleView", null);
    this.set("_numberOfStacks", 0);
    this.set("_singleViewMode", false);
  }
  destroy() {
    super.destroy();
    if (this._view) {
      this._view.destroy();
    }
    if (this._rotatorView) {
      this._rotatorView.destroy();
    }
    if (this._fakePanelsView) {
      this._fakePanelsView.destroy();
    }
  }
  get view() {
    if (!this._view) {
      this._createPanelView();
    }
    return this._view;
  }
  hasView(view) {
    return Array.from(this._viewToStack.keys()).includes(view);
  }
  add(data) {
    if (!this._view) {
      this._createPanelView();
    }
    if (this.hasView(data.view)) {
      throw new ckeditorerror_default("contextualballoon-add-view-exist", [this, data]);
    }
    const stackId = data.stackId || "main";
    if (!this._idToStack.has(stackId)) {
      this._idToStack.set(stackId, new Map([[data.view, data]]));
      this._viewToStack.set(data.view, this._idToStack.get(stackId));
      this._numberOfStacks = this._idToStack.size;
      if (!this._visibleStack || data.singleViewMode) {
        this.showStack(stackId);
      }
      return;
    }
    const stack = this._idToStack.get(stackId);
    if (data.singleViewMode) {
      this.showStack(stackId);
    }
    stack.set(data.view, data);
    this._viewToStack.set(data.view, stack);
    if (stack === this._visibleStack) {
      this._showView(data);
    }
  }
  remove(view) {
    if (!this.hasView(view)) {
      throw new ckeditorerror_default("contextualballoon-remove-view-not-exist", [this, view]);
    }
    const stack = this._viewToStack.get(view);
    if (this._singleViewMode && this.visibleView === view) {
      this._singleViewMode = false;
    }
    if (this.visibleView === view) {
      if (stack.size === 1) {
        if (this._idToStack.size > 1) {
          this._showNextStack();
        } else {
          this.view.hide();
          this.visibleView = null;
          this._rotatorView.hideView();
        }
      } else {
        this._showView(Array.from(stack.values())[stack.size - 2]);
      }
    }
    if (stack.size === 1) {
      this._idToStack.delete(this._getStackId(stack));
      this._numberOfStacks = this._idToStack.size;
    } else {
      stack.delete(view);
    }
    this._viewToStack.delete(view);
  }
  updatePosition(position) {
    if (position) {
      this._visibleStack.get(this.visibleView).position = position;
    }
    this.view.pin(this._getBalloonPosition());
    this._fakePanelsView.updatePosition();
  }
  showStack(id) {
    this.visibleStack = id;
    const stack = this._idToStack.get(id);
    if (!stack) {
      throw new ckeditorerror_default("contextualballoon-showstack-stack-not-exist", this);
    }
    if (this._visibleStack === stack) {
      return;
    }
    this._showView(Array.from(stack.values()).pop());
  }
  _createPanelView() {
    this._view = new balloonpanelview_default(this.editor.locale);
    this.editor.ui.view.body.add(this._view);
    this.editor.ui.focusTracker.add(this._view.element);
    this._rotatorView = this._createRotatorView();
    this._fakePanelsView = this._createFakePanelsView();
  }
  get _visibleStack() {
    return this._viewToStack.get(this.visibleView);
  }
  _getStackId(stack) {
    const entry = Array.from(this._idToStack.entries()).find((entry2) => entry2[1] === stack);
    return entry[0];
  }
  _showNextStack() {
    const stacks = Array.from(this._idToStack.values());
    let nextIndex = stacks.indexOf(this._visibleStack) + 1;
    if (!stacks[nextIndex]) {
      nextIndex = 0;
    }
    this.showStack(this._getStackId(stacks[nextIndex]));
  }
  _showPrevStack() {
    const stacks = Array.from(this._idToStack.values());
    let nextIndex = stacks.indexOf(this._visibleStack) - 1;
    if (!stacks[nextIndex]) {
      nextIndex = stacks.length - 1;
    }
    this.showStack(this._getStackId(stacks[nextIndex]));
  }
  _createRotatorView() {
    const view = new RotatorView(this.editor.locale);
    const t = this.editor.locale.t;
    this.view.content.add(view);
    view.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (value, isSingleViewMode) => {
      return !isSingleViewMode && value > 1;
    });
    view.on("change:isNavigationVisible", () => this.updatePosition(), {priority: "low"});
    view.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (visibleView, numberOfStacks) => {
      if (numberOfStacks < 2) {
        return "";
      }
      const current = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
      return t("%0 of %1", [current, numberOfStacks]);
    });
    view.buttonNextView.on("execute", () => {
      if (view.focusTracker.isFocused) {
        this.editor.editing.view.focus();
      }
      this._showNextStack();
    });
    view.buttonPrevView.on("execute", () => {
      if (view.focusTracker.isFocused) {
        this.editor.editing.view.focus();
      }
      this._showPrevStack();
    });
    return view;
  }
  _createFakePanelsView() {
    const view = new FakePanelsView(this.editor.locale, this.view);
    view.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (number, isSingleViewMode) => {
      const showPanels = !isSingleViewMode && number >= 2;
      return showPanels ? Math.min(number - 1, 2) : 0;
    });
    view.listenTo(this.view, "change:top", () => view.updatePosition());
    view.listenTo(this.view, "change:left", () => view.updatePosition());
    this.editor.ui.view.body.add(view);
    return view;
  }
  _showView({view, balloonClassName = "", withArrow = true, singleViewMode = false}) {
    this.view.class = balloonClassName;
    this.view.withArrow = withArrow;
    this._rotatorView.showView(view);
    this.visibleView = view;
    this.view.pin(this._getBalloonPosition());
    this._fakePanelsView.updatePosition();
    if (singleViewMode) {
      this._singleViewMode = true;
    }
  }
  _getBalloonPosition() {
    let position = Array.from(this._visibleStack.values()).pop().position;
    if (position) {
      if (!position.limiter) {
        position = Object.assign({}, position, {
          limiter: this.positionLimiter
        });
      }
      position = Object.assign({}, position, {
        viewportOffsetConfig: this.editor.ui.viewportOffset
      });
    }
    return position;
  }
};
var contextualballoon_default = ContextualBalloon;
var RotatorView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const t = locale.t;
    const bind = this.bindTemplate;
    this.set("isNavigationVisible", true);
    this.focusTracker = new focustracker_default();
    this.buttonPrevView = this._createButtonView(t("Previous"), previous_arrow_default);
    this.buttonNextView = this._createButtonView(t("Next"), next_arrow_default);
    this.content = this.createCollection();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-balloon-rotator"
        ],
        "z-index": "-1"
      },
      children: [
        {
          tag: "div",
          attributes: {
            class: [
              "ck-balloon-rotator__navigation",
              bind.to("isNavigationVisible", (value) => value ? "" : "ck-hidden")
            ]
          },
          children: [
            this.buttonPrevView,
            {
              tag: "span",
              attributes: {
                class: [
                  "ck-balloon-rotator__counter"
                ]
              },
              children: [
                {
                  text: bind.to("counter")
                }
              ]
            },
            this.buttonNextView
          ]
        },
        {
          tag: "div",
          attributes: {
            class: "ck-balloon-rotator__content"
          },
          children: this.content
        }
      ]
    });
  }
  render() {
    super.render();
    this.focusTracker.add(this.element);
  }
  destroy() {
    super.destroy();
    this.focusTracker.destroy();
  }
  showView(view) {
    this.hideView();
    this.content.add(view);
  }
  hideView() {
    this.content.clear();
  }
  _createButtonView(label, icon) {
    const view = new buttonview_default(this.locale);
    view.set({
      label,
      icon,
      tooltip: true
    });
    return view;
  }
};
var FakePanelsView = class extends view_default2 {
  constructor(locale, balloonPanelView) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("top", 0);
    this.set("left", 0);
    this.set("height", 0);
    this.set("width", 0);
    this.set("numberOfPanels", 0);
    this.content = this.createCollection();
    this._balloonPanelView = balloonPanelView;
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck-fake-panel",
          bind.to("numberOfPanels", (number) => number ? "" : "ck-hidden")
        ],
        style: {
          top: bind.to("top", toPx2),
          left: bind.to("left", toPx2),
          width: bind.to("width", toPx2),
          height: bind.to("height", toPx2)
        }
      },
      children: this.content
    });
    this.on("change:numberOfPanels", (evt, name, next, prev) => {
      if (next > prev) {
        this._addPanels(next - prev);
      } else {
        this._removePanels(prev - next);
      }
      this.updatePosition();
    });
  }
  _addPanels(number) {
    while (number--) {
      const view = new view_default2();
      view.setTemplate({tag: "div"});
      this.content.add(view);
      this.registerChild(view);
    }
  }
  _removePanels(number) {
    while (number--) {
      const view = this.content.last;
      this.content.remove(view);
      this.deregisterChild(view);
      view.destroy();
    }
  }
  updatePosition() {
    if (this.numberOfPanels) {
      const {top, left} = this._balloonPanelView;
      const {width, height} = new rect_default(this._balloonPanelView.element);
      Object.assign(this, {top, left, width, height});
    }
  }
};

// node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var toPx3 = toUnit("px");
var StickyPanelView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.set("isActive", false);
    this.set("isSticky", false);
    this.set("limiterElement", null);
    this.set("limiterBottomOffset", 50);
    this.set("viewportTopOffset", 0);
    this.set("_marginLeft", null);
    this.set("_isStickyToTheBottomOfLimiter", false);
    this.set("_stickyTopOffset", null);
    this.set("_stickyBottomOffset", null);
    this.content = this.createCollection();
    this._contentPanelPlaceholder = new template_default({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__placeholder"
        ],
        style: {
          display: bind.to("isSticky", (isSticky) => isSticky ? "block" : "none"),
          height: bind.to("isSticky", (isSticky) => {
            return isSticky ? toPx3(this._contentPanelRect.height) : null;
          })
        }
      }
    }).render();
    this._contentPanel = new template_default({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel__content",
          bind.if("isSticky", "ck-sticky-panel__content_sticky"),
          bind.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
        ],
        style: {
          width: bind.to("isSticky", (isSticky) => {
            return isSticky ? toPx3(this._contentPanelPlaceholder.getBoundingClientRect().width) : null;
          }),
          top: bind.to("_stickyTopOffset", (value) => value ? toPx3(value) : value),
          bottom: bind.to("_stickyBottomOffset", (value) => value ? toPx3(value) : value),
          marginLeft: bind.to("_marginLeft")
        }
      },
      children: this.content
    }).render();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-sticky-panel"
        ]
      },
      children: [
        this._contentPanelPlaceholder,
        this._contentPanel
      ]
    });
  }
  render() {
    super.render();
    this.checkIfShouldBeSticky();
    this.listenTo(global_default.document, "scroll", () => {
      this.checkIfShouldBeSticky();
    }, {useCapture: true});
    this.listenTo(this, "change:isActive", () => {
      this.checkIfShouldBeSticky();
    });
  }
  checkIfShouldBeSticky() {
    if (!this.limiterElement || !this.isActive) {
      this._unstick();
      return;
    }
    const limiterRect = new rect_default(this.limiterElement);
    let visibleLimiterRect = limiterRect.getVisible();
    if (visibleLimiterRect) {
      const windowRect = new rect_default(global_default.window);
      windowRect.top += this.viewportTopOffset;
      windowRect.height -= this.viewportTopOffset;
      visibleLimiterRect = visibleLimiterRect.getIntersection(windowRect);
    }
    if (visibleLimiterRect && limiterRect.top < visibleLimiterRect.top) {
      const visibleLimiterTop = visibleLimiterRect.top;
      if (visibleLimiterTop + this._contentPanelRect.height + this.limiterBottomOffset > visibleLimiterRect.bottom) {
        const stickyBottomOffset = Math.max(limiterRect.bottom - visibleLimiterRect.bottom, 0) + this.limiterBottomOffset;
        if (limiterRect.bottom - stickyBottomOffset > limiterRect.top + this._contentPanelRect.height) {
          this._stickToBottomOfLimiter(stickyBottomOffset);
        } else {
          this._unstick();
        }
      } else {
        if (this._contentPanelRect.height + this.limiterBottomOffset < limiterRect.height) {
          this._stickToTopOfAncestors(visibleLimiterTop);
        } else {
          this._unstick();
        }
      }
    } else {
      this._unstick();
    }
  }
  _stickToTopOfAncestors(topOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = topOffset;
    this._stickyBottomOffset = null;
    this._marginLeft = toPx3(-global_default.window.scrollX);
  }
  _stickToBottomOfLimiter(stickyBottomOffset) {
    this.isSticky = true;
    this._isStickyToTheBottomOfLimiter = true;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = stickyBottomOffset;
    this._marginLeft = toPx3(-global_default.window.scrollX);
  }
  _unstick() {
    this.isSticky = false;
    this._isStickyToTheBottomOfLimiter = false;
    this._stickyTopOffset = null;
    this._stickyBottomOffset = null;
    this._marginLeft = null;
  }
  get _contentPanelRect() {
    return new rect_default(this._contentPanel);
  }
};
var stickypanelview_default = StickyPanelView;

// node_modules/@ckeditor/ckeditor5-ui/src/search/text/searchtextqueryview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SearchTextQueryView = class extends labeledfieldview_default {
  constructor(locale, config) {
    const t = locale.t;
    const viewConfig = Object.assign({}, {
      showResetButton: true,
      showIcon: true,
      creator: createLabeledInputText
    }, config);
    super(locale, viewConfig.creator);
    this.label = config.label;
    this._viewConfig = viewConfig;
    if (this._viewConfig.showIcon) {
      this.iconView = new iconview_default();
      this.iconView.content = icons.loupe;
      this.fieldWrapperChildren.add(this.iconView, 0);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-icon"
        }
      });
    }
    if (this._viewConfig.showResetButton) {
      this.resetButtonView = new buttonview_default(locale);
      this.resetButtonView.set({
        label: t("Clear"),
        icon: icons.cancel,
        class: "ck-search__reset",
        isVisible: false,
        tooltip: true
      });
      this.resetButtonView.on("execute", () => {
        this.reset();
        this.focus();
        this.fire("reset");
      });
      this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (isEmpty) => !isEmpty);
      this.fieldWrapperChildren.add(this.resetButtonView);
      this.extendTemplate({
        attributes: {
          class: "ck-search__query_with-reset"
        }
      });
    }
  }
  reset() {
    this.fieldView.reset();
    if (this._viewConfig.showResetButton) {
      this.resetButtonView.isVisible = false;
    }
  }
};
var searchtextqueryview_default = SearchTextQueryView;

// node_modules/@ckeditor/ckeditor5-ui/src/search/searchinfoview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SearchInfoView = class extends view_default2 {
  constructor() {
    super();
    const bind = this.bindTemplate;
    this.set({
      isVisible: false,
      primaryText: "",
      secondaryText: ""
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__info",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ],
        tabindex: -1
      },
      children: [
        {
          tag: "span",
          children: [
            {
              text: [bind.to("primaryText")]
            }
          ]
        },
        {
          tag: "span",
          children: [
            {
              text: [bind.to("secondaryText")]
            }
          ]
        }
      ]
    });
  }
  focus() {
    this.element.focus();
  }
};
var searchinfoview_default = SearchInfoView;

// node_modules/@ckeditor/ckeditor5-ui/src/search/searchresultsview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SearchResultsView = class extends view_default2 {
  constructor(locale) {
    super(locale);
    this.children = this.createCollection();
    this.focusTracker = new focustracker_default();
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search__results"
        ],
        tabindex: -1
      },
      children: this.children
    });
    this._focusCycler = new focuscycler_default({
      focusables: this.children,
      focusTracker: this.focusTracker
    });
  }
  render() {
    super.render();
    for (const child of this.children) {
      this.focusTracker.add(child.element);
    }
  }
  focus() {
    this._focusCycler.focusFirst();
  }
  focusFirst() {
    this._focusCycler.focusFirst();
  }
  focusLast() {
    this._focusCycler.focusLast();
  }
};
var searchresultsview_default = SearchResultsView;

// node_modules/@ckeditor/ckeditor5-ui/src/search/text/searchtextview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SearchTextView = class extends view_default2 {
  constructor(locale, config) {
    super(locale);
    this._config = config;
    this.filteredView = config.filteredView;
    this.queryView = this._createSearchTextQueryView();
    this.focusTracker = new focustracker_default();
    this.keystrokes = new keystrokehandler_default();
    this.resultsView = new searchresultsview_default(locale);
    this.children = this.createCollection();
    this.focusableChildren = this.createCollection([this.queryView, this.resultsView]);
    this.set("isEnabled", true);
    this.set("resultsCount", 0);
    this.set("totalItemsCount", 0);
    if (config.infoView && config.infoView.instance) {
      this.infoView = config.infoView.instance;
    } else {
      this.infoView = new searchinfoview_default();
      this._enableDefaultInfoViewBehavior();
      this.on("render", () => {
        this.search("");
      });
    }
    this.resultsView.children.addMany([this.infoView, this.filteredView]);
    this.focusCycler = new focuscycler_default({
      focusables: this.focusableChildren,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: "shift + tab",
        focusNext: "tab"
      }
    });
    this.on("search", (evt, {resultsCount, totalItemsCount}) => {
      this.resultsCount = resultsCount;
      this.totalItemsCount = totalItemsCount;
    });
    this.setTemplate({
      tag: "div",
      attributes: {
        class: [
          "ck",
          "ck-search",
          config.class || null
        ],
        tabindex: "-1"
      },
      children: this.children
    });
  }
  render() {
    super.render();
    this.children.addMany([
      this.queryView,
      this.resultsView
    ]);
    const stopPropagation = (data) => data.stopPropagation();
    for (const focusableChild of this.focusableChildren) {
      this.focusTracker.add(focusableChild.element);
    }
    this.keystrokes.listenTo(this.element);
    this.keystrokes.set("arrowright", stopPropagation);
    this.keystrokes.set("arrowleft", stopPropagation);
    this.keystrokes.set("arrowup", stopPropagation);
    this.keystrokes.set("arrowdown", stopPropagation);
  }
  focus() {
    this.queryView.focus();
  }
  reset() {
    this.queryView.reset();
    this.search("");
  }
  search(query) {
    const regExp = query ? new RegExp(escapeRegExp_default(query), "ig") : null;
    const filteringResults = this.filteredView.filter(regExp);
    this.fire("search", {query, ...filteringResults});
  }
  _createSearchTextQueryView() {
    const queryView = new searchtextqueryview_default(this.locale, this._config.queryView);
    this.listenTo(queryView.fieldView, "input", () => {
      this.search(queryView.fieldView.element.value);
    });
    queryView.on("reset", () => this.reset());
    queryView.bind("isEnabled").to(this);
    return queryView;
  }
  _enableDefaultInfoViewBehavior() {
    const t = this.locale.t;
    const infoView = this.infoView;
    this.on("search", (evt, data) => {
      if (!data.resultsCount) {
        const defaultTextConfig = this._config.infoView && this._config.infoView.text;
        let primaryText, secondaryText;
        if (data.totalItemsCount) {
          if (defaultTextConfig && defaultTextConfig.notFound) {
            primaryText = defaultTextConfig.notFound.primary;
            secondaryText = defaultTextConfig.notFound.secondary;
          } else {
            primaryText = t("No results found");
            secondaryText = "";
          }
        } else {
          if (defaultTextConfig && defaultTextConfig.noSearchableItems) {
            primaryText = defaultTextConfig.noSearchableItems.primary;
            secondaryText = defaultTextConfig.noSearchableItems.secondary;
          } else {
            primaryText = t("No searchable items");
            secondaryText = "";
          }
        }
        infoView.set({
          primaryText: normalizeInfoText(primaryText, data),
          secondaryText: normalizeInfoText(secondaryText, data),
          isVisible: true
        });
      } else {
        infoView.set({
          isVisible: false
        });
      }
    });
    function normalizeInfoText(text, {query, resultsCount, totalItemsCount}) {
      return typeof text === "function" ? text(query, resultsCount, totalItemsCount) : text;
    }
  }
};
var searchtextview_default = SearchTextView;

// node_modules/@ckeditor/ckeditor5-ui/src/autocomplete/autocompleteview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var AutocompleteView = class extends searchtextview_default {
  constructor(locale, config) {
    super(locale, config);
    this._config = config;
    const toPx8 = toUnit("px");
    this.extendTemplate({
      attributes: {
        class: ["ck-autocomplete"]
      }
    });
    const bindResultsView = this.resultsView.bindTemplate;
    this.resultsView.set("isVisible", false);
    this.resultsView.set("_position", "s");
    this.resultsView.set("_width", 0);
    this.resultsView.extendTemplate({
      attributes: {
        class: [
          bindResultsView.if("isVisible", "ck-hidden", (value) => !value),
          bindResultsView.to("_position", (value) => `ck-search__results_${value}`)
        ],
        style: {
          width: bindResultsView.to("_width", toPx8)
        }
      }
    });
    this.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
      this._updateResultsVisibility();
      if (isFocused) {
        this.resultsView.element.scrollTop = 0;
      } else if (config.resetOnBlur) {
        this.queryView.reset();
      }
    });
    this.on("search", () => {
      this._updateResultsVisibility();
      this._updateResultsViewWidthAndPosition();
    });
    this.keystrokes.set("esc", (evt, cancel) => {
      this.resultsView.isVisible = false;
      cancel();
    });
    this.listenTo(global_default.document, "scroll", () => {
      this._updateResultsViewWidthAndPosition();
    });
    this.on("change:isEnabled", () => {
      this._updateResultsVisibility();
    });
    this.filteredView.on("execute", (evt, {value}) => {
      this.focus();
      this.reset();
      this.queryView.fieldView.value = this.queryView.fieldView.element.value = value;
      this.resultsView.isVisible = false;
    });
    this.resultsView.on("change:isVisible", () => {
      this._updateResultsViewWidthAndPosition();
    });
  }
  _updateResultsViewWidthAndPosition() {
    if (!this.resultsView.isVisible) {
      return;
    }
    this.resultsView._width = new rect_default(this.queryView.fieldView.element).width;
    const optimalResultsPosition = AutocompleteView._getOptimalPosition({
      element: this.resultsView.element,
      target: this.queryView.element,
      fitInViewport: true,
      positions: AutocompleteView.defaultResultsPositions
    });
    this.resultsView._position = optimalResultsPosition ? optimalResultsPosition.name : "s";
  }
  _updateResultsVisibility() {
    const queryMinChars = typeof this._config.queryMinChars === "undefined" ? 0 : this._config.queryMinChars;
    const queryLength = this.queryView.fieldView.element.value.length;
    this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && queryLength >= queryMinChars;
  }
};
var autocompleteview_default = AutocompleteView;
AutocompleteView.defaultResultsPositions = [
  (fieldRect) => {
    return {
      top: fieldRect.bottom,
      left: fieldRect.left,
      name: "s"
    };
  },
  (fieldRect, resultsRect) => {
    return {
      top: fieldRect.top - resultsRect.height,
      left: fieldRect.left,
      name: "n"
    };
  }
];
AutocompleteView._getOptimalPosition = getOptimalPosition;

// node_modules/@ckeditor/ckeditor5-ui/src/highlightedtext/highlightedtextview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var HighlightedTextView = class extends view_default2 {
  constructor() {
    super();
    this.set("text", void 0);
    this.setTemplate({
      tag: "span",
      attributes: {
        class: ["ck", "ck-highlighted-text"]
      }
    });
    this.on("render", () => {
      this.on("change:text", () => {
        this._updateInnerHTML(this.text);
      });
      this._updateInnerHTML(this.text);
    });
  }
  highlightText(regExp) {
    this._updateInnerHTML(markText(this.text || "", regExp));
  }
  _updateInnerHTML(newInnerHTML) {
    this.element.innerHTML = newInnerHTML || "";
  }
};
var highlightedtextview_default = HighlightedTextView;
function markText(text, regExp) {
  if (!regExp) {
    return escape_default(text);
  }
  const textParts = [];
  let lastMatchEnd = 0;
  let matchInfo = regExp.exec(text);
  while (matchInfo !== null) {
    const curMatchStart = matchInfo.index;
    if (curMatchStart !== lastMatchEnd) {
      textParts.push({
        text: text.substring(lastMatchEnd, curMatchStart),
        isMatch: false
      });
    }
    textParts.push({
      text: matchInfo[0],
      isMatch: true
    });
    lastMatchEnd = regExp.lastIndex;
    matchInfo = regExp.exec(text);
  }
  if (lastMatchEnd !== text.length) {
    textParts.push({
      text: text.substring(lastMatchEnd),
      isMatch: false
    });
  }
  const outputHtml = textParts.map((part) => {
    part.text = escape_default(part.text);
    return part;
  }).map((part) => part.isMatch ? `<mark>${part.text}</mark>` : part.text).join("");
  return outputHtml;
}

// node_modules/@ckeditor/ckeditor5-ui/src/spinner/spinnerview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var SpinnerView = class extends view_default2 {
  constructor() {
    super();
    this.set("isVisible", false);
    const bind = this.bindTemplate;
    this.setTemplate({
      tag: "span",
      attributes: {
        class: [
          "ck",
          "ck-spinner-container",
          bind.if("isVisible", "ck-hidden", (value) => !value)
        ]
      },
      children: [{
        tag: "span",
        attributes: {
          class: ["ck", "ck-spinner"]
        }
      }]
    });
  }
};
var spinnerview_default = SpinnerView;

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/balloon/balloontoolbar.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var toPx4 = toUnit("px");
var BalloonToolbar = class extends plugin_default {
  static get pluginName() {
    return "BalloonToolbar";
  }
  static get requires() {
    return [contextualballoon_default];
  }
  constructor(editor) {
    super(editor);
    this._resizeObserver = null;
    this._balloonConfig = normalizeToolbarConfig(editor.config.get("balloonToolbar"));
    this.toolbarView = this._createToolbarView();
    this.focusTracker = new focustracker_default();
    editor.ui.once("ready", () => {
      this.focusTracker.add(editor.ui.getEditableElement());
      this.focusTracker.add(this.toolbarView.element);
    });
    editor.ui.addToolbar(this.toolbarView, {
      beforeFocus: () => this.show(true),
      afterBlur: () => this.hide(),
      isContextual: true
    });
    this._balloon = editor.plugins.get(contextualballoon_default);
    this._fireSelectionChangeDebounced = debounce_default(() => this.fire("_selectionChangeDebounced"), 200);
    this.decorate("show");
  }
  init() {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    this.listenTo(this.focusTracker, "change:isFocused", (evt, name, isFocused) => {
      const isToolbarVisible = this._balloon.visibleView === this.toolbarView;
      if (!isFocused && isToolbarVisible) {
        this.hide();
      } else if (isFocused) {
        this.show();
      }
    });
    this.listenTo(selection, "change:range", (evt, data) => {
      if (data.directChange || selection.isCollapsed) {
        this.hide();
      }
      this._fireSelectionChangeDebounced();
    });
    this.listenTo(this, "_selectionChangeDebounced", () => {
      if (this.editor.editing.view.document.isFocused) {
        this.show();
      }
    });
    if (!this._balloonConfig.shouldNotGroupWhenFull) {
      this.listenTo(editor, "ready", () => {
        const editableElement = editor.ui.view.editable.element;
        this._resizeObserver = new resizeobserver_default(editableElement, (entry) => {
          this.toolbarView.maxWidth = toPx4(entry.contentRect.width * 0.9);
        });
      });
    }
    this.listenTo(this.toolbarView, "groupedItemsUpdate", () => {
      this._updatePosition();
    });
  }
  afterInit() {
    const factory = this.editor.ui.componentFactory;
    this.toolbarView.fillFromConfig(this._balloonConfig, factory);
  }
  _createToolbarView() {
    const t = this.editor.locale.t;
    const shouldGroupWhenFull = !this._balloonConfig.shouldNotGroupWhenFull;
    const toolbarView = new toolbarview_default(this.editor.locale, {
      shouldGroupWhenFull,
      isFloating: true
    });
    toolbarView.ariaLabel = t("Editor contextual toolbar");
    toolbarView.render();
    return toolbarView;
  }
  show(showForCollapsedSelection = false) {
    const editor = this.editor;
    const selection = editor.model.document.selection;
    const schema = editor.model.schema;
    if (this._balloon.hasView(this.toolbarView)) {
      return;
    }
    if (selection.isCollapsed && !showForCollapsedSelection) {
      return;
    }
    if (selectionContainsOnlyMultipleSelectables(selection, schema)) {
      return;
    }
    if (Array.from(this.toolbarView.items).every((item) => item.isEnabled !== void 0 && !item.isEnabled)) {
      return;
    }
    this.listenTo(this.editor.ui, "update", () => {
      this._updatePosition();
    });
    this._balloon.add({
      view: this.toolbarView,
      position: this._getBalloonPositionData(),
      balloonClassName: "ck-toolbar-container"
    });
  }
  hide() {
    if (this._balloon.hasView(this.toolbarView)) {
      this.stopListening(this.editor.ui, "update");
      this._balloon.remove(this.toolbarView);
    }
  }
  _getBalloonPositionData() {
    const editor = this.editor;
    const view = editor.editing.view;
    const viewDocument = view.document;
    const viewSelection = viewDocument.selection;
    const isBackward = viewDocument.selection.isBackward;
    return {
      target: () => {
        const range = isBackward ? viewSelection.getFirstRange() : viewSelection.getLastRange();
        const rangeRects = rect_default.getDomRangeRects(view.domConverter.viewRangeToDom(range));
        if (isBackward) {
          return rangeRects[0];
        } else {
          if (rangeRects.length > 1 && rangeRects[rangeRects.length - 1].width === 0) {
            rangeRects.pop();
          }
          return rangeRects[rangeRects.length - 1];
        }
      },
      positions: this._getBalloonPositions(isBackward)
    };
  }
  _updatePosition() {
    this._balloon.updatePosition(this._getBalloonPositionData());
  }
  destroy() {
    super.destroy();
    this.stopListening();
    this._fireSelectionChangeDebounced.cancel();
    this.toolbarView.destroy();
    this.focusTracker.destroy();
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  _getBalloonPositions(isBackward) {
    const isSafariIniOS = env_default.isSafari && env_default.isiOS;
    const positions = isSafariIniOS ? generatePositions({
      heightOffset: Math.max(balloonpanelview_default.arrowHeightOffset, Math.round(20 / global_default.window.visualViewport.scale))
    }) : balloonpanelview_default.defaultPositions;
    return isBackward ? [
      positions.northWestArrowSouth,
      positions.northWestArrowSouthWest,
      positions.northWestArrowSouthEast,
      positions.northWestArrowSouthMiddleEast,
      positions.northWestArrowSouthMiddleWest,
      positions.southWestArrowNorth,
      positions.southWestArrowNorthWest,
      positions.southWestArrowNorthEast,
      positions.southWestArrowNorthMiddleWest,
      positions.southWestArrowNorthMiddleEast
    ] : [
      positions.southEastArrowNorth,
      positions.southEastArrowNorthEast,
      positions.southEastArrowNorthWest,
      positions.southEastArrowNorthMiddleEast,
      positions.southEastArrowNorthMiddleWest,
      positions.northEastArrowSouth,
      positions.northEastArrowSouthEast,
      positions.northEastArrowSouthWest,
      positions.northEastArrowSouthMiddleEast,
      positions.northEastArrowSouthMiddleWest
    ];
  }
};
var balloontoolbar_default = BalloonToolbar;
function selectionContainsOnlyMultipleSelectables(selection, schema) {
  if (selection.rangeCount === 1) {
    return false;
  }
  return [...selection.getRanges()].every((range) => {
    const element = range.getContainedElement();
    return element && schema.isSelectable(element);
  });
}

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blockbuttonview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var toPx5 = toUnit("px");
var BlockButtonView = class extends buttonview_default {
  constructor(locale) {
    super(locale);
    const bind = this.bindTemplate;
    this.isVisible = false;
    this.isToggleable = true;
    this.set("top", 0);
    this.set("left", 0);
    this.extendTemplate({
      attributes: {
        class: "ck-block-toolbar-button",
        style: {
          top: bind.to("top", (val) => toPx5(val)),
          left: bind.to("left", (val) => toPx5(val))
        }
      }
    });
  }
};
var blockbuttonview_default = BlockButtonView;

// node_modules/@ckeditor/ckeditor5-ui/src/toolbar/block/blocktoolbar.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var toPx6 = toUnit("px");
var BlockToolbar = class extends plugin_default {
  static get pluginName() {
    return "BlockToolbar";
  }
  constructor(editor) {
    super(editor);
    this._resizeObserver = null;
    this._blockToolbarConfig = normalizeToolbarConfig(this.editor.config.get("blockToolbar"));
    this.toolbarView = this._createToolbarView();
    this.panelView = this._createPanelView();
    this.buttonView = this._createButtonView();
    clickOutsideHandler({
      emitter: this.panelView,
      contextElements: [this.panelView.element, this.buttonView.element],
      activator: () => this.panelView.isVisible,
      callback: () => this._hidePanel()
    });
  }
  init() {
    const editor = this.editor;
    const t = editor.t;
    const editBlockText = t("Click to edit block");
    const dragToMoveText = t("Drag to move");
    const editBlockLabel = t("Edit block");
    const isDragDropBlockToolbarPluginLoaded = editor.plugins.has("DragDropBlockToolbar");
    const label = isDragDropBlockToolbarPluginLoaded ? `${editBlockText}
${dragToMoveText}` : editBlockLabel;
    this.buttonView.label = label;
    if (isDragDropBlockToolbarPluginLoaded) {
      this.buttonView.element.dataset.ckeTooltipClass = "ck-tooltip_multi-line";
    }
    this.listenTo(editor.model.document.selection, "change:range", (evt, data) => {
      if (data.directChange) {
        this._hidePanel();
      }
    });
    this.listenTo(editor.ui, "update", () => this._updateButton());
    this.listenTo(editor, "change:isReadOnly", () => this._updateButton(), {priority: "low"});
    this.listenTo(editor.ui.focusTracker, "change:isFocused", () => this._updateButton());
    this.listenTo(this.buttonView, "change:isVisible", (evt, name, isVisible2) => {
      if (isVisible2) {
        this.buttonView.listenTo(window, "resize", () => this._updateButton());
      } else {
        this.buttonView.stopListening(window, "resize");
        this._hidePanel();
      }
    });
    editor.ui.addToolbar(this.toolbarView, {
      beforeFocus: () => this._showPanel(),
      afterBlur: () => this._hidePanel()
    });
  }
  afterInit() {
    this.toolbarView.fillFromConfig(this._blockToolbarConfig, this.editor.ui.componentFactory);
    for (const item of this.toolbarView.items) {
      item.on("execute", () => this._hidePanel(true), {priority: "high"});
    }
  }
  destroy() {
    super.destroy();
    this.panelView.destroy();
    this.buttonView.destroy();
    this.toolbarView.destroy();
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  _createToolbarView() {
    const t = this.editor.locale.t;
    const shouldGroupWhenFull = !this._blockToolbarConfig.shouldNotGroupWhenFull;
    const toolbarView = new toolbarview_default(this.editor.locale, {
      shouldGroupWhenFull,
      isFloating: true
    });
    toolbarView.ariaLabel = t("Editor block content toolbar");
    return toolbarView;
  }
  _createPanelView() {
    const editor = this.editor;
    const panelView = new balloonpanelview_default(editor.locale);
    panelView.content.add(this.toolbarView);
    panelView.class = "ck-toolbar-container";
    editor.ui.view.body.add(panelView);
    editor.ui.focusTracker.add(panelView.element);
    this.toolbarView.keystrokes.set("Esc", (evt, cancel) => {
      this._hidePanel(true);
      cancel();
    });
    return panelView;
  }
  _createButtonView() {
    const editor = this.editor;
    const t = editor.t;
    const buttonView = new blockbuttonview_default(editor.locale);
    const iconFromConfig = this._blockToolbarConfig.icon;
    const icon = NESTED_TOOLBAR_ICONS[iconFromConfig] || iconFromConfig || NESTED_TOOLBAR_ICONS.dragIndicator;
    buttonView.set({
      label: t("Edit block"),
      icon,
      withText: false
    });
    buttonView.bind("isOn").to(this.panelView, "isVisible");
    buttonView.bind("tooltip").to(this.panelView, "isVisible", (isVisible2) => !isVisible2);
    this.listenTo(buttonView, "execute", () => {
      if (!this.panelView.isVisible) {
        this._showPanel();
      } else {
        this._hidePanel(true);
      }
    });
    editor.ui.view.body.add(buttonView);
    editor.ui.focusTracker.add(buttonView.element);
    return buttonView;
  }
  _updateButton() {
    const editor = this.editor;
    const model = editor.model;
    const view = editor.editing.view;
    if (!editor.ui.focusTracker.isFocused) {
      this._hideButton();
      return;
    }
    if (!editor.model.canEditAt(editor.model.document.selection)) {
      this._hideButton();
      return;
    }
    const modelTarget = Array.from(model.document.selection.getSelectedBlocks())[0];
    if (!modelTarget || Array.from(this.toolbarView.items).every((item) => !item.isEnabled)) {
      this._hideButton();
      return;
    }
    const domTarget = view.domConverter.mapViewToDom(editor.editing.mapper.toViewElement(modelTarget));
    this.buttonView.isVisible = true;
    this._setupToolbarResize();
    this._attachButtonToElement(domTarget);
    if (this.panelView.isVisible) {
      this._showPanel();
    }
  }
  _hideButton() {
    this.buttonView.isVisible = false;
  }
  _showPanel() {
    if (!this.buttonView.isVisible) {
      return;
    }
    const wasVisible = this.panelView.isVisible;
    this.panelView.show();
    const editableElement = this._getSelectedEditableElement();
    this.toolbarView.maxWidth = this._getToolbarMaxWidth(editableElement);
    this.panelView.pin({
      target: this.buttonView.element,
      limiter: editableElement
    });
    if (!wasVisible) {
      this.toolbarView.items.get(0).focus();
    }
  }
  _getSelectedEditableElement() {
    const selectedModelRootName = this.editor.model.document.selection.getFirstRange().root.rootName;
    return this.editor.ui.getEditableElement(selectedModelRootName);
  }
  _hidePanel(focusEditable) {
    this.panelView.isVisible = false;
    if (focusEditable) {
      this.editor.editing.view.focus();
    }
  }
  _attachButtonToElement(targetElement) {
    const contentStyles = window.getComputedStyle(targetElement);
    const editableRect = new rect_default(this._getSelectedEditableElement());
    const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
    const contentLineHeight = parseInt(contentStyles.lineHeight, 10) || parseInt(contentStyles.fontSize, 10) * 1.2;
    const buttonRect = new rect_default(this.buttonView.element);
    const contentRect = new rect_default(targetElement);
    let positionLeft;
    if (this.editor.locale.uiLanguageDirection === "ltr") {
      positionLeft = editableRect.left - buttonRect.width;
    } else {
      positionLeft = editableRect.right;
    }
    const positionTop = contentRect.top + contentPaddingTop + (contentLineHeight - buttonRect.height) / 2;
    buttonRect.moveTo(positionLeft, positionTop);
    const absoluteButtonRect = buttonRect.toAbsoluteRect();
    this.buttonView.top = absoluteButtonRect.top;
    this.buttonView.left = absoluteButtonRect.left;
  }
  _setupToolbarResize() {
    const editableElement = this._getSelectedEditableElement();
    if (!this._blockToolbarConfig.shouldNotGroupWhenFull) {
      if (this._resizeObserver && this._resizeObserver.element !== editableElement) {
        this._resizeObserver.destroy();
        this._resizeObserver = null;
      }
      if (!this._resizeObserver) {
        this._resizeObserver = new resizeobserver_default(editableElement, () => {
          this.toolbarView.maxWidth = this._getToolbarMaxWidth(editableElement);
        });
      }
    }
  }
  _getToolbarMaxWidth(editableElement) {
    const editableRect = new rect_default(editableElement);
    const buttonRect = new rect_default(this.buttonView.element);
    const isRTL = this.editor.locale.uiLanguageDirection === "rtl";
    const offset = isRTL ? buttonRect.left - editableRect.right + buttonRect.width : editableRect.left - buttonRect.left;
    return toPx6(editableRect.width + offset);
  }
};
var blocktoolbar_default = BlockToolbar;

// node_modules/@ckeditor/ckeditor5-ui/src/augmentation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-ui/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/ckeditor5/src/ui.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/ckeditor5/src/engine.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/ckeditor5/src/utils.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditorui.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ClassicEditorUI = class extends editorui_default {
  constructor(editor, view) {
    super(editor);
    this.view = view;
    this._toolbarConfig = normalizeToolbarConfig(editor.config.get("toolbar"));
    this._elementReplacer = new elementreplacer_default();
    this.listenTo(editor.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
  }
  get element() {
    return this.view.element;
  }
  init(replacementElement) {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    view.editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    if (replacementElement) {
      this._elementReplacer.replace(replacementElement, this.element);
    }
    this._initPlaceholder();
    this._initToolbar();
    this.fire("ready");
  }
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    this._elementReplacer.restore();
    editingView.detachDomRoot(view.editable.name);
    view.destroy();
  }
  _initToolbar() {
    const view = this.view;
    view.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
    view.stickyPanel.limiterElement = view.element;
    view.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({top}) => top || 0);
    view.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const sourceElement = editor.sourceElement;
    let placeholderText;
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      placeholderText = typeof placeholder === "string" ? placeholder : placeholder[this.view.editable.name];
    }
    if (!placeholderText && sourceElement && sourceElement.tagName.toLowerCase() === "textarea") {
      placeholderText = sourceElement.getAttribute("placeholder");
    }
    if (placeholderText) {
      editingRoot.placeholder = placeholderText;
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
  _handleScrollToTheSelectionWithStickyPanel(evt, data, originalArgs) {
    const stickyPanel = this.view.stickyPanel;
    if (stickyPanel.isSticky) {
      const stickyPanelHeight = new rect_default(stickyPanel.element).height;
      data.viewportOffset.top += stickyPanelHeight;
    } else {
      const scrollViewportOnPanelGettingSticky = () => {
        this.editor.editing.view.scrollToTheSelection(originalArgs);
      };
      this.listenTo(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      setTimeout(() => {
        this.stopListening(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
      }, 20);
    }
  }
};
var classiceditorui_default = ClassicEditorUI;

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditoruiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ClassicEditorUIView = class extends boxededitoruiview_default {
  constructor(locale, editingView, options = {}) {
    super(locale);
    this.stickyPanel = new stickypanelview_default(locale);
    this.toolbar = new toolbarview_default(locale, {
      shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
    });
    this.editable = new inlineeditableuiview_default(locale, editingView);
  }
  render() {
    super.render();
    this.stickyPanel.content.add(this.toolbar);
    this.top.add(this.stickyPanel);
    this.main.add(this.editable);
  }
};
var classiceditoruiview_default = ClassicEditorUIView;

// node_modules/ckeditor5/src/core.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-watchdog/src/watchdog.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var Watchdog = class {
  constructor(config) {
    this.crashes = [];
    this.state = "initializing";
    this._now = Date.now;
    this.crashes = [];
    this._crashNumberLimit = typeof config.crashNumberLimit === "number" ? config.crashNumberLimit : 3;
    this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === "number" ? config.minimumNonErrorTimePeriod : 5e3;
    this._boundErrorHandler = (evt) => {
      const error = "error" in evt ? evt.error : evt.reason;
      if (error instanceof Error) {
        this._handleError(error, evt);
      }
    };
    this._listeners = {};
    if (!this._restart) {
      throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
    }
  }
  destroy() {
    this._stopErrorHandling();
    this._listeners = {};
  }
  on(eventName, callback) {
    if (!this._listeners[eventName]) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push(callback);
  }
  off(eventName, callback) {
    this._listeners[eventName] = this._listeners[eventName].filter((cb) => cb !== callback);
  }
  _fire(eventName, ...args) {
    const callbacks = this._listeners[eventName] || [];
    for (const callback of callbacks) {
      callback.apply(this, [null, ...args]);
    }
  }
  _startErrorHandling() {
    window.addEventListener("error", this._boundErrorHandler);
    window.addEventListener("unhandledrejection", this._boundErrorHandler);
  }
  _stopErrorHandling() {
    window.removeEventListener("error", this._boundErrorHandler);
    window.removeEventListener("unhandledrejection", this._boundErrorHandler);
  }
  _handleError(error, evt) {
    if (this._shouldReactToError(error)) {
      this.crashes.push({
        message: error.message,
        stack: error.stack,
        filename: evt instanceof ErrorEvent ? evt.filename : void 0,
        lineno: evt instanceof ErrorEvent ? evt.lineno : void 0,
        colno: evt instanceof ErrorEvent ? evt.colno : void 0,
        date: this._now()
      });
      const causesRestart = this._shouldRestart();
      this.state = "crashed";
      this._fire("stateChange");
      this._fire("error", {error, causesRestart});
      if (causesRestart) {
        this._restart();
      } else {
        this.state = "crashedPermanently";
        this._fire("stateChange");
      }
    }
  }
  _shouldReactToError(error) {
    return error.is && error.is("CKEditorError") && error.context !== void 0 && error.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(error);
  }
  _shouldRestart() {
    if (this.crashes.length <= this._crashNumberLimit) {
      return true;
    }
    const lastErrorTime = this.crashes[this.crashes.length - 1].date;
    const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
    const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;
    return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;
  }
};
var watchdog_default = Watchdog;

// node_modules/@ckeditor/ckeditor5-watchdog/src/utils/getsubnodes.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function getSubNodes(head, excludedProperties = new Set()) {
  const nodes = [head];
  const subNodes = new Set();
  let nodeIndex = 0;
  while (nodes.length > nodeIndex) {
    const node = nodes[nodeIndex++];
    if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {
      continue;
    }
    subNodes.add(node);
    if (Symbol.iterator in node) {
      try {
        for (const n of node) {
          nodes.push(n);
        }
      } catch (err) {
      }
    } else {
      for (const key in node) {
        if (key === "defaultValue") {
          continue;
        }
        nodes.push(node[key]);
      }
    }
  }
  return subNodes;
}
function shouldNodeBeIncluded(node) {
  const type = Object.prototype.toString.call(node);
  const typeOfNode = typeof node;
  return !(typeOfNode === "number" || typeOfNode === "boolean" || typeOfNode === "string" || typeOfNode === "symbol" || typeOfNode === "function" || type === "[object Date]" || type === "[object RegExp]" || type === "[object Module]" || node === void 0 || node === null || node._watchdogExcluded || node instanceof EventTarget || node instanceof Event);
}

// node_modules/@ckeditor/ckeditor5-watchdog/src/utils/areconnectedthroughproperties.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
function areConnectedThroughProperties(target1, target2, excludedNodes = new Set()) {
  if (target1 === target2 && isObject2(target1)) {
    return true;
  }
  const subNodes1 = getSubNodes(target1, excludedNodes);
  const subNodes2 = getSubNodes(target2, excludedNodes);
  for (const node of subNodes1) {
    if (subNodes2.has(node)) {
      return true;
    }
  }
  return false;
}
/* istanbul ignore next -- @preserve */
function isObject2(structure) {
  return typeof structure === "object" && structure !== null;
}

// node_modules/@ckeditor/ckeditor5-watchdog/src/editorwatchdog.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var EditorWatchdog = class extends watchdog_default {
  constructor(Editor2, watchdogConfig = {}) {
    super(watchdogConfig);
    this._editor = null;
    this._initUsingData = true;
    this._editables = {};
    this._throttledSave = throttle_default(this._save.bind(this), typeof watchdogConfig.saveInterval === "number" ? watchdogConfig.saveInterval : 5e3);
    if (Editor2) {
      this._creator = (elementOrData, config) => Editor2.create(elementOrData, config);
    }
    this._destructor = (editor) => editor.destroy();
  }
  get editor() {
    return this._editor;
  }
  get _item() {
    return this._editor;
  }
  setCreator(creator) {
    this._creator = creator;
  }
  setDestructor(destructor) {
    this._destructor = destructor;
  }
  _restart() {
    return Promise.resolve().then(() => {
      this.state = "initializing";
      this._fire("stateChange");
      return this._destroy();
    }).catch((err) => {
      console.error("An error happened during the editor destroying.", err);
    }).then(() => {
      const existingRoots = {};
      const lazyRoots = [];
      const oldRootsAttributes = this._config.rootsAttributes || {};
      const rootsAttributes = {};
      for (const [rootName, rootData] of Object.entries(this._data.roots)) {
        if (rootData.isLoaded) {
          existingRoots[rootName] = "";
          rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};
        } else {
          lazyRoots.push(rootName);
        }
      }
      const updatedConfig = {
        ...this._config,
        extraPlugins: this._config.extraPlugins || [],
        lazyRoots,
        rootsAttributes,
        _watchdogInitialData: this._data
      };
      delete updatedConfig.initialData;
      updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);
      if (this._initUsingData) {
        return this.create(existingRoots, updatedConfig, updatedConfig.context);
      } else {
        if (isElement_default(this._elementOrData)) {
          return this.create(this._elementOrData, updatedConfig, updatedConfig.context);
        } else {
          return this.create(this._editables, updatedConfig, updatedConfig.context);
        }
      }
    }).then(() => {
      this._fire("restart");
    });
  }
  create(elementOrData = this._elementOrData, config = this._config, context) {
    return Promise.resolve().then(() => {
      super._startErrorHandling();
      this._elementOrData = elementOrData;
      this._initUsingData = typeof elementOrData == "string" || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == "string";
      this._config = this._cloneEditorConfiguration(config) || {};
      this._config.context = context;
      return this._creator(elementOrData, this._config);
    }).then((editor) => {
      this._editor = editor;
      editor.model.document.on("change:data", this._throttledSave);
      this._lastDocumentVersion = editor.model.document.version;
      this._data = this._getData();
      if (!this._initUsingData) {
        this._editables = this._getEditables();
      }
      this.state = "ready";
      this._fire("stateChange");
    });
  }
  destroy() {
    return Promise.resolve().then(() => {
      this.state = "destroyed";
      this._fire("stateChange");
      super.destroy();
      return this._destroy();
    });
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      this._throttledSave.cancel();
      const editor = this._editor;
      this._editor = null;
      editor.model.document.off("change:data", this._throttledSave);
      return this._destructor(editor);
    });
  }
  _save() {
    const version2 = this._editor.model.document.version;
    try {
      this._data = this._getData();
      if (!this._initUsingData) {
        this._editables = this._getEditables();
      }
      this._lastDocumentVersion = version2;
    } catch (err) {
      console.error(err, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
    }
  }
  _setExcludedProperties(props) {
    this._excludedProps = props;
  }
  _getData() {
    const editor = this._editor;
    const roots = editor.model.document.roots.filter((root2) => root2.isAttached() && root2.rootName != "$graveyard");
    const {plugins} = editor;
    const commentsRepository = plugins.has("CommentsRepository") && plugins.get("CommentsRepository");
    const trackChanges = plugins.has("TrackChanges") && plugins.get("TrackChanges");
    const data = {
      roots: {},
      markers: {},
      commentThreads: JSON.stringify([]),
      suggestions: JSON.stringify([])
    };
    roots.forEach((root2) => {
      data.roots[root2.rootName] = {
        content: JSON.stringify(Array.from(root2.getChildren())),
        attributes: JSON.stringify(Array.from(root2.getAttributes())),
        isLoaded: root2._isLoaded
      };
    });
    for (const marker of editor.model.markers) {
      if (!marker._affectsData) {
        continue;
      }
      data.markers[marker.name] = {
        rangeJSON: marker.getRange().toJSON(),
        usingOperation: marker._managedUsingOperations,
        affectsData: marker._affectsData
      };
    }
    if (commentsRepository) {
      data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({toJSON: true, skipNotAttached: true}));
    }
    if (trackChanges) {
      data.suggestions = JSON.stringify(trackChanges.getSuggestions({toJSON: true, skipNotAttached: true}));
    }
    return data;
  }
  _getEditables() {
    const editables = {};
    for (const rootName of this.editor.model.document.getRootNames()) {
      const editable = this.editor.ui.getEditableElement(rootName);
      if (editable) {
        editables[rootName] = editable;
      }
    }
    return editables;
  }
  _isErrorComingFromThisItem(error) {
    return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);
  }
  _cloneEditorConfiguration(config) {
    return cloneDeepWith_default(config, (value, key) => {
      if (isElement_default(value)) {
        return value;
      }
      if (key === "context") {
        return value;
      }
    });
  }
};
var editorwatchdog_default = EditorWatchdog;
var EditorWatchdogInitPlugin = class {
  constructor(editor) {
    this.editor = editor;
    this._data = editor.config.get("_watchdogInitialData");
  }
  init() {
    this.editor.data.on("init", (evt) => {
      evt.stop();
      this.editor.model.enqueueChange({isUndoable: false}, (writer) => {
        this._restoreCollaborationData();
        this._restoreEditorData(writer);
      });
      this.editor.data.fire("ready");
    }, {priority: 1e3 - 1});
  }
  _createNode(writer, jsonNode) {
    if ("name" in jsonNode) {
      const element = writer.createElement(jsonNode.name, jsonNode.attributes);
      if (jsonNode.children) {
        for (const child of jsonNode.children) {
          element._appendChild(this._createNode(writer, child));
        }
      }
      return element;
    } else {
      return writer.createText(jsonNode.data, jsonNode.attributes);
    }
  }
  _restoreEditorData(writer) {
    const editor = this.editor;
    Object.entries(this._data.roots).forEach(([rootName, {content, attributes}]) => {
      const parsedNodes = JSON.parse(content);
      const parsedAttributes = JSON.parse(attributes);
      const rootElement = editor.model.document.getRoot(rootName);
      for (const [key, value] of parsedAttributes) {
        writer.setAttribute(key, value, rootElement);
      }
      for (const child of parsedNodes) {
        const node = this._createNode(writer, child);
        writer.insert(node, rootElement, "end");
      }
    });
    Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {
      const {document: document2} = editor.model;
      const {rangeJSON: {start, end}, ...options} = markerOptions;
      const root2 = document2.getRoot(start.root);
      const startPosition = writer.createPositionFromPath(root2, start.path, start.stickiness);
      const endPosition = writer.createPositionFromPath(root2, end.path, end.stickiness);
      const range = writer.createRange(startPosition, endPosition);
      writer.addMarker(markerName, {
        range,
        ...options
      });
    });
  }
  _restoreCollaborationData() {
    const parsedCommentThreads = JSON.parse(this._data.commentThreads);
    const parsedSuggestions = JSON.parse(this._data.suggestions);
    parsedCommentThreads.forEach((commentThreadData) => {
      const channelId = this.editor.config.get("collaboration.channelId");
      const commentsRepository = this.editor.plugins.get("CommentsRepository");
      if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {
        const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);
        commentThread.remove();
      }
      commentsRepository.addCommentThread({channelId, ...commentThreadData});
    });
    parsedSuggestions.forEach((suggestionData) => {
      const trackChangesEditing = this.editor.plugins.get("TrackChangesEditing");
      if (trackChangesEditing.hasSuggestion(suggestionData.id)) {
        const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);
        suggestion.attributes = suggestionData.attributes;
      } else {
        trackChangesEditing.addSuggestionData(suggestionData);
      }
    });
  }
};

// node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var mainQueueId = Symbol("MainQueueId");
var ContextWatchdog = class extends watchdog_default {
  constructor(Context2, watchdogConfig = {}) {
    super(watchdogConfig);
    this._watchdogs = new Map();
    this._context = null;
    this._contextProps = new Set();
    this._actionQueues = new ActionQueues();
    this._watchdogConfig = watchdogConfig;
    this._creator = (contextConfig) => Context2.create(contextConfig);
    this._destructor = (context) => context.destroy();
    this._actionQueues.onEmpty(() => {
      if (this.state === "initializing") {
        this.state = "ready";
        this._fire("stateChange");
      }
    });
  }
  setCreator(creator) {
    this._creator = creator;
  }
  setDestructor(destructor) {
    this._destructor = destructor;
  }
  get context() {
    return this._context;
  }
  create(contextConfig = {}) {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this._contextConfig = contextConfig;
      return this._create();
    });
  }
  getItem(itemId) {
    const watchdog = this._getWatchdog(itemId);
    return watchdog._item;
  }
  getItemState(itemId) {
    const watchdog = this._getWatchdog(itemId);
    return watchdog.state;
  }
  add(itemConfigurationOrItemConfigurations) {
    const itemConfigurations = toArray2(itemConfigurationOrItemConfigurations);
    return Promise.all(itemConfigurations.map((item) => {
      return this._actionQueues.enqueue(item.id, () => {
        if (this.state === "destroyed") {
          throw new Error("Cannot add items to destroyed watchdog.");
        }
        if (!this._context) {
          throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
        }
        let watchdog;
        if (this._watchdogs.has(item.id)) {
          throw new Error(`Item with the given id is already added: '${item.id}'.`);
        }
        if (item.type === "editor") {
          watchdog = new editorwatchdog_default(null, this._watchdogConfig);
          watchdog.setCreator(item.creator);
          watchdog._setExcludedProperties(this._contextProps);
          if (item.destructor) {
            watchdog.setDestructor(item.destructor);
          }
          this._watchdogs.set(item.id, watchdog);
          watchdog.on("error", (evt, {error, causesRestart}) => {
            this._fire("itemError", {itemId: item.id, error});
            if (!causesRestart) {
              return;
            }
            this._actionQueues.enqueue(item.id, () => new Promise((res) => {
              const rethrowRestartEventOnce = () => {
                watchdog.off("restart", rethrowRestartEventOnce);
                this._fire("itemRestart", {itemId: item.id});
                res();
              };
              watchdog.on("restart", rethrowRestartEventOnce);
            }));
          });
          return watchdog.create(item.sourceElementOrData, item.config, this._context);
        } else {
          throw new Error(`Not supported item type: '${item.type}'.`);
        }
      });
    }));
  }
  remove(itemIdOrItemIds) {
    const itemIds = toArray2(itemIdOrItemIds);
    return Promise.all(itemIds.map((itemId) => {
      return this._actionQueues.enqueue(itemId, () => {
        const watchdog = this._getWatchdog(itemId);
        this._watchdogs.delete(itemId);
        return watchdog.destroy();
      });
    }));
  }
  destroy() {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this.state = "destroyed";
      this._fire("stateChange");
      super.destroy();
      return this._destroy();
    });
  }
  _restart() {
    return this._actionQueues.enqueue(mainQueueId, () => {
      this.state = "initializing";
      this._fire("stateChange");
      return this._destroy().catch((err) => {
        console.error("An error happened during destroying the context or items.", err);
      }).then(() => this._create()).then(() => this._fire("restart"));
    });
  }
  _create() {
    return Promise.resolve().then(() => {
      this._startErrorHandling();
      return this._creator(this._contextConfig);
    }).then((context) => {
      this._context = context;
      this._contextProps = getSubNodes(this._context);
      return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => {
        watchdog._setExcludedProperties(this._contextProps);
        return watchdog.create(void 0, void 0, this._context);
      }));
    });
  }
  _destroy() {
    return Promise.resolve().then(() => {
      this._stopErrorHandling();
      const context = this._context;
      this._context = null;
      this._contextProps = new Set();
      return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => watchdog.destroy())).then(() => this._destructor(context));
    });
  }
  _getWatchdog(itemId) {
    const watchdog = this._watchdogs.get(itemId);
    if (!watchdog) {
      throw new Error(`Item with the given id was not registered: ${itemId}.`);
    }
    return watchdog;
  }
  _isErrorComingFromThisItem(error) {
    for (const watchdog of this._watchdogs.values()) {
      if (watchdog._isErrorComingFromThisItem(error)) {
        return false;
      }
    }
    return areConnectedThroughProperties(this._context, error.context);
  }
};
var contextwatchdog_default = ContextWatchdog;
var ActionQueues = class {
  constructor() {
    this._onEmptyCallbacks = [];
    this._queues = new Map();
    this._activeActions = 0;
  }
  onEmpty(onEmptyCallback) {
    this._onEmptyCallbacks.push(onEmptyCallback);
  }
  enqueue(queueId, action) {
    const isMainAction = queueId === mainQueueId;
    this._activeActions++;
    if (!this._queues.get(queueId)) {
      this._queues.set(queueId, Promise.resolve());
    }
    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);
    const queueWithAction = awaitedActions.then(action);
    const nonErrorQueue = queueWithAction.catch(() => {
    });
    this._queues.set(queueId, nonErrorQueue);
    return queueWithAction.finally(() => {
      this._activeActions--;
      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {
        this._onEmptyCallbacks.forEach((cb) => cb());
      }
    });
  }
};
function toArray2(elementOrArray) {
  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];
}

// node_modules/@ckeditor/ckeditor5-watchdog/src/augmentation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-watchdog/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/ckeditor5/src/watchdog.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var ClassicEditor = class extends DataApiMixin(ElementApiMixin(editor_default)) {
  constructor(sourceElementOrData, config = {}) {
    if (!isElement2(sourceElementOrData) && config.initialData !== void 0) {
      throw new ckeditorerror_default("editor-create-initial-data", null);
    }
    super(config);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData(sourceElementOrData));
    }
    if (isElement2(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
    }
    this.model.document.createRoot();
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const view = new classiceditoruiview_default(this.locale, this.editing.view, {
      shouldToolbarGroupWhenFull
    });
    this.ui = new classiceditorui_default(this, view);
    attachToForm(this);
  }
  destroy() {
    if (this.sourceElement) {
      this.updateSourceElement();
    }
    this.ui.destroy();
    return super.destroy();
  }
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init(isElement2(sourceElementOrData) ? sourceElementOrData : null)).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
var classiceditor_default = ClassicEditor;
ClassicEditor.Context = context_default;
ClassicEditor.EditorWatchdog = editorwatchdog_default;
ClassicEditor.ContextWatchdog = contextwatchdog_default;
function getInitialData(sourceElementOrData) {
  return isElement2(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement2(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-classic/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-editor-inline/src/inlineeditorui.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InlineEditorUI = class extends editorui_default {
  constructor(editor, view) {
    super(editor);
    this.view = view;
    this._toolbarConfig = normalizeToolbarConfig(editor.config.get("toolbar"));
  }
  get element() {
    return this.view.editable.element;
  }
  init() {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    this._initPlaceholder();
    this._initToolbar();
    this.fire("ready");
  }
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    editingView.detachDomRoot(view.editable.name);
    view.destroy();
  }
  _initToolbar() {
    const editor = this.editor;
    const view = this.view;
    const editableElement = view.editable.element;
    const toolbar = view.toolbar;
    view.panel.bind("isVisible").to(this.focusTracker, "isFocused");
    view.bind("viewportTopOffset").to(this, "viewportOffset", ({top}) => top || 0);
    view.listenTo(editor.ui, "update", () => {
      if (view.panel.isVisible) {
        view.panel.pin({
          target: editableElement,
          positions: view.panelPositions
        });
      }
    });
    toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
    this.addToolbar(toolbar);
  }
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      const placeholderText = typeof placeholder === "string" ? placeholder : placeholder[editingRoot.rootName];
      if (placeholderText) {
        editingRoot.placeholder = placeholderText;
      }
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var inlineeditorui_default = InlineEditorUI;

// node_modules/@ckeditor/ckeditor5-editor-inline/src/inlineeditoruiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var toPx7 = toUnit("px");
var InlineEditorUIView = class extends editoruiview_default {
  constructor(locale, editingView, editableElement, options = {}) {
    super(locale);
    const t = locale.t;
    this.toolbar = new toolbarview_default(locale, {
      shouldGroupWhenFull: options.shouldToolbarGroupWhenFull,
      isFloating: true
    });
    this.set("viewportTopOffset", 0);
    this.panel = new balloonpanelview_default(locale);
    this.panelPositions = this._getPanelPositions();
    this.panel.extendTemplate({
      attributes: {
        class: "ck-toolbar-container"
      }
    });
    this.editable = new inlineeditableuiview_default(locale, editingView, editableElement, {
      label: (editableView) => {
        return t("Rich Text Editor. Editing area: %0", editableView.name);
      }
    });
    this._resizeObserver = null;
  }
  render() {
    super.render();
    this.body.add(this.panel);
    this.registerChild(this.editable);
    this.panel.content.add(this.toolbar);
    const options = this.toolbar.options;
    if (options.shouldGroupWhenFull) {
      const editableElement = this.editable.element;
      this._resizeObserver = new resizeobserver_default(editableElement, () => {
        this.toolbar.maxWidth = toPx7(new rect_default(editableElement).width);
      });
    }
  }
  destroy() {
    super.destroy();
    if (this._resizeObserver) {
      this._resizeObserver.destroy();
    }
  }
  _getPanelPositionTop(editableRect, panelRect) {
    let top;
    if (editableRect.top > panelRect.height + this.viewportTopOffset) {
      top = editableRect.top - panelRect.height;
    } else if (editableRect.bottom > panelRect.height + this.viewportTopOffset + 50) {
      top = this.viewportTopOffset;
    } else {
      top = editableRect.bottom;
    }
    return top;
  }
  _getPanelPositions() {
    const positions = [
      (editableRect, panelRect) => {
        return {
          top: this._getPanelPositionTop(editableRect, panelRect),
          left: editableRect.left,
          name: "toolbar_west",
          config: {
            withArrow: false
          }
        };
      },
      (editableRect, panelRect) => {
        return {
          top: this._getPanelPositionTop(editableRect, panelRect),
          left: editableRect.left + editableRect.width - panelRect.width,
          name: "toolbar_east",
          config: {
            withArrow: false
          }
        };
      }
    ];
    if (this.locale.uiLanguageDirection === "ltr") {
      return positions;
    } else {
      return positions.reverse();
    }
  }
};
var inlineeditoruiview_default = InlineEditorUIView;

// node_modules/@ckeditor/ckeditor5-editor-inline/src/inlineeditor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var InlineEditor = class extends DataApiMixin(ElementApiMixin(editor_default)) {
  constructor(sourceElementOrData, config = {}) {
    if (!isElement3(sourceElementOrData) && config.initialData !== void 0) {
      throw new ckeditorerror_default("editor-create-initial-data", null);
    }
    super(config);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData2(sourceElementOrData));
    }
    this.model.document.createRoot();
    if (isElement3(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
      secureSourceElement(this, sourceElementOrData);
    }
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const view = new inlineeditoruiview_default(this.locale, this.editing.view, this.sourceElement, {
      shouldToolbarGroupWhenFull
    });
    this.ui = new inlineeditorui_default(this, view);
    attachToForm(this);
  }
  destroy() {
    const data = this.getData();
    this.ui.destroy();
    return super.destroy().then(() => {
      if (this.sourceElement) {
        this.updateSourceElement(data);
      }
    });
  }
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      if (isElement3(sourceElementOrData) && sourceElementOrData.tagName === "TEXTAREA") {
        throw new ckeditorerror_default("editor-wrong-element", null);
      }
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
var inlineeditor_default = InlineEditor;
InlineEditor.Context = context_default;
InlineEditor.EditorWatchdog = editorwatchdog_default;
InlineEditor.ContextWatchdog = contextwatchdog_default;
function getInitialData2(sourceElementOrData) {
  return isElement3(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement3(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-inline/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-editor-balloon/src/ballooneditorui.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BalloonEditorUI = class extends editorui_default {
  constructor(editor, view) {
    super(editor);
    this.view = view;
  }
  get element() {
    return this.view.editable.element;
  }
  init() {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    this._initPlaceholder();
    this.fire("ready");
  }
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    editingView.detachDomRoot(view.editable.name);
    view.destroy();
  }
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      const placeholderText = typeof placeholder === "string" ? placeholder : placeholder[editingRoot.rootName];
      if (placeholderText) {
        editingRoot.placeholder = placeholderText;
      }
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var ballooneditorui_default = BalloonEditorUI;

// node_modules/@ckeditor/ckeditor5-editor-balloon/src/ballooneditoruiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BalloonEditorUIView = class extends editoruiview_default {
  constructor(locale, editingView, editableElement) {
    super(locale);
    const t = locale.t;
    this.editable = new inlineeditableuiview_default(locale, editingView, editableElement, {
      label: (editableView) => {
        return t("Rich Text Editor. Editing area: %0", editableView.name);
      }
    });
  }
  render() {
    super.render();
    this.registerChild(this.editable);
  }
};
var ballooneditoruiview_default = BalloonEditorUIView;

// node_modules/@ckeditor/ckeditor5-editor-balloon/src/ballooneditor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var BalloonEditor = class extends DataApiMixin(ElementApiMixin(editor_default)) {
  constructor(sourceElementOrData, config = {}) {
    if (!isElement4(sourceElementOrData) && config.initialData !== void 0) {
      throw new ckeditorerror_default("editor-create-initial-data", null);
    }
    super(config);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData3(sourceElementOrData));
    }
    if (isElement4(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
      secureSourceElement(this, sourceElementOrData);
    }
    const plugins = this.config.get("plugins");
    plugins.push(balloontoolbar_default);
    this.config.set("plugins", plugins);
    this.config.define("balloonToolbar", this.config.get("toolbar"));
    this.model.document.createRoot();
    const view = new ballooneditoruiview_default(this.locale, this.editing.view, this.sourceElement);
    this.ui = new ballooneditorui_default(this, view);
    attachToForm(this);
  }
  destroy() {
    const data = this.getData();
    this.ui.destroy();
    return super.destroy().then(() => {
      if (this.sourceElement) {
        this.updateSourceElement(data);
      }
    });
  }
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      if (isElement4(sourceElementOrData) && sourceElementOrData.tagName === "TEXTAREA") {
        throw new ckeditorerror_default("editor-wrong-element", null);
      }
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
var ballooneditor_default = BalloonEditor;
BalloonEditor.Context = context_default;
BalloonEditor.EditorWatchdog = editorwatchdog_default;
BalloonEditor.ContextWatchdog = contextwatchdog_default;
function getInitialData3(sourceElementOrData) {
  return isElement4(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement4(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-balloon/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-editor-decoupled/src/decouplededitorui.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DecoupledEditorUI = class extends editorui_default {
  constructor(editor, view) {
    super(editor);
    this.view = view;
  }
  init() {
    const editor = this.editor;
    const view = this.view;
    const editingView = editor.editing.view;
    const editable = view.editable;
    const editingRoot = editingView.document.getRoot();
    editable.name = editingRoot.rootName;
    view.render();
    const editableElement = editable.element;
    this.setEditableElement(editable.name, editableElement);
    view.editable.bind("isFocused").to(this.focusTracker);
    editingView.attachDomRoot(editableElement);
    this._initPlaceholder();
    this._initToolbar();
    this.fire("ready");
  }
  destroy() {
    super.destroy();
    const view = this.view;
    const editingView = this.editor.editing.view;
    editingView.detachDomRoot(view.editable.name);
    view.destroy();
  }
  _initToolbar() {
    const editor = this.editor;
    const view = this.view;
    const toolbar = view.toolbar;
    toolbar.fillFromConfig(editor.config.get("toolbar"), this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  _initPlaceholder() {
    const editor = this.editor;
    const editingView = editor.editing.view;
    const editingRoot = editingView.document.getRoot();
    const placeholder = editor.config.get("placeholder");
    if (placeholder) {
      const placeholderText = typeof placeholder === "string" ? placeholder : placeholder[editingRoot.rootName];
      if (placeholderText) {
        editingRoot.placeholder = placeholderText;
      }
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var decouplededitorui_default = DecoupledEditorUI;

// node_modules/@ckeditor/ckeditor5-editor-decoupled/src/decouplededitoruiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DecoupledEditorUIView = class extends editoruiview_default {
  constructor(locale, editingView, options = {}) {
    super(locale);
    const t = locale.t;
    this.toolbar = new toolbarview_default(locale, {
      shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
    });
    this.editable = new inlineeditableuiview_default(locale, editingView, options.editableElement, {
      label: (editableView) => {
        return t("Rich Text Editor. Editing area: %0", editableView.name);
      }
    });
    this.toolbar.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: locale.uiLanguageDirection
      }
    });
  }
  render() {
    super.render();
    this.registerChild([this.toolbar, this.editable]);
  }
};
var decouplededitoruiview_default = DecoupledEditorUIView;

// node_modules/@ckeditor/ckeditor5-editor-decoupled/src/decouplededitor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var DecoupledEditor = class extends DataApiMixin(ElementApiMixin(editor_default)) {
  constructor(sourceElementOrData, config = {}) {
    if (!isElement5(sourceElementOrData) && config.initialData !== void 0) {
      throw new ckeditorerror_default("editor-create-initial-data", null);
    }
    super(config);
    if (this.config.get("initialData") === void 0) {
      this.config.set("initialData", getInitialData4(sourceElementOrData));
    }
    if (isElement5(sourceElementOrData)) {
      this.sourceElement = sourceElementOrData;
      secureSourceElement(this, sourceElementOrData);
    }
    this.model.document.createRoot();
    const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
    const view = new decouplededitoruiview_default(this.locale, this.editing.view, {
      editableElement: this.sourceElement,
      shouldToolbarGroupWhenFull
    });
    this.ui = new decouplededitorui_default(this, view);
  }
  destroy() {
    const data = this.getData();
    this.ui.destroy();
    return super.destroy().then(() => {
      if (this.sourceElement) {
        this.updateSourceElement(data);
      }
    });
  }
  static create(sourceElementOrData, config = {}) {
    return new Promise((resolve) => {
      if (isElement5(sourceElementOrData) && sourceElementOrData.tagName === "TEXTAREA") {
        throw new ckeditorerror_default("editor-wrong-element", null);
      }
      const editor = new this(sourceElementOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
    });
  }
};
var decouplededitor_default = DecoupledEditor;
DecoupledEditor.Context = context_default;
DecoupledEditor.EditorWatchdog = editorwatchdog_default;
DecoupledEditor.ContextWatchdog = contextwatchdog_default;
function getInitialData4(sourceElementOrData) {
  return isElement5(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement5(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-decoupled/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-editor-multi-root/src/multirooteditorui.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MultiRootEditorUI = class extends editorui_default {
  constructor(editor, view) {
    super(editor);
    this.view = view;
    this._lastFocusedEditableElement = null;
  }
  init() {
    const view = this.view;
    view.render();
    this.focusTracker.on("change:focusedElement", (evt, name, focusedElement) => {
      for (const editable of Object.values(this.view.editables)) {
        if (focusedElement === editable.element) {
          this._lastFocusedEditableElement = editable.element;
        }
      }
    });
    this.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
      if (!isFocused) {
        this._lastFocusedEditableElement = null;
      }
    });
    for (const editable of Object.values(this.view.editables)) {
      this.addEditable(editable);
    }
    this._initToolbar();
    this.fire("ready");
  }
  addEditable(editable, placeholder) {
    const editableElement = editable.element;
    this.editor.editing.view.attachDomRoot(editableElement, editable.name);
    this.setEditableElement(editable.name, editableElement);
    editable.bind("isFocused").to(this.focusTracker, "isFocused", this.focusTracker, "focusedElement", (isFocused, focusedElement) => {
      if (!isFocused) {
        return false;
      }
      if (focusedElement === editableElement) {
        return true;
      } else {
        return this._lastFocusedEditableElement === editableElement;
      }
    });
    this._initPlaceholder(editable, placeholder);
  }
  removeEditable(editable) {
    this.editor.editing.view.detachDomRoot(editable.name);
    editable.unbind("isFocused");
    this.removeEditableElement(editable.name);
  }
  destroy() {
    super.destroy();
    for (const editable of Object.values(this.view.editables)) {
      this.removeEditable(editable);
    }
    this.view.destroy();
  }
  _initToolbar() {
    const editor = this.editor;
    const view = this.view;
    const toolbar = view.toolbar;
    toolbar.fillFromConfig(editor.config.get("toolbar"), this.componentFactory);
    this.addToolbar(view.toolbar);
  }
  _initPlaceholder(editable, placeholder) {
    if (!placeholder) {
      const configPlaceholder = this.editor.config.get("placeholder");
      if (configPlaceholder) {
        placeholder = typeof configPlaceholder === "string" ? configPlaceholder : configPlaceholder[editable.name];
      }
    }
    const editingView = this.editor.editing.view;
    const editingRoot = editingView.document.getRoot(editable.name);
    if (placeholder) {
      editingRoot.placeholder = placeholder;
    }
    enablePlaceholder({
      view: editingView,
      element: editingRoot,
      isDirectHost: false,
      keepOnFocus: true
    });
  }
};
var multirooteditorui_default = MultiRootEditorUI;

// node_modules/@ckeditor/ckeditor5-editor-multi-root/src/multirooteditoruiview.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MultiRootEditorUIView = class extends editoruiview_default {
  constructor(locale, editingView, editableNames, options = {}) {
    super(locale);
    this._editingView = editingView;
    this.toolbar = new toolbarview_default(locale, {
      shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
    });
    this.editables = {};
    for (const editableName of editableNames) {
      const editableElement = options.editableElements ? options.editableElements[editableName] : void 0;
      this.createEditable(editableName, editableElement);
    }
    this.editable = Object.values(this.editables)[0];
    this.toolbar.extendTemplate({
      attributes: {
        class: [
          "ck-reset_all",
          "ck-rounded-corners"
        ],
        dir: locale.uiLanguageDirection
      }
    });
  }
  createEditable(editableName, editableElement) {
    const t = this.locale.t;
    const editable = new inlineeditableuiview_default(this.locale, this._editingView, editableElement, {
      label: (editable2) => {
        return t("Rich Text Editor. Editing area: %0", editable2.name);
      }
    });
    this.editables[editableName] = editable;
    editable.name = editableName;
    if (this.isRendered) {
      this.registerChild(editable);
    }
    return editable;
  }
  removeEditable(editableName) {
    const editable = this.editables[editableName];
    if (this.isRendered) {
      this.deregisterChild(editable);
    }
    delete this.editables[editableName];
    editable.destroy();
  }
  render() {
    super.render();
    this.registerChild(Object.values(this.editables));
    this.registerChild(this.toolbar);
  }
};
var multirooteditoruiview_default = MultiRootEditorUIView;

// node_modules/@ckeditor/ckeditor5-editor-multi-root/src/multirooteditor.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
var MultiRootEditor = class extends DataApiMixin(editor_default) {
  constructor(sourceElementsOrData, config = {}) {
    const rootNames = Object.keys(sourceElementsOrData);
    const sourceIsData = rootNames.length === 0 || typeof sourceElementsOrData[rootNames[0]] === "string";
    if (sourceIsData && config.initialData !== void 0 && Object.keys(config.initialData).length > 0) {
      throw new ckeditorerror_default("editor-create-initial-data", null);
    }
    super(config);
    this._registeredRootsAttributesKeys = new Set();
    this._readOnlyRootLocks = new Map();
    if (!sourceIsData) {
      this.sourceElements = sourceElementsOrData;
    } else {
      this.sourceElements = {};
    }
    if (this.config.get("initialData") === void 0) {
      const initialData = {};
      for (const rootName of rootNames) {
        initialData[rootName] = getInitialData5(sourceElementsOrData[rootName]);
      }
      this.config.set("initialData", initialData);
    }
    if (!sourceIsData) {
      for (const rootName of rootNames) {
        secureSourceElement(this, sourceElementsOrData[rootName]);
      }
    }
    this.editing.view.document.roots.on("add", (evt, viewRoot) => {
      viewRoot.unbind("isReadOnly");
      viewRoot.bind("isReadOnly").to(this.editing.view.document, "isReadOnly", (isReadOnly) => {
        return isReadOnly || this._readOnlyRootLocks.has(viewRoot.rootName);
      });
      viewRoot.on("change:isReadOnly", (evt2, prop, value) => {
        const viewRange = this.editing.view.createRangeIn(viewRoot);
        for (const viewItem of viewRange.getItems()) {
          if (viewItem.is("editableElement")) {
            viewItem.unbind("isReadOnly");
            viewItem.isReadOnly = value;
          }
        }
      });
    });
    for (const rootName of rootNames) {
      this.model.document.createRoot("$root", rootName);
    }
    if (this.config.get("lazyRoots")) {
      for (const rootName of this.config.get("lazyRoots")) {
        const root2 = this.model.document.createRoot("$root", rootName);
        root2._isLoaded = false;
      }
    }
    if (this.config.get("rootsAttributes")) {
      const rootsAttributes = this.config.get("rootsAttributes");
      for (const [rootName, attributes] of Object.entries(rootsAttributes)) {
        if (!this.model.document.getRoot(rootName)) {
          throw new ckeditorerror_default("multi-root-editor-root-attributes-no-root", null);
        }
        for (const key of Object.keys(attributes)) {
          this._registeredRootsAttributesKeys.add(key);
        }
      }
      this.data.on("init", () => {
        this.model.enqueueChange({isUndoable: false}, (writer) => {
          for (const [name, attributes] of Object.entries(rootsAttributes)) {
            const root2 = this.model.document.getRoot(name);
            for (const [key, value] of Object.entries(attributes)) {
              if (value !== null) {
                writer.setAttribute(key, value, root2);
              }
            }
          }
        });
      });
    }
    const options = {
      shouldToolbarGroupWhenFull: !this.config.get("toolbar.shouldNotGroupWhenFull"),
      editableElements: sourceIsData ? void 0 : sourceElementsOrData
    };
    const view = new multirooteditoruiview_default(this.locale, this.editing.view, rootNames, options);
    this.ui = new multirooteditorui_default(this, view);
    this.model.document.on("change:data", () => {
      const changedRoots = this.model.document.differ.getChangedRoots();
      for (const changes of changedRoots) {
        const root2 = this.model.document.getRoot(changes.name);
        if (changes.state == "detached") {
          this.fire("detachRoot", root2);
        }
      }
      for (const changes of changedRoots) {
        const root2 = this.model.document.getRoot(changes.name);
        if (changes.state == "attached") {
          this.fire("addRoot", root2);
        }
      }
    });
    this.listenTo(this.model, "canEditAt", (evt, [selection]) => {
      if (!selection) {
        return;
      }
      let selectionInReadOnlyRoot = false;
      for (const range of selection.getRanges()) {
        const root2 = range.root;
        if (this._readOnlyRootLocks.has(root2.rootName)) {
          selectionInReadOnlyRoot = true;
          break;
        }
      }
      if (selectionInReadOnlyRoot) {
        evt.return = false;
        evt.stop();
      }
    }, {priority: "high"});
    this.decorate("loadRoot");
    this.on("loadRoot", (evt, [rootName]) => {
      const root2 = this.model.document.getRoot(rootName);
      if (!root2) {
        throw new ckeditorerror_default("multi-root-editor-load-root-no-root", this, {rootName});
      }
      if (root2._isLoaded) {
        logWarning("multi-root-editor-load-root-already-loaded");
        evt.stop();
      }
    }, {priority: "highest"});
  }
  destroy() {
    const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
    const data = {};
    for (const rootName of Object.keys(this.sourceElements)) {
      data[rootName] = shouldUpdateSourceElement ? this.getData({rootName}) : "";
    }
    this.ui.destroy();
    return super.destroy().then(() => {
      for (const rootName of Object.keys(this.sourceElements)) {
        setDataInElement(this.sourceElements[rootName], data[rootName]);
      }
    });
  }
  addRoot(rootName, {data = "", attributes = {}, elementName = "$root", isUndoable = false} = {}) {
    const dataController = this.data;
    const registeredKeys = this._registeredRootsAttributesKeys;
    if (isUndoable) {
      this.model.change(_addRoot);
    } else {
      this.model.enqueueChange({isUndoable: false}, _addRoot);
    }
    function _addRoot(writer) {
      const root2 = writer.addRoot(rootName, elementName);
      if (data) {
        writer.insert(dataController.parse(data, root2), root2, 0);
      }
      for (const key of Object.keys(attributes)) {
        registeredKeys.add(key);
        writer.setAttribute(key, attributes[key], root2);
      }
    }
  }
  detachRoot(rootName, isUndoable = false) {
    if (isUndoable) {
      this.model.change((writer) => writer.detachRoot(rootName));
    } else {
      this.model.enqueueChange({isUndoable: false}, (writer) => writer.detachRoot(rootName));
    }
  }
  createEditable(root2, placeholder) {
    const editable = this.ui.view.createEditable(root2.rootName);
    this.ui.addEditable(editable, placeholder);
    this.editing.view.forceRender();
    return editable.element;
  }
  detachEditable(root2) {
    const rootName = root2.rootName;
    const editable = this.ui.view.editables[rootName];
    this.ui.removeEditable(editable);
    this.ui.view.removeEditable(rootName);
    return editable.element;
  }
  loadRoot(rootName, {data = "", attributes = {}} = {}) {
    const root2 = this.model.document.getRoot(rootName);
    this.model.enqueueChange({isUndoable: false}, (writer) => {
      if (data) {
        writer.insert(this.data.parse(data, root2), root2, 0);
      }
      for (const key of Object.keys(attributes)) {
        this._registeredRootsAttributesKeys.add(key);
        writer.setAttribute(key, attributes[key], root2);
      }
      root2._isLoaded = true;
      this.model.document.differ._bufferRootLoad(root2);
    });
  }
  getFullData(options) {
    const data = {};
    for (const rootName of this.model.document.getRootNames()) {
      data[rootName] = this.data.get({...options, rootName});
    }
    return data;
  }
  getRootsAttributes() {
    const rootsAttributes = {};
    for (const rootName of this.model.document.getRootNames()) {
      rootsAttributes[rootName] = this.getRootAttributes(rootName);
    }
    return rootsAttributes;
  }
  getRootAttributes(rootName) {
    const rootAttributes = {};
    const root2 = this.model.document.getRoot(rootName);
    for (const key of this._registeredRootsAttributesKeys) {
      rootAttributes[key] = root2.hasAttribute(key) ? root2.getAttribute(key) : null;
    }
    return rootAttributes;
  }
  disableRoot(rootName, lockId) {
    if (rootName == "$graveyard") {
      throw new ckeditorerror_default("multi-root-editor-cannot-disable-graveyard-root", this);
    }
    const locksForGivenRoot = this._readOnlyRootLocks.get(rootName);
    if (locksForGivenRoot) {
      locksForGivenRoot.add(lockId);
    } else {
      this._readOnlyRootLocks.set(rootName, new Set([lockId]));
      const editableRootElement = this.editing.view.document.getRoot(rootName);
      editableRootElement.isReadOnly = true;
      Array.from(this.commands.commands()).forEach((command) => command.affectsData && command.refresh());
    }
  }
  enableRoot(rootName, lockId) {
    const locksForGivenRoot = this._readOnlyRootLocks.get(rootName);
    if (!locksForGivenRoot || !locksForGivenRoot.has(lockId)) {
      return;
    }
    if (locksForGivenRoot.size === 1) {
      this._readOnlyRootLocks.delete(rootName);
      const editableRootElement = this.editing.view.document.getRoot(rootName);
      editableRootElement.isReadOnly = this.isReadOnly;
      Array.from(this.commands.commands()).forEach((command) => command.affectsData && command.refresh());
    } else {
      locksForGivenRoot.delete(lockId);
    }
  }
  static create(sourceElementsOrData, config = {}) {
    return new Promise((resolve) => {
      for (const sourceItem of Object.values(sourceElementsOrData)) {
        if (isElement6(sourceItem) && sourceItem.tagName === "TEXTAREA") {
          throw new ckeditorerror_default("editor-wrong-element", null);
        }
      }
      const editor = new this(sourceElementsOrData, config);
      resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => {
        editor._verifyRootsWithInitialData();
        return editor.data.init(editor.config.get("initialData"));
      }).then(() => editor.fire("ready")).then(() => editor));
    });
  }
  _verifyRootsWithInitialData() {
    const initialData = this.config.get("initialData");
    for (const rootName of this.model.document.getRootNames()) {
      if (!(rootName in initialData)) {
        throw new ckeditorerror_default("multi-root-editor-root-initial-data-mismatch", null);
      }
    }
    for (const rootName of Object.keys(initialData)) {
      const root2 = this.model.document.getRoot(rootName);
      if (!root2 || !root2.isAttached()) {
        throw new ckeditorerror_default("multi-root-editor-root-initial-data-mismatch", null);
      }
    }
  }
};
var multirooteditor_default = MultiRootEditor;
MultiRootEditor.Context = context_default;
MultiRootEditor.EditorWatchdog = editorwatchdog_default;
MultiRootEditor.ContextWatchdog = contextwatchdog_default;
function getInitialData5(sourceElementOrData) {
  return isElement6(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
function isElement6(value) {
  return isElement_default(value);
}

// node_modules/@ckeditor/ckeditor5-editor-multi-root/src/augmentation.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

// node_modules/@ckeditor/ckeditor5-editor-multi-root/src/index.js
/**
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
export {
  attributeelement_default as AttributeElement,
  attributeoperation_default as AttributeOperation,
  autocompleteview_default as AutocompleteView,
  ballooneditor_default as Balloon,
  balloonpanelview_default as BalloonPanelView,
  balloontoolbar_default as BalloonToolbar,
  blocktoolbar_default as BlockToolbar,
  bodycollection_default as BodyCollection,
  boxededitoruiview_default as BoxedEditorUIView,
  bubblingeventinfo_default as BubblingEventInfo,
  buttonlabelview_default as ButtonLabelView,
  buttonview_default as ButtonView,
  ckeditorerror_default as CKEditorError,
  classiceditor_default as Classic,
  clickobserver_default as ClickObserver,
  collection_default as Collection,
  colorgridview_default as ColorGridView,
  colorpickerview_default as ColorPickerView,
  colorselectorview_default as ColorSelectorView,
  colortileview_default as ColorTileView,
  command_default as Command,
  componentfactory_default as ComponentFactory,
  config_default as Config,
  context_default as Context,
  contextplugin_default as ContextPlugin,
  contextualballoon_default as ContextualBalloon,
  conversion_default as Conversion,
  CssTransitionDisablerMixin,
  DataApiMixin,
  datacontroller_default as DataController,
  datatransfer_default as DataTransfer,
  decouplededitor_default as Decoupled,
  documentfragment_default2 as DocumentFragment,
  documentselection_default2 as DocumentSelection,
  domconverter_default as DomConverter,
  DomEmitterMixin,
  domeventdata_default as DomEventData,
  domeventobserver_default as DomEventObserver,
  downcastwriter_default as DowncastWriter,
  dropdownbuttonview_default as DropdownButtonView,
  dropdownpanelview_default as DropdownPanelView,
  dropdownview_default as DropdownView,
  editingcontroller_default as EditingController,
  editor_default as Editor,
  editorui_default as EditorUI,
  editoruiview_default as EditorUIView,
  element_default2 as Element,
  ElementApiMixin,
  elementreplacer_default as ElementReplacer,
  EmitterMixin,
  eventinfo_default as EventInfo,
  focuscycler_default as FocusCycler,
  focusobserver_default as FocusObserver,
  focustracker_default as FocusTracker,
  formheaderview_default as FormHeaderView,
  highlightedtextview_default as HighlightedTextView,
  history_default as History,
  htmldataprocessor_default as HtmlDataProcessor,
  iconview_default as IconView,
  iframeview_default as IframeView,
  inlineeditor_default as Inline,
  inlineeditableuiview_default as InlineEditableUIView,
  inputnumberview_default as InputNumberView,
  inputtextview_default as InputTextView,
  inputview_default as InputView,
  insertoperation_default as InsertOperation,
  keystrokehandler_default as KeystrokeHandler,
  labelview_default as LabelView,
  labeledfieldview_default as LabeledFieldView,
  listitemgroupview_default as ListItemGroupView,
  listitemview_default as ListItemView,
  listview_default as ListView,
  liveposition_default as LivePosition,
  liverange_default as LiveRange,
  locale_default as Locale,
  markeroperation_default as MarkerOperation,
  matcher_default as Matcher,
  mergeoperation_default as MergeOperation,
  model_default as Model,
  mouseobserver_default as MouseObserver,
  moveoperation_default as MoveOperation,
  multicommand_default as MultiCommand,
  multirooteditor_default as Multiroot,
  nooperation_default as NoOperation,
  notification_default as Notification,
  ObservableMixin,
  observer_default as Observer,
  operationfactory_default as OperationFactory,
  pendingactions_default as PendingActions,
  plugin_default as Plugin,
  position_default2 as Position,
  range_default2 as Range,
  rect_default as Rect,
  renameoperation_default as RenameOperation,
  renderer_default as Renderer,
  resizeobserver_default as ResizeObserver,
  rootattributeoperation_default as RootAttributeOperation,
  rootoperation_default as RootOperation,
  searchinfoview_default as SearchInfoView,
  searchtextview_default as SearchTextView,
  spinnerview_default as SpinnerView,
  splitbuttonview_default as SplitButtonView,
  splitoperation_default as SplitOperation,
  stickypanelview_default as StickyPanelView,
  StylesProcessor,
  switchbuttonview_default as SwitchButtonView,
  tabobserver_default as TabObserver,
  template_default as Template,
  text_default2 as Text,
  textproxy_default2 as TextProxy,
  textareaview_default as TextareaView,
  toolbarlinebreakview_default as ToolbarLineBreakView,
  toolbarseparatorview_default as ToolbarSeparatorView,
  toolbarview_default as ToolbarView,
  tooltipmanager_default as TooltipManager,
  treewalker_default2 as TreeWalker,
  upcastwriter_default as UpcastWriter,
  view_default2 as View,
  attributeelement_default as ViewAttributeElement,
  viewcollection_default as ViewCollection,
  containerelement_default as ViewContainerElement,
  document_default as ViewDocument,
  documentfragment_default as ViewDocumentFragment,
  editableelement_default as ViewEditableElement,
  element_default as ViewElement,
  emptyelement_default as ViewEmptyElement,
  rawelement_default as ViewRawElement,
  rooteditableelement_default as ViewRootEditableElement,
  text_default as ViewText,
  treewalker_default as ViewTreeWalker,
  uielement_default as ViewUIElement,
  addBackgroundRules,
  addBorderRules,
  addKeyboardHandlingForGrid,
  addListToDropdown,
  addMarginRules,
  addPaddingRules,
  addToolbarToDropdown,
  attachToForm,
  clickOutsideHandler,
  compareArrays,
  count,
  createDropdown,
  createElement,
  createLabeledDropdown,
  createLabeledInputNumber,
  createLabeledInputText,
  createLabeledTextarea,
  delay,
  diff,
  diffToChanges,
  disablePlaceholder,
  enablePlaceholder,
  env_default as env,
  fastDiff,
  findClosestScrollableAncestor,
  findOptimalInsertionRange,
  first,
  focusChildOnDropdownOpen,
  getAncestors,
  getBorderWidths,
  getBoxSidesShorthandValue,
  getBoxSidesValueReducer,
  getBoxSidesValues,
  getCode,
  getDataFromElement,
  getEnvKeystrokeText,
  getFillerOffset,
  getLanguageDirection,
  getLocalizedArrowKeyCodeDirection,
  getLocalizedColorOptions,
  getOptimalPosition,
  getPositionShorthandNormalizer,
  getShorthandValues,
  global_default as global,
  hidePlaceholder,
  icons,
  indexOf,
  injectCssTransitionDisabler,
  insertAt,
  insertToPriorityArray,
  isArrowKeyCode,
  isAttachment,
  isColor,
  isCombiningMark,
  isComment,
  isForwardArrowKeyCode,
  isHighSurrogateHalf,
  isInsideCombinedSymbol,
  isInsideEmojiSequence,
  isInsideSurrogatePair,
  isIterable,
  isLength2 as isLength,
  isLineStyle,
  isLowSurrogateHalf,
  isNode,
  isPercentage,
  isPosition,
  isRange,
  isRepeat,
  isText,
  isURL,
  isValidAttributeName,
  isVisible,
  keyCodes,
  logError,
  logWarning,
  mix,
  needsPlaceholder,
  normalizeColorOptions,
  normalizeSingleColorDefinition,
  normalizeToolbarConfig,
  parseKeystroke,
  priorities_default as priorities,
  releaseDate,
  remove,
  scrollAncestorsToShowTarget,
  scrollViewportToShowTarget,
  secureSourceElement,
  setDataInElement,
  showPlaceholder,
  spliceArray,
  submitHandler,
  toArray,
  toMap,
  toUnit,
  transformSets,
  uid,
  verifyLicense,
  version_default as version
};
